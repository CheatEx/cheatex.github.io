<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://cheatex.cc/" rel="self" type="application/rss+xml"/><title>cheatex</title><link>https://cheatex.cc/</link><description>Yet another personal site</description><lastBuildDate>Sat, 21 Sep 2019 18:23:38 +0300</lastBuildDate><generator>clj-rss</generator><item><guid>https://cheatex.cc/posts-output/2019-08-23-understanding-computation/</guid><link>https://cheatex.cc/posts-output/2019-08-23-understanding-computation/</link><title>Understanding computation</title><description>&lt;p&gt;Я в полном восторге от книги. По содержанию - это введение в теорию вычислений. По форме - пошаговые инструкции на руби по реализации разных интерпретаторов и виртуальных машин. Она состоит из трёх больших разделов.&lt;/p&gt;&lt;p&gt;Первый про языки и интерпретаторы. Пробуем по разному задать семантику языка, собрать синтаксическое дерево и написать простой интерпретатор. Возня с парсерами естественно решена одной рубёвой библиотекой.&lt;/p&gt;&lt;p&gt;Второй про модели вычислений. Всё классически: детерминированые-недетерминированные машины с состояниями, машины с состояниями и памятью, разбор языков с их помощью. Только собственно берём и программируем их. Машина Тьринга, лямбда-исчисление. Чувак реально пишет fizz-buzz на одних лямбдах! Не то чтобы я не верил другим книжкам, но вот прям взял и убедился что оно реально рaботает. Под конец рассказывает о SKI и еще нескольких экзотических моделях.&lt;/p&gt;&lt;p&gt;Третья часть больше про теорию. Кратко и уже только с эскизами кода рассматриваем решаемые/нерешаемые машиной Тьюринга задачи. Ковыряем задачу останова. Смотрим на некоторые опции model-checking и пишем простой чекер.&lt;/p&gt;&lt;p&gt;В общем всё самое интересное и хоть как-то соотносящееся с практикой программирования в одном издании. У меня новая #1 рекомендованная книга по CS.&lt;/p&gt;</description><pubDate>Fri, 23 Aug 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-06-03-elements-of-programming/</guid><link>https://cheatex.cc/posts-output/2019-06-03-elements-of-programming/</link><title>Начала программирования</title><description>&lt;p&gt;У меня уже лет 5 в закромах лежала довольно занимательная книга "Начала программирования" Степанова. Что характерно я её купил на книжном развале за старухой за 50 рублей. Где-то полгода назад почувствовал что борода стала достаточно густой чтобы попробовать её открыть.&lt;/p&gt;&lt;p&gt;Книга неплоха, но тяжела для чтения без необходимости.&lt;/p&gt;&lt;p&gt;Основное внимание уделено отношению между математическими концепциями, их выражением в ЯП и непосредственно структурами в памяти. Это довольно интересный топкик, обычно как в литературе таки и во всяких блого-конференциях один из аспектов начисто игнорируется. Содержание построено грамотно и в принципе старается идти от простого к сложному. Автор не пытается объять всё сразу, а плавно строит инструментарий и применяет его в простых но имеющих смысл для бывалого программиста задачах. Математические аспекты напоминаются бегло и немного путанно, видимо пару раз на почитать чтонить по алгебре придётся отвлечься.&lt;/p&gt;&lt;p&gt;Язык крайне тяжёл. Много собственной терминологии. Причём термины многословны и похожи, много времени тратится на листание назад в поисках определения. Можно было радикально упростить восприятие небольшими врезками с напоминанием терминологии.  Также не хватает диаграмм, особенно при обсуждении бифуркатных координат, переупорядочений и вспомогательных "машин". Пришлось много рисовать самому чтобы въехать.&lt;/p&gt;&lt;p&gt;В общем типичный экземпляр позднесоветской литературы. Если есть хорошее представление что хочешь от книги получить и тебе повезло быть с автором примерно на одной волне то можно подчерпнуть много интересных идей. Если нет - идите нахер, у нас тут фундаментальное образование, мы тут не развлекаться собрались, надо привыкать  страдать.&lt;/p&gt;&lt;p&gt;Эксперты рекомендуют для расширения сознания.&lt;/p&gt;</description><pubDate>Mon, 03 Jun 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-03-27-web-improved/</guid><link>https://cheatex.cc/posts-output/2019-03-27-web-improved/</link><title>The HTML we shouldn't ever have</title><description>&lt;p&gt;Мне попался &lt;a href='http://skch.net/view.php?page=articles&amp;post=bhtml'&gt;проект как сделать вэб лучше&lt;/a&gt; и что-то мне кажется проработан он весьма поверхностно...&lt;/p&gt;&lt;p&gt;Для начала автор сетует что аттрибут &lt;code&gt;src&lt;/code&gt; не был внедрён повсеместно, а только для &lt;code&gt;img&lt;/code&gt;. В частности:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Everyone was fascinated with the new features, and most likely the reason why no one had a wit to ask: why don’t we let all the other HTML elements also use this attribute?  &lt;h1 src="/website/info/title"&gt; &lt;/h1&gt;  This code means that the browser must load the content of the heading from the provided URL. Maybe it doesn’t make much sense for such a small element, but what about a div or an article? &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Дальше больше, автор предлагает ввести подстановки в язык разметки, в духе&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;name&amp;quot;&amp;gt;George&amp;lt;/div&amp;gt;
&amp;lt;h1&amp;gt;Welcome, $name&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Дело тут какое. Во-первых src много где есть, например в &lt;a href='https://www.owasp.org/index.php/Cross_Frame_Scripting'&gt;полюбившемся всем&lt;/a&gt; &lt;code&gt;iframe&lt;/code&gt;. И кое-где он &lt;a href='https://www.owasp.org/index.php/Clickjacking'&gt;уже доставляет&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Во-вторых давайте почитаем что говорит один из авторов современного web про проблемы которые он пытался решить.&lt;/p&gt;&lt;p&gt;Что требовалось от HTML и где он не справился:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; HTML is an example of a media type that, for the most part, has good latency  characteristics. Information within early HTML could be rendered as it was received... &lt;/p&gt;&lt;p&gt; However, there are aspects of HTML that were not designed well for latency. Examples include: ...;&lt;br /&gt; embedded images without rendering size hints, requiring that the first few bytes of the image&lt;br /&gt; (the part that contains the layout size) be received before the rest of the surrounding HTML&lt;br /&gt; can be displayed; dynamically sized table columns, requiring that the renderer read&lt;br /&gt; and determine sizes for the entire table before it can start displaying the top; ... &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;В моём понимании рац. предложение из поста - сразу два шага назад. Первый - больше запросов на страницу, второй - еще больше компонентов которые не могут рисоваться до полной загрузки.&lt;/p&gt;&lt;p&gt;Теперь немного оценки &lt;code&gt;src&lt;/code&gt; в контексте &lt;code&gt;iframe&lt;/code&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; ... The introduction of “frames” to the Hypertext Markup Language (HTML) caused  similar confusion. Frames allow a browser window to be partitioned into subwindows,  each with its own navigational state. Link selections within a subwindow are  indistinguishable from normal transitions, but the resulting response representation is  rendered within the subwindow instead of the full browser application workspace. This is  fine provided that no link exits the realm of information that is intended for subwindow  treatment, but when it does occur the user finds themself viewing one application wedged  within the subcontext of another application. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Здесь нельзя указать на очевидную деградацию, own navigational state вроде не предлагается. Но предлагается использовать в src переменные с не совсем понятной областью видимости персистентностью. Ограничения на куда &lt;code&gt;src&lt;/code&gt; ходит типа тоже не нужны?&lt;/p&gt;&lt;p&gt;Ничего не сказано о том как читать/писать/переопределять стили и новые $-переменные в подгруженных из src элементах. Без модели каскадирования - это просто размахивание руками. Проблему с ней ведь и пытаемся решить, не?&lt;/p&gt;</description><pubDate>Wed, 27 Mar 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-03-23-on-interviews/</guid><link>https://cheatex.cc/posts-output/2019-03-23-on-interviews/</link><title>Про интервью</title><description>&lt;p&gt;На нтервью реально интересно узнать о гребце следующее.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Способность быстро въезжать в более менее значительное количество кода. Не 10 строк с кастами лонгов в байты а в десяток-другой тысяч со всем возможным креативом.&lt;/li&gt;&lt;li&gt;Большой рабочий диапазон на шкале говнокодим быстро - делаем на века медленно.&lt;/li&gt;&lt;li&gt;Уменее дебагать. На основе п. 1 и общих идей о том что не так строить путь из простых вопросов о поведении кода. И отвечаяя на них приходить к точке поломки.&lt;/li&gt;&lt;li&gt;Способность самостоятельно убедиться что его произведение работает в правдоподобных обстоятельствах. В идеале еще умение эти обстоятельства выяснить.&lt;/li&gt;&lt;li&gt;Ну и физическую способность грести хотя бы часов 20 в неделю, в перспективных стартапах и поболе. Я естественно про время в потоке, а не время за проходной.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Эти вопросы объединяет то что реалистичные ответы на них можно получить не раньше чем через месяц. Так что имеем на собесах то что имеем, смешное разбирательство с cultural fitом. Да, вращения деревья и отличия интерфейсов от абстрактных классов это культура и ничего общего с техническими навыками не имеют.&lt;/p&gt;</description><pubDate>Sat, 23 Mar 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-02-27-fire-and-motion-2019/</guid><link>https://cheatex.cc/posts-output/2019-02-27-fire-and-motion-2019/</link><title>Fire and motion 2019</title><description>&lt;p&gt; Немного реалий андроид программирования.&lt;/p&gt;&lt;p&gt;Сегодня понадобилось сделать тест работающий непосредственно на устройстве. (Никогда, слышите никогда не вводите зависимости между дествительно важным функционалом и любыми нативными API).&lt;/p&gt;&lt;p&gt;Сделал по гайду. Впилил зависимость &lt;code&gt;androidx.test:runner:1.1.0&lt;/code&gt;, повесил &lt;code&gt;@RunWith&amp;#40;AndroidJUnit4.class&amp;#41;&lt;/code&gt; на тест. Тут мне говорят ахтунг, 1.1.0 устарел, надо на 1.1.1 обновляться. Обновился, иду в код. Там снова ахтунг, &lt;code&gt;androidx.test.runner.AndroidJUnit4&lt;/code&gt; устарел, надо &lt;code&gt;androidx.test.ext.junit.runners.AndroidJUnit4&lt;/code&gt;. Поправил, одна беда - такого класса нет. Иду на SO, там советуют &lt;code&gt;androidx.test.ext:junit:1.1.0&lt;/code&gt;. Ну я то стаинг ап-ту-дейт, сразу на 1.1.1 поправил. Билдим - всё наёбывается, &lt;code&gt;androidx.test.ext:junit:1.1.1&lt;/code&gt; отсутсвует. Вдох, выдох, всё откатываем на 1.1.0. Билдим, билдицо. Запускаем тест - всё наёбывается, 2 экрана ошибок. Ещё глубже вдох, помедленнее выдох чтоб в голову не дало. Возвращаем аннотацию &lt;code&gt;androidx.test.runner.AndroidJUnit4&lt;/code&gt;. Работает!!!&lt;/p&gt;&lt;p&gt;А теперь 2 интересные детали. &lt;i&gt;Deprecation warning&lt;/i&gt; можно сапреснуть только во всём классе сразу. Gradle &lt;i&gt;dependency inspection&lt;/i&gt; нельзя сапреснуть вообще, только выключить полностью.&lt;/p&gt;&lt;p&gt;Интересно, зачем выпускать несовместимое обновление с изменением в 3 числе версии? Зачем рекомендовать миграцию с работающего класса на сломаный? Зачем заставлять делящихся прибылью разработчиков выбирать между кучей нерелевантных ворнингов и риском пропустить критичное изменение?&lt;/p&gt;&lt;p&gt;Классики проясняют &lt;a href='https://www.joelonsoftware.com/2002/01/06/fire-and-motion/'&gt;Fire And Motion&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Wed, 27 Feb 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-02-13-conditional-failures/</guid><link>https://cheatex.cc/posts-output/2019-02-13-conditional-failures/</link><title>Странный гайд по исключениям от гуавы</title><description>&lt;p&gt;Наткнулся тут на &lt;a href='https://github.com/google/guava/wiki/ConditionalFailuresExplained'&gt;гайд по пользованию исключениями в Guava&lt;/a&gt;, и видимо в джавовских проектах гугла.&lt;/p&gt;&lt;p&gt;Первое что бросается в глаза Rationale пропущен. Второе - 6 вариантов ответа для фундаментального вопроса это реально дохера. Если вчитаться тоже есть вопросы.&lt;/p&gt;&lt;p&gt;Мне показалось что основная проблема которая решается применением этой конвенции - поиск виноватых. Краткое изложение в табличке целиком про кто "messed up".&lt;/p&gt;&lt;p&gt;Не понятно зачем сюда втянут exceptional result. Типа контракт штуки такой, ожидаемое поведение. Test assertion его частный случай, ничего требующего выделения отдельного пункта не сказано. Дальше в табличке предлагают &lt;code&gt;AssertionError&lt;/code&gt; для него, видиом чтобы по ошибке не ловить падение теста вместо своего исключения. Но это стоило прояснять явно и в формате примечания к exceptional result.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Precondition&lt;/i&gt; check важный частный случай, всё-таки это ситуация когда у кода нет в принципе возможности сделать задуманое. Можно согласиться.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Assertion&lt;/i&gt; - понятно, поддерживаю.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Verification check&lt;/i&gt; пункт про поиск виноватых и пинг-понг. Никакой разницы почему вмерло нет, нарушено ожидание, действуем по плану assertion. А тут добавлен отдельный пункт и класс с утилитами под него.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Impossible-condition&lt;/i&gt; check вообще не понимаю зачем нужен, всё еще assertion.&lt;/p&gt;&lt;p&gt;В этой системе есть проблема: легко ловить что-то тебе не предназначенное. Если есть контракты с исключениями то в код который их использует может приехать и &lt;i&gt;precondition check&lt;/i&gt; и &lt;i&gt;verification check&lt;/i&gt;. Чтобы работало ко всей конструкции надо еще добавлять правило в духе "не ловим &lt;code&gt;Exception&lt;/code&gt; и &lt;code&gt;RuntimeException&lt;/code&gt; в прикладном коде". И правило какой код уже можно считать системным. А потом еще правило про catch который на самом деле finally. Ну вы поняли.&lt;/p&gt;&lt;p&gt;Вывод: там тоже всё плохо. На Java надо писать без ошибок или не писать вообще.&lt;/p&gt;</description><pubDate>Wed, 13 Feb 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-26-on-vs-code/</guid><link>https://cheatex.cc/posts-output/2018-12-26-on-vs-code/</link><title>Про VS Code</title><description>&lt;p&gt;Я тут еще довольно плотно посидел на VS Code. На удивление дельная вещь. Работает совсем неплохо в плане производительности и глючности. На жёсткие баги пока не налетал, не тормозит на i5 480M!&lt;/p&gt;&lt;p&gt;Из встроеных плюшек мне нравятся: всплывающий просмотр кода, терминал и его удобная интеграция с билдами, несколько вариантов навигации по табам.&lt;/p&gt;&lt;p&gt;Плагинов много на всё что можно придумать. Многие кажется ещё в процессе допила, явно не хватает функциональности.&lt;/p&gt;&lt;p&gt;Среда поддерживает двухсоставные хоткеи, когда жмёшь одну комбинацию и потом вторую. Простые хоткеи в основном разобраны самим редактором, а плагины используют двухсоставные. Сначала казалось дичью. Но потом понял что одна стартовая комбинация для плагина + мнемоника для конкретной функции очень удобно запоминается. В результате через небольшой промежуток времени хоткеи используются ативнее чем в других редакторах. Нет  конфликтов типа нужна мнемоника на eval а Ctrl+e и Alt+e заняты.&lt;/p&gt;&lt;p&gt;Я с ней связался  ради Clojure, по итогам считаю VS code наиболее цивилизованным вариантом. В emacs я не смог. В основном всё работает после установки одного плагина: Calva. Нельзя сказать что прям блестяще работает, но лучше чем франкенштейны которые у меня собирались на базе Sublime. Дешевле Cursive.&lt;/p&gt;</description><pubDate>Wed, 26 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-22-on-scala/</guid><link>https://cheatex.cc/posts-output/2018-12-22-on-scala/</link><title>Проблема со скалой</title><description>&lt;p&gt;Мне кажется очень большая беда языка scala в количестве понабежавших фанатиков хаскеля, упорно портирующих его бибилотеки и техники программирования. В своём порыве они мало на что обращают внимание (включая просьбы &lt;a href='https://twitter.com/odersky/status/382631934729277440'&gt;свалить подальше&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;При этом есть ряд техник которые в скажем так прикладном программировании не менее полезны, и языком очень хорошо поодерживаются. Это стиль больше похожий на ML модули и функторы. Про него есть &lt;a href='http://web.archive.org/web/20140815233646/http://blog.pellucid.com/post/94532532890/scalas-modular-roots-by-dan-james-earlier-this'&gt;отличное введение&lt;/a&gt; так и некоторые более серьёзные работы. Но сообщество как прикладников так и разработчиков бибилотек этот аспект языка в основном игнорирует. Беда понятна - техники всё ещё далеки от С++-style OOP и трудны в освоении. А чувства интеллектуального превосходства дают меньше, чем монад-трансформеры. В основном из отсутсвия стада евангелистов в твиттере.&lt;/p&gt;&lt;p&gt;Ещё пара ссылок для заинтересовавшихся:  &lt;a href='http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf'&gt;Scalable Component Abstractions&lt;/a&gt;  &lt;a href='https://pdfs.semanticscholar.org/84b1/d4f7c6d3e243508d153d7e8a10b3d7d33f2c.pdf'&gt;Objects + Views = Components?&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 22 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-07-makejavagreateagain/</guid><link>https://cheatex.cc/posts-output/2018-12-07-makejavagreateagain/</link><title>Make Java great again</title><description>&lt;h3 id="про&amp;#95;импорты"&gt;Про импорты&lt;/h3&gt;&lt;p&gt;Понял что одной из самых недостающих фич в яве являются алиасы в импортах. Крайне удобно и помогает в борьбе с многословностью. Нужен на всех уровнях, для пакетов, классов и методов. &lt;/p&gt;&lt;p&gt;Вместо&lt;/p&gt;&lt;pre&gt;&lt;code&gt;blah.blah.blah.views
∟EditView
∟ShareView
∟ProfileView
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;И обращений типа &lt;code&gt;myFrameworkRenderer.view&amp;#40;new ProfileView&amp;#40;&amp;#41;&amp;#41;&lt;/code&gt; везде.&lt;/p&gt;&lt;p&gt;Можно будет делать&lt;/p&gt;&lt;pre&gt;&lt;code&gt;blah.blah.blah.views
∟Edit
∟Share
∟Profile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В далёком-далёком коде писать &lt;code&gt;views.Profile.DATE&amp;#95;FORMAT&lt;/code&gt;, а гденить поближе &lt;code&gt;myFrameworkRenderer.view&amp;#40;new Profile&amp;#40;&amp;#41;&amp;#41;&lt;/code&gt;.&lt;/p&gt;&lt;h3 id="про&amp;#95;kwargs"&gt;Про kwargs&lt;/h3&gt;&lt;p&gt;Если еще чуть подумать то вторая довольно простая штука (с точки зрения накатать пост в телеге) которой не хватает - keyword arguments.&lt;/p&gt;&lt;p&gt;В основном со стороны вызова. Как ни крути бывают методы и с 4 и с 12 параметрами. Разбираться где что большая трата времени, тут редкий случай когда побольше слов пойдут на пользу.&lt;/p&gt;&lt;p&gt;Я вкурсе про идеевские хинты. Но они ломают форматирование и их нет в гитхабе. (Тут у меня возникло желание начать серию про перспективы структурных редакторов, но я мужественно держусь.)&lt;/p&gt;&lt;h3 id="про&amp;#95;культуру"&gt;Про культуру&lt;/h3&gt;&lt;p&gt;Реально основная проблема с программированием на яве - культура. Сегодня попал на глаза кусок старого кода. Много слов. Очень много слов. Когда я начинал работать все по привычке использовали отбивку 80 символов, потом 120, сейчас уже 150-180 норма. Только вот на 14'' код уже не прочитать. И это только ширина. И пофиксить то не проблема.&lt;/p&gt;&lt;p&gt;Названия больше 4х слов нахер. Ничего понять они не помогают. Читать новый код тяжело и травматично для самолюбия, deal with it. Придумывайте новые новые названия, используйте аналогии, вырабатывайте идиомы. Кто может без доки рассказать разницу между &lt;code&gt;StaticListableBeanFactory&lt;/code&gt; и &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; может бросить в меня камень. Использовать такие названия в письменно коммуникации боль в устной просто невозможно. Когда 5 классов делят 3-4 слова в префиксе или суффиксе никакой возможности завести для них отдельные места в голове нет, кодовая база сливается в невнятную жижу.&lt;/p&gt;&lt;p&gt;get/set нахер. Абсолютно бесполезная трата места на экране. Выдумана от безысходности С кодерами к которым пришли менеджеры и сказали что теперь надо программировать объектно-ориентировано. Никакой абстракции не даёт, вариантов реализации отличных от return/= просто нет. Пользовать &lt;code&gt;public final&lt;/code&gt; поля, если совсем приперает удалять &lt;code&gt;final&lt;/code&gt;. Я не имею в виду методы которые реально что-то ищут или создают, вроде любимого &lt;code&gt;getBean&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Ну это так, чисто площадку от мусора очистить. Хотя почти никто даже этого не делает.&lt;/p&gt;&lt;h3 id="ссылки"&gt;Ссылки&lt;/h3&gt;&lt;p&gt;&lt;a href='https://www.youtube.com/watch?v=ZsHMHukIlJY'&gt;Seven Ineffective Coding Habits of Many Programmers&lt;/a&gt; У чувака довольно дельные идеи по энтерпрайз стилю. Правда изложение крайне водянистое, эксперты советуют смотреть под сидр.&lt;/p&gt;</description><pubDate>Fri, 07 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-07-21-on-exceptions/</guid><link>https://cheatex.cc/posts-output/2018-07-21-on-exceptions/</link><title>Проблема с исключениями</title><description>&lt;p&gt;С исключениями есть одна большая проблема. В каждой команде которую мне довелось встречать было своё уникальное видение как их "правильно" применять.&lt;/p&gt;&lt;p&gt;Какие? Где кидать? Когда кидать? Где ловить? Все эти вопросы дают комбинаторный взрыв стилей и широкий простор для самовыражения. Каждый вариант ответа имеет свои фатальные недостатки, но их можно и проигнорировать для любимого набора. Носители альтернативного набора ответов обрекают всех окружающих на вечные муки и должны немедленно высылаться прямиком в ад. (Ну или в недельное кодревью хотя бы.)&lt;/p&gt;&lt;p&gt;Набор который мне нравится:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;В понятных ситуациях кидаем checked ловим как только можем с ними что-то сделать.&lt;/li&gt;&lt;li&gt;В непонятных делаем assert, в случае религиозно-операционных трудностей создаем AssertionError.&lt;/li&gt;&lt;li&gt;Сторонний код признающийся в выбросе исключений или замеченный за этим заворачивем.&lt;/li&gt;&lt;li&gt;Error ловим только на уровне точек входа, вроде запуска потоков или обработки сети.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Да, и у него тоже есть фатальные недостатки.&lt;/p&gt;&lt;p&gt;А еще я не разу встречал различных мнений по тому как использовать &lt;a href='https://www.scala-lang.org/api/2.9.3/scala/Either.html'&gt;Either&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Sat, 21 Jul 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-07-07-framework-evo/</guid><link>https://cheatex.cc/posts-output/2018-07-07-framework-evo/</link><title>Эволюция фреймворков</title><description>&lt;p&gt;Вначале была уютная джавочка с API для файлов-сокетов и интерфейсом в ODBC.&lt;/p&gt;&lt;p&gt;Потом решили что так программировать сложно и забахали пакет API для серверных приложений. Появилась куча аббревиатур которые до сих пор позволяют HRам писать вакансии не приходя в сознание.&lt;/p&gt;&lt;p&gt;Потом решили что собирать адаптеры и конвертеры между этими аббревиатурами руками сложно. Расцвела концепция inversion of control, появились контейнеры вроде спринга и guice.&lt;/p&gt;&lt;p&gt;Чтобы запуститься и на машине разраба и в тесте и собственно на сервере эти контейнерам требовалась куча конфигов. Расписывать их было не просто, "Правильно" запустить такую конструкцию получалось не у всякого. Пошли в дело оболочки для контейнеров вроде boot. На горизонте замаячил призрак совсем других контейнеров.&lt;/p&gt;&lt;p&gt;Успеть везде не возможно. И пока выкристаллизовывался верный способ завернуть перегонялку из таблички БД в JSON этих перегонялок для приличного приложения стало требоваться несколько сотен. И каждую надо "Правильно" оформить чтобы потраченные ранее усилия не пропали даром. Светлые умы быстренько подыскали выход: &lt;a href='https://www.jhipster.tech/presentation/#/'&gt;Java Hipster&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Хочется собрать всех этих инноваторов и провести с ними воспитательную беседу примерно такого формата: &lt;a href='https://www.youtube.com/watch?v=7n_1zsCVBxw&amp;t=7'&gt;https://www.youtube.com/watch?v=7n_1zsCVBxw&amp;t=7&lt;/a&gt; (Один из лучших гейм-артов, смотреть на самом большом экране что есть и сделать погромче)&lt;/p&gt;</description><pubDate>Sat, 07 Jul 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2015-02-04-complexity-birth/</guid><link>https://cheatex.cc/posts-output/2015-02-04-complexity-birth/</link><title>Рождение сложности</title><description>&lt;p&gt; Решил немного отвлечься от технического образования и заняться научно-популярной литературой. Был приятно удивлён простотой и доступностью книги вышедшей в оригинале на русском да ещё и написанной человеком работающим в Москве. Работа всё ещё не попадает в разряд лёгкого чтива, требует определённой концентрации и запоминания терминологии, но тем не менее доступна без специальной подготовки и даже приятна для людей со склонностью к разбиранию сложных штук.&lt;/p&gt;&lt;p&gt;Книга посвящена современному состоянию эволюционной биологии, в особенности тому что известно о ранних этапах развития жизни. Попутно делается краткий экскурс в современное состояние генетики и молекулярной биологии, которые изрядно продвинулись со времён написания учебников по которым я учился. Много врезок кратко описывающих результаты отдельных исследований конца 2010х годов и их место среди остального материала. Как и положенно научной книге большинство упомянутых фактов сопровождаются ссылками на соответствующие работы.&lt;/p&gt;&lt;p&gt;Медленно и неспешно, начиная с самых простых организмов автор рассматривает как устроен и мог возникнуть соответствующий тип. Начало, конечно, получается довольно насыщенным гипотетическими формами жизни, но это, по мере приближения во времени к современности а по уровню организации к современным многоклеточным и их сообществам, проходит. Приводится множество фактов палеонтологии и недавних открытий реликтовых видов, про которые неспециалисты вряд ли слышали. Огромный массив информации представляется как логически связанная цепочка фактов.&lt;/p&gt;&lt;p&gt;Неожиданно подробно для книги с такой направленностью разбираются химические механизмы регуляции в живых организмах, современное состояние молекулярной биологии. Все даётся в описательном виде, без технических деталей, что может быть небольши минусом для людей не страдающих страхом перед химией. Где уместно полностью рассматриваются цепочки обратной связи от гена до влияния на внешнюю среду и обратно, приводится несколько "интуитивных" доказательств что даже самые простые обратные связи могут эволюционировать в сторону усложнения и адаптации. Вообще одна из позитивных идей вынесенных мной из книги - математические модели и формальные доказательства становятся всё более важной частью биологии.&lt;/p&gt;&lt;p&gt;В общем книга оставляет в голове достаточно яркую и развёрнутую картину современной биологии и её взгляда на историю жизни. Бонусом читатель знакомится с существенно более детальным описанием микроскопического устройства клетки и её механизмов регуляции чем остаётся от школьного курса биологии. В целом дочитывал книгу в состоянии легкого восторга и немедленно приобрёл ещё одни труд автора, ждите ещё обзоров.&lt;/p&gt;</description><pubDate>Wed, 04 Feb 2015 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-10-12-links-3/</guid><link>https://cheatex.cc/posts-output/2014-10-12-links-3/</link><title>Линкопост #3</title><description>&lt;p&gt;Понял что умных своих мыслей не было уже пару месяцев и не предвидится. Давайте хоть чужими поделюсь чтобы блог не умер.&lt;/p&gt;&lt;p&gt;Для начала про хаскель и теорию:&lt;/p&gt;&lt;p&gt;&lt;a href='http://siek.blogspot.be/2012/07/crash-course-on-notation-in-programming.html'&gt;Crash Course on Notation in Programming Language Theory&lt;/a&gt; - название говорит само за себя. Позволяет не пропускать разделы с формальной семантикой в современных статьях по теории ЯП. В принципе материал достаточно уникальный, я например больше нигде не видел описания этой нотации.&lt;/p&gt;&lt;p&gt;Также наткнулся на две статьи с нормальным описанием подхода к IO в Haskell. &lt;a href='http://blog.jle.im/entry/first-class-statements'&gt;First-Class “Statements”&lt;/a&gt; и &lt;a href='https://web.archive.org/web/20151121193133/http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/'&gt;I/O Is Pure&lt;/a&gt;. Они наглядно показывают как устроен ввод-вывод в ленивых языках. Что такое тип IO и каков смысл основных операций с ним в терминах "read data" и "apply to result" а не выдуманнных эффектов и действий. Как небольшой побочный результат дают возможность понять что монады, функторы и прочие интересности которыми забиты все тьюториалы и ответы на SO никакого отношения к сути IO не имеют.&lt;/p&gt;&lt;p&gt;Нашлось за полгода и много интересного и про развитие языков программирования.&lt;/p&gt;&lt;p&gt;Всплыла демо-сессия посвящённая дебаггеру в Elm, &lt;a href='https://www.youtube.com/watch?v=lK0vph1zR8s'&gt;Bret Victor style reactive debugging&lt;/a&gt;. Сейчас этот проект уже влит в основную ветку разработки и доступен как &lt;a href='http://elm-lang.org/blog/Introducing-Elm-Reactor.elm'&gt;reactor&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Chris Granger написал пару стоящих прочтения статей о том что он дальше собирается делать с IDE. Первая, &lt;a href='http://www.chris-granger.com/2014/03/27/toward-a-better-programming/'&gt;Toward a better programming&lt;/a&gt;, неплохо рассмотрено почему софт пишется медленно и заброшена пара идей что с этим можно сделать. Также было сделано объявление о старте &lt;a href='http://www.chris-granger.com/2014/10/01/beyond-light-table/'&gt;EVE&lt;/a&gt;, по делу там достаточно мало, но всё-таки читать интересно. Фактически признано что Light Table превратился в "ещё один редактор" с парой секси фич. Чтож светлая ему память, у EVE есть все шансы таки сдвинуть идею "среды разработки" с мёртвой точки.&lt;/p&gt;&lt;p&gt;Интересная декларация создания двухуровневого языка программирования. Я так понял чистое прожектёрство, по проекту год не было новостей, но идея выглядит неплохо &lt;a href='http://fendrich.se/blog/2013/09/03/big-programming/'&gt;Big Programming, Small Programming&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Небольшой флешбэк, &lt;a href='http://www.youtube.com/watch?v=yJDv-zdhzMY'&gt;The Mother of All Demos&lt;/a&gt;. Презентация руководителя ARC о результатах работы лаборатории 1968 года. Показывается ряд интерактивных систем и озвучиваются идеи их развития. Пользуясь случаем хочу передать пламенный привет всем свидетелям Джобса придумавшего ПК.&lt;/p&gt;&lt;p&gt;Отдельно стоит найденная мной серия лекция Хэмминга (того самого) &lt;a href='http://www.youtube.com/playlist?list=PL2FF649D0C4407B30'&gt;Learning to Learn&lt;/a&gt;. Название говорит само за себя, Хэмминг рассказывает о том как он учился сам и советует как учиться студентам. Особого внимания достойна завершающая лекция &lt;a href='http://www.youtube.com/watch?v=a1zDuOPkMSw'&gt;You and Your Research&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Ну и немного по управлению, статья в духе капитана, но так нереально трудно усваиваемая людьми работающими в менеджменте &lt;a href='http://eao197.blogspot.ru/2014/04/work_14.html'&gt;Банальность: главный ингредиент в разработке ПО &amp;ndash; это люди&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Sun, 12 Oct 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-08-11-bullet-journal/</guid><link>https://cheatex.cc/posts-output/2014-08-11-bullet-journal/</link><title>Опыт с Bullet Journal</title><description>&lt;p&gt;Какое-то время назад я увидел сам и немного порекламировал окружающим аналоговую систему ведения списка дел: &lt;a href='http://bulletjournal.com/'&gt;Bullet Journal&lt;/a&gt;. Суть кратко: автор предлагает типографскую нотацию легко воспроизводимую от руки для управления списками дел на бумаге без помощи компьютера.&lt;/p&gt;&lt;p&gt;Сама идея весьма удобна. Во-первых аналоговая запись существенно расширяет диапазон артефактов которые можно хранить, в программировании часто нет слов зато есть небольшая схемка. Во-вторых записи можно обрабатывать и дополнять оффлайн, в вагоне поезда, в палатке за городом, когда лежишь на диване и боишься случайно засветиться в скайпе.&lt;/p&gt;&lt;p&gt;Однако некоторые детали этой системы меня не устроили и в процессе использования прижился ряд поправок. Последняя версия не подвергалась изменениям уже месяца 3, так что я решил ей поделиться.&lt;/p&gt;&lt;p&gt;Крупнейшее изменение которое я внёс состоит в разделении журнала на две книги. Одну для "текучки" и одну для "вечного". Первую я веду в блокноте чуть меньше А5, туда идут собственно кратковременные задачи и малозначимые заметки по разным топикам. Вторую я веду в обычной школьной тетради. Туда идут долговременные планы, эскизы по разным проектам, важные мысли. Обе книги оформлены как оригинальный журнал: содержат нумерацию страниц и оглавление.&lt;/p&gt;&lt;p&gt;Второе важное отличие: удаление контента. Меня существенно раздражает наличие в поле зрения ненужных вещей, в частности топиков которые уже точно не актуальны. И если оригинальный журнал был append-only, то мои книги подразумевают удаление. В книге с текучкой я просто вычёркиваю элементы оглавления и вырываю соответствующие страницы когда топик становится полностью закрыт или не актуален. Из книги с вечным я только вычёркиваю названия топиков как в оглавлении так и на странице.&lt;/p&gt;&lt;p&gt;Небольшим изменением подвергся набор иконок. Значок "звезда" долго рисовать и редко получается если пишешь на коленях. Иконка priority была заменена на восклицательный знак, соответственно для inspiration я использю простую молнию. Теперь все значки рисуются в пару касаний и узнаваемы даже когда добавлены в вагоне метро.&lt;/p&gt;&lt;p&gt;Я полностью не отказался от цифрового хранения тудушек. Для трекинга живого и эволюционирующего проекта оно подходит лучше. Ну и хранить ссылки на бумаге немного не удобно. Для таких задач я использую Trello. Топики иногда перемещаются между журналом и облаком. Для сохранения разума были выработаны два правила. Первое: никакой топик не живёт одновременно в двух системах. Второе: никогда не осуществлять перенос сразу, я всегда ставлю специальную пометку в названии и осуществляю перенос только когда на неё натыкаюсь.&lt;/p&gt;&lt;p&gt;Система в общем оказалась весьма полезной и после небольшого тюнинга достаточно удобной. Иногда приходится выделять полчаса на обзор текущего состояния журнала и чистку перенос части содержимого, но случается это примерно раз в два месяца. При том что я регулярно оказываюсь поездах, автобусах и т.п. без особого желания читать но с желанием о чём-то подумать бумажный журнал оказывается весьма кстати. Основная проблема не забыть книги дома, но надёжного способа борьбы с ней пока не придумано.&lt;/p&gt;</description><pubDate>Mon, 11 Aug 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-08-04-cg-books/</guid><link>https://cheatex.cc/posts-output/2014-08-04-cg-books/</link><title>"Mathematics for Computer Graphics" и "Computational Geometry: Algorithms and Applications"</title><description>&lt;p&gt; Последние полгода очень сильно ленился в плане чтения и справился всего с двумя книжками.&lt;/p&gt;&lt;p&gt;Первая &lt;a href='http://www.amazon.com/Mathematics-Computer-Graphics-Undergraduate-Science/dp/1849960224'&gt;Mathematics for Computer Graphics&lt;/a&gt; - краткое ревью математики полезной для программирования графики. Книга в принципе неплоха как напоминание и как компактная коллекция полезных математических инструментов. В качестве книги для начального изучения чего либо она к сожалению не очень хороша по нескольким причинам.&lt;/p&gt;&lt;p&gt;Во-первых книге катастрофически не достаёт иллюстративного материала, что фатально сказывается на скорости начального восприятия. Ко многим выкладкам и доказательствам приходится рисовать картинки самостоятельно, что исключает чтение книги в транспорте или на отдыхе.&lt;/p&gt;&lt;p&gt;Вторая проблема: разная глубина изложения в разных разделах. Какие-то направления представлены подборкой основных формул и их интерпретацией. Где-то есть пара примеров их применения, где-то вдруг приводятся доказательства. При сквозном чтении очень тяжело зацепиться за какой-то ритм и следовать ему.&lt;/p&gt;&lt;p&gt;В общем книга приемлема для полки в качестве справочника и не может использоваться для начального ознакомления с мат. аппаратом.&lt;/p&gt;&lt;p&gt;Вторая, &lt;a href='http://www.amazon.com/Computational-Geometry-Applications-Mark-Berg/dp/3540779736'&gt;Computational Geometry: Algorithms and Applications&lt;/a&gt;. Книга как раз противоположна предыдущей - она очень удачна в качестве учебника. Начинает с простого, продолжает непростым, заканчивает комбинацией ранее изложенного. Очень приятной деталью является отличное покрытие иллюстрациями. Все логические построения и алгоритмы сопровождаются удачными рисунками - мне практически не приходилось брать карандаш и бумагу в руки.&lt;/p&gt;&lt;p&gt;Рассматривается около полутора десятков проблем вычислительной геометрии. Каждая атакуется плавно. Нет хороших решений из коробки, всегда показывается эволюция алгоритма от простых идей и игнорирования предельных случаев до доказуемо корректного решения. Авторы часто приводят не лучший алгоритм предпочитая детально описать более простой и понятный.&lt;/p&gt;&lt;p&gt;Чтение не требует знаний выходящих за первый семестр курса алгоритмов. Используются самые базовые вещи: деревья, кучи, списки. Анализ алгоритмов предполагает только знакомство с нотацией асимптот и умение решать "recurrences".&lt;/p&gt;&lt;p&gt;Все главы сопровождаются небольшим ревью вопроса. Там даётся история изучения проблемы и наиболее сильные современные результаты. Часто есть обзор смежных областей, приложений и т.п. Список ссылок огромный.&lt;/p&gt;&lt;p&gt;Книга даёт приятный уровень нагрузки на мозг, каждая задача требует 10-15 сконцентрированных размышлений сверх времени на прочтение. Можно рекомендовать и как учебник если вдруг пришлось столкнуться с геометрическими проблемами так и для развивающего чтения. В целом книга мне исключительно понравилась.&lt;/p&gt;</description><pubDate>Mon, 04 Aug 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-06-19-whats-wrong-with-haskell/</guid><link>https://cheatex.cc/posts-output/2014-06-19-whats-wrong-with-haskell/</link><title>Что не так с Хаскелем</title><description>&lt;p&gt;Недавно тут &lt;a href='http://eax.me/eaxcast-s02e02/'&gt;вспомнилась&lt;/a&gt; забавная статья &lt;a href='http://habrahabr.ru/post/163283/'&gt;"Почему язык Haskell так непопулярен"&lt;/a&gt; &lt;a href='https://savepearlharbor.com/?p=163283'&gt;alt&lt;/a&gt; от одного из вождей соответствующего сообщества. Понял что со времён её публикации мой ответ на заголовок изменился с абстрактного "нихрена не понял" на список из нескольких достаточно конкретных проблем. Их я и попробую тут расписать.&lt;/p&gt;&lt;p&gt;Во-первых нет учебников и справочников по алгоритмам/структурам данных. Большая часть алгоритмов описана в расчёте на дешёвое присваивание и строгие вычисления. Найти описание и анализ нетривиального алгоритма для хаскельных реалий практически не возможно. У того же Окасаки, как я понимаю, половина книги - разработка аппарата для того чтобы только научиться иметь с этим дело.&lt;/p&gt;&lt;p&gt;К предыдущей плотно примыкает проблема номер два. Ленивые вычисления - это фактически полная передача компилятору баланса между потреблением памяти и процессора. Иногда он сдвигает его в совершенно неожиданное место и программа вдруг начинает требовать феерические объёмы ресурсов. Что с этим делать непонятно, гайды которые мне удавалось находить написаны для разрабов этого самого компилятора. В них в принципе нет введений, даже нет ссылок, предполагается что огромная масса знаний о реализации вычислительной модели уже в голове. Что делать человеку который прочитал LYHGG, написал первый алгоритм и получил время выполнение или потребление памяти в районе лунной орбиты непонятно.&lt;/p&gt;&lt;p&gt;Лирическое отступление. Пару лет назад я проходил на курсере курс по алгоритмам. Начать попробовал на хаскеле. Первым заданием было посчитать inversions, то есть нарушения порядка в массиве. Решение я написал сравнительно быстро, мин 40. Проблемы начались при запуске - программа пожирала всю доступную память. Несколько ритуальных плясок в обходе списка позволили программе вмещаться в пару гигабайт памяти и 20 минут. И да, выдавать &lt;a href='https://twitter.com/puffnfresh'&gt;корректный&lt;/a&gt; ответ для пары тысяч чисел в первой версии, спустя полтора часа...&lt;/p&gt;&lt;p&gt;Обзор тематических ресурсов подходы к решению проблемы найти не позволил. Консультация с коллегой-фаном хаскеля, который кстати тоже получил что-то не вменяемое в первой версии программы, и перестановка чего-то там в паре выражений (перед глазами встал призрак 2003 студии где перестановка инклудов иногда чинила access violation)  позволили сократить время до нескольких минут. Для интереса сделал тоже на питоне за 10 мин, 20 или 30 секунд выполнения и символическое потребление памяти. Искать с помощью Хаскеля минимальный разрез графа из нескольких тысяч узлов я уже не рискнул.&lt;/p&gt;&lt;p&gt;Ну и главное: нет примеров полномасштабных приложений. Какая нибудь обработка исключений от трёх функций с помощью стрелок находится легко. Исходник простого веб-сервера, без расширений языка, без 90% закопанного в библиотеки найти сложно. Хотелось бы увидеть простой аналог рисовалки или текстового редактора. Что угодно что демонстрирует в рамках 3-4 экранов дизайн полноценного приложения которое читает, пишет, показывает что-то пользователю, реагирует на ошибки и нарушения форматов. Таких примеров нет, невозможно оценить какой массив знаний необходим для создания полноценного приложения. Теркат? Трансформеры? Дисер Окасаки? Свободная навигация по исходникам компилятора? Я за три года так и не понял.&lt;/p&gt;&lt;p&gt;Ещё для меня серьёзной проблемой является типографический кретинизм большинства авторов. Он проявляется в нескольких аспектах. Во-первых для функции нормально &lt;a href='http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators'&gt;не иметь человеческого имени&lt;/a&gt;. Пишем &lt;*&gt;, в уме проговариваем "треугольная жопа", как описать код коллеге не понятно. Во-вторых статьи абсолютно всех уровней, от ICFP до очередного тьюториала по монадам в блоге программиста Васи наполнены типографскими аналогами собственно операторов языка, то есть вместо -&gt; везде →. Какая-нибудь тау с нижним и верхним индексом - тоже святое дело. Вообще обучение на примере кода который не запускается - норма для данного сообщества. В том же LYHGG процентов 30 не работало ещё три года назад когда я его читал.&lt;/p&gt;&lt;p&gt;Ну и сообщество. Я там выше давал ссылочку на любителя корректных программ, подпишитесь - понаблюдайте недельку. Подумайте что делать если к такому существу придётся обращаться за поддержкой или оно окажется у вас в команде. Справедливости ради надо заметить что те кто собственно что-то делает, разработчики самого компилятора и популярных билиотек более вменяемы и не лишены кругозора.&lt;/p&gt;&lt;p&gt;Чуть не забыл, данная заметка не претендует на полный охват предмета. Haskell имеет некоторое (конечное) количество положительных черт, но я тут про них умолчал. Жаждущие серебряных пуль могут найти их в интернете во множестве.&lt;/p&gt;&lt;p&gt;UPD: Буду сюда докидывать пруфы&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://www.haskell.org/pipermail/haskell-cafe/2014-June/114724.html'&gt;Need help - my haskell code is over 50 times slower than equivalent perl implementation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://codeflow.wordpress.com/2011/02/20/the-reasons-i-dont-write-all-my-code-in-haskell/'&gt;The reasons I don’t write all my code in Haskell&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2a310v/where_is_haskell_going_in_industry/'&gt;Where is Haskell going in industry?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2aerm7/whats_the_performance_bottleneck_in_this_prime/'&gt;What's the performance bottleneck in this prime sieve function?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2ain3c/beginner_parse_error_on_input/'&gt;Beginner - Parse Error on Input '='&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2al3vx/how_do_you_avoid_the_cabal_hell/'&gt;How do you avoid the Cabal Hell™?&lt;/a&gt; (третий пункт прекрасен, изящный функциональный дизайн типа)&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2ali12/complete_roadmap_from_total_novice_to_haskell/'&gt;Complete roadmap from total novice to Haskell mastery?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.reddit.com/r/haskell/comments/2fxjcg/how_do_you_structure_a_program_to_support_logging/'&gt;How do you structure a program to support logging?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.reddit.com/r/haskell/comments/2n0991/how_lazy_evaluation_works/cm9qx7v'&gt;Why is foldl bad?&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Thu, 19 Jun 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-05-26-untypical-ides/</guid><link>https://cheatex.cc/posts-output/2014-05-26-untypical-ides/</link><title>Нетипичные IDE</title><description>&lt;p&gt; Не так давно я написал довольно обстоятельный пост про проблемы современных IDE. В частности подробно отписался почему они могут нанести существенный ущерб проекту без должной осторожности и почему заметной пользы они не приносят. Что характерно пост получился самым популярным за историю блога и много народу не поленилось даже отстоять любимый инструмент в твиттере.&lt;/p&gt;&lt;p&gt;Пришло время перейти к конструктиву и немного посмотреть как их можно делать среды которые что-то меняют в процессе разработки. Есть изрядное количество инструментов которые пытаются продвинуться за пределы 95го года и существенно изменить способ взаимодействия программиста и разрабатываемой им программы.&lt;/p&gt;&lt;p&gt;Вот например &lt;a href='http://www.squeak.org/'&gt;Squeake&lt;/a&gt;, первый релиз 96 год. (Небось думали я с потолка год в прошлом посте взял? Правильно думали на самом деле, да и большинство обсуждаемых далее фич были в &lt;a href='http://weather-dimensions.com/tedkaehler/us/ted/resume/st80release-lic2.jpg'&gt;Smalltalk-80&lt;/a&gt;). Я наверно повторяю очень известную вещь, но всё таки: основной чертой Smalltalk является существование live image. В нём нет статического кода и времени исполнения, всё что делает программист порождает объекты в одном образе, этот образ несёт в себе и код и живые объекты на одинаковых правах. Образ содержит и ядро языка, и разрабатываемое приложение, и среду разработки одновременно, при поставке пользователю ненужные классы удаляются.&lt;/p&gt;&lt;p&gt;Подход этот конечно спорный, но он имеет несколько явно положительных результатов. Например при разработке графики можно весьма просто с ней управляться. Например имея нарисованную как-то картинку можно немного её покрутить, примерить к другой картинке, продублировать. &lt;a href='http://www.youtube.com/watch?v=oH-Jj_1v8BM#t=78'&gt;Как-то так&lt;/a&gt; или &lt;a href='https://www.hpi.uni-potsdam.de/hirschfeld/trac/SqueakCommunityProjects/raw-attachment/wiki/squeak_screencasts/Image-Halos.m4v'&gt;так&lt;/a&gt; (вторая ссылка покороче, но требует скачивания видяшки). А после соответствующего благоустройства среда позволяет &lt;a href='http://www.youtube.com/watch?v=34cWCnLC5nM'&gt;что-то программировать&lt;/a&gt; даже детям. Ну и вообще она полна простых приятностей, вот например Object inspector.&lt;/p&gt;&lt;p&gt;&lt;img src="/img/Exploring-ObjectExplorerInspector-2.jpg" alt="Object inspector" /&gt;&lt;/p&gt;&lt;p&gt;"Чего же тут такого интересного?" - многие спросят. Вроде и ничего, но вот 2014 год на дворе а все популярные среды разработки по-прежнему считают что цвет нормально показывать как десятизначное число.&lt;/p&gt;&lt;p&gt;Второй интересной наработкой Smalltalk является &lt;a href='http://wiki.squeak.org/squeak/1916'&gt;method finder&lt;/a&gt;. Первая его фича - поиск по ключевым словам более менее освоена современными IDE. А вот вторая, поиск по примеру и сейчас, спустя примерно 30 лет после создания насколько я знаю ни кем не повторена. Если кратко она позволяет ввести пример результата метода при заданных аргументах и получить список методов которые этому примеру удовлетворяют. Например на запрос ' trim my spaces '. 'trim my spaces' он ответит #withBlanksTrimmed.&lt;/p&gt;&lt;p&gt;Ладно, хватит истории, вот пара проектов которые прямо сейчас в разработке. Первый, собравший 300k$ на кикстартере, &lt;a href='http://www.lighttable.com/'&gt;Light table&lt;/a&gt;. Это IDE которая должна решить несколько известных проблем и серьёзно пересмотреть постановку других. На данный момент она нацелена на поддержку Clojure, JavaScript и Python. Среди наиболее интересных фичей:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Абстрагирование от файлов проекта, редактор показывает и даёт редактировать функции динамически компонуя их по мере просмотра и редактирования исходников.&lt;/li&gt;&lt;li&gt;Автоматический показ документации и/или исходников связанных функций.&lt;/li&gt;&lt;li&gt;Интерактивная отладка, как через горячую подмену кода так и через 'watches' которые позволяют записывать и отображать состояние программы в отдельных точках.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Текущие релизы правда пока сконцентрированы на разработке тюнингуемого редактора. Но разрабы &lt;a href='https://groups.google.com/d/topic/light-table-discussion/1Hyeia7TXag/discussion'&gt;полны решимости&lt;/a&gt; довести первоначальную идею до конца, вплоть до запила своего языка с блэкджеком и монадами.&lt;/p&gt;&lt;p&gt;Проект &lt;a href='http://peaker.github.io/lamdu/'&gt;Lamdu&lt;/a&gt; параллельно развивает язык и среду разработки для него. Язык построен на основе Haskell с изменениями направленными на большую явность конструкций и адаптацию для визуального представления структуры программ. В частности он вводит обязательные имена параметров для функций и явно отображает типы в лямбда-выражениях.&lt;/p&gt;&lt;p&gt;Среда построена вокруг структурированного представления и редактирования кода с выделением различных элементов шрифтом и цветом.  Редактор позволяет вводить код только в предназначенные для этого слоты, контролирует после ввода тип, предполагаются умные автодополнения. Ошибки типизации получаются хорошо локализованы (не могу не заметить что оригинальный хаскель тут от C++ ушёл совсем не далеко, точность ошибки компенсируется неопределённостью её местоположения).&lt;/p&gt;&lt;p&gt;Редактор автоматически применяет визуальную свёртку сложных языковых конструкций (вроде лямбд и аннотаций параметров как на картинке). Среди целей проекта предоставление билиотекам возможности настраивать отображение для своих структур данных и функций.&lt;/p&gt;&lt;p&gt;&lt;img src="/img/lamdu.png" alt="Lamdu" /&gt;&lt;/p&gt;&lt;p&gt;Также предполагается поддержка "regression debugging", то есть автоматический контроль хода выполнения теста и поиск изменения которое сломало тест. Примерно можно сказать что IDE будет запоминать все промежуточные результаты вычисления функций и сравнивать их для каждой версии. Хотя в контексте ленивости языка всё явно будет хитрее.&lt;/p&gt;&lt;p&gt;Помимо попыток привнести глобальные улучшения в IDE есть несколько инструментов реализующие какие-то конкретные компоненты гораздо лучше, чем принято в мэйнстриме.&lt;/p&gt;&lt;p&gt;Вот например &lt;a href='http://2013.cppnow.org/session/the-projucer-live-coding-with-c-and-the-llvm-jit-engine/'&gt;Projucer&lt;/a&gt;, инструмент визуальный разработки для &lt;a href='http://www.juce.com/'&gt;Juce&lt;/a&gt;. Ничего сверхъестественного, просто быстрая связь кода и картинки, но всё-таки поживее многочисленных SWING-дизайнеров, а пишется одним человеком.&lt;/p&gt;&lt;p&gt;Ещё один проект, коммерческий, &lt;a href='http://chrononsystems.com/what-is-chronon'&gt;Chronon&lt;/a&gt;. Включает в себя "Time Traveling Debugger". Это забавный инструмент который работает с полной записью исполнения программы. Записи получаются с помощью чёрной магии и второго компонента Chronon'а - "Recording Server". Нам же тут интересен дебаггер.&lt;/p&gt;&lt;p&gt;Его центральной фичей является возможность идти не только вперёд но и назад. Найдя ошибку можно вместо того чтобы расставлять бряки в подозрительных местах и перезапускать программу просто пойти назад и посмотреть "откуда пошло". Есть множество приятностей, вроде подсветки активных путей исполнения, истории состояний для переменных и вызовов методов. Много различных фильтров для поиска нужных значений в истории. Для примера можно посмотреть &lt;a href='http://www.youtube.com/watch?v=X80EdpI9z1Y'&gt;вот это видео&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Последний пример с совсем неожиданного направления, из мира железячных корпораций и кровавого геймдева. PhysX debugger - инструмент для физического движка от nVidia. Он создан для отладки поведения физической модели в сложных сценах. И демонстрирует очень высокий уровень использования различных визуализаций. Если вам интересно визуальное программирование я рекомендую потратить 15 мин и посмотреть обзорный ролик целиком: &lt;a href='https://www.youtube.com/watch?feature=player_embedded&amp;v=aKsY-U4kUBA'&gt;PVD tutorial video&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;В этом инструменте есть множество примеров визуализации разных аспектов динамических сцен и процесса их вычисления, вот &lt;a href='https://www.youtube.com/watch?feature=player_embedded&amp;v=aKsY-U4kUBA#t=434'&gt;интересный кусочек&lt;/a&gt; для ленивых (смотреть минуты три). Есть функции бэктрекинга, когда есть бажный объект, есть момент времени когда с ним что-то не так и надо найти откуда проблема появилась. Предусмотрены инструменты для командной работы, можно аннотировать дебаг-сессию оставляя каменты к объектам в определённые моменты времени. Сессия экспортируется и может быть передана коллеге для дальнейшего разбора проблемы. Действительно развитый инструмент для решения весьма нетривиальных задач.&lt;/p&gt;&lt;p&gt;Напоследок уже в который раз не могу не дать ссылку на сайт Bret Victor'а, которого авторы большинства описанных выше проектов называют в числе основных источников идей: &lt;a href='http://worrydream.com/'&gt;worrydream.com&lt;/a&gt;. Если Вы ещё не изучили все его материалы стоит немедленно начать.&lt;/p&gt;</description><pubDate>Mon, 26 May 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-04-08-racket-env/</guid><link>https://cheatex.cc/posts-output/2014-04-08-racket-env/</link><title>Альтернативная среда для Racket</title><description>&lt;p&gt;Это последний отчёт о моих опытах с Racket и посвящён он сугубо техническому вопросу, а именно среде разработки. По умолчанию новоиспечённому Racket-разработчику предлагается минимальная среда разработки. Она умеет открывать файлы с исходниками, подсвечивать синтаксис, загружать их в простой (ну очень простой) REPL и запускать под отладкой.&lt;/p&gt;&lt;p&gt;В принципе это не так и мало, но хотелось большего. А именно:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Полноценного REPL который бы помнил историю команд и умел подгружать изменения без полного перезапуска.&lt;/li&gt;&lt;li&gt;Быстрой навигации по именам функций и структур.&lt;/li&gt;&lt;li&gt;Богатого функционалом текстового редактора, в частности мультивыделения и быстрого поиска.&lt;/li&gt;&lt;li&gt;Поддержки проектов, по крайней мере коллекций файлов по которым можно искать.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;REPL достаточно быстро нашёлся, &lt;a href='http://docs.racket-lang.org/xrepl/'&gt;xrepl&lt;/a&gt;. Он прекрасно помнит историю, умеет (пере)загружать файлы, заходить в них чтобы тестировать не экспортированные функции и органично встраивается в shell. Инструкция по установке на сайте хорошо работает, для полного счастья только пришлось добавить в bash_aliases следующую строчку: &lt;code&gt;xracket=&amp;quot;racket -il xrepl&amp;quot;&lt;/code&gt;. Она запускает Racket в интерактивном режиме и загружает модуль xrepl. Модуль написан таким образом что сам применяет все необходимые хаки для создания полноценной оболочки.&lt;/p&gt;&lt;p&gt;Однако не сразу всё идеально заработало. Файлы с константами было невозможно перезагружать ,rr - Racket выдавал ошибку переопределения имён. Небольшое исследование вопроса показало что это связано с включенными по умолчанию оптимизациями и легко может быть исправлено одной командой, алиас принял вид &lt;code&gt;xracket=&amp;quot;racket -il xrepl --eval '&amp;#40;compile-enforce-module-constants #f&amp;#41;'&amp;quot;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Остальные 3 функции поставляет Sublime оставалось только подружить его немного с ЛИСПом, благо я не первый кто этим озадачился. Установка пары плагинов налаживает между крепкую дружбу между Racket и Sublime. Для упрощения жизни я использовал &lt;a href='https://sublime.wbond.net/installation#st2'&gt;Package Control&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Первый и самый насущный - конечно отступы :) &lt;a href='https://sublime.wbond.net/packages/lispindent'&gt;lispindent&lt;/a&gt; - отлично справляется с этой задачей и даже не пугается квадратных скобок.&lt;/p&gt;&lt;p&gt;Второй - &lt;a href='https://github.com/follesoe/sublime-racket'&gt;подсветка синтаксиса&lt;/a&gt;. В принципе она уже была, однако некоторые конструкции понимала не корректно. В частности совершенно убивали подсветку литералы #something а также функции и структуры не появлялись в списке символов. За пару дней поправил всё это и даже заслал патч в основную ветку проекта.&lt;/p&gt;&lt;p&gt;Ну и последняя доводка из области эстетства - красивая подсветка скобок и быстрый переход между ними. Делается плагином Bracket Highlighter. Очень удобно показывает границы блока слева, рядом с номерами строк а также позволяет включить "усиленную подсветку" - дополнительно подсветить весь текст принадлежащий выделенному блоку. Плюшки вроде удалить блок или перейти во внешний также присутствуют.&lt;/p&gt;&lt;p&gt;Для того чтобы всё это дружило потребовалось буквально пара настроек.&lt;/p&gt;&lt;p&gt;Во-первых надо включить lispindent для соответствующего языка следующей настройкой в &lt;code&gt;lispindent.sublime-settings&lt;/code&gt; (если используется Package Control то его можно открыть через меню Preferences-&gt;Package settings).&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;languages&amp;quot;: {
    &amp;quot;racket&amp;quot;: {
      &amp;quot;syntax&amp;quot;: &amp;quot;Racket.tmLanguage&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В настройках Bracket Highlighter, которые &lt;code&gt;bh&amp;#95;core.sublime-settings&lt;/code&gt; (также легко открываются через меню Preferences-&gt;Package settings) надо только найти и настроить под себя параметр &lt;code&gt;high&amp;#95;visibility&amp;#95;style&lt;/code&gt;, мне понравился &lt;code&gt;underline&lt;/code&gt;. Также удобно повесить переключение этого режима на хоткей, для этого в &lt;code&gt;Default.sublime-keymap&lt;/code&gt; надо дописать&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;keys&amp;quot;: &amp;#91;&amp;quot;ctrl+\\&amp;quot;&amp;#93;,
  &amp;quot;command&amp;quot;: &amp;quot;bh&amp;#95;toggle&amp;#95;high&amp;#95;visibility&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ну и проверить что файлы &lt;code&gt;.rkt&lt;/code&gt; открываются как Racket по умолчанию.&lt;/p&gt;&lt;p&gt;В принципе это всё. Я первый раз что-то глубоко копал в настройку Sublime и результат мне очень понравился. Всё, вплоть до написания своего плагина, решается достаточно легко и работает вполне безглючно.&lt;/p&gt;</description><pubDate>Tue, 08 Apr 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-03-26-evil-ide/</guid><link>https://cheatex.cc/posts-output/2014-03-26-evil-ide/</link><title>IDE как зло</title><description>&lt;p&gt; Уже очень давно начиная новый проект с запуска IDE и создания проекта в ней я чувствую смутное беспокойство. Лёгкий страх, что я принимаю решение которое не смогу пересмотреть, что проект получает пробную дозу и не сможет жить без новых.&lt;/p&gt;&lt;p&gt;Этот пост скорее дамп мыслей чем законченная идея. Однако мысли эти посещают меня довольно давно и мне кажется неплохой идей их зафиксировать. Мыслей этих примерно 4:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Общая польза от IDE крайне переоценена&lt;/li&gt;&lt;li&gt;Вред от них практически никогда осознанно не рассматривается&lt;/li&gt;&lt;li&gt;Во многих [коммерческих] проектах есть крайне не здоровая зависимость от них&lt;/li&gt;&lt;li&gt;Производящие их компании и сообщества уже много лет ничего реально не улучшали&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Польза переоценена очень сильно. Очень многие буквально считаю что без них нельзя работать. Другие думаю что IDE ускоряет разработку в разы. Основными функциями которые считаются незаменимыми являются поиск, навигация, рефакторинг и, иногда, дебагер. Как мне кажется потребность в этих функциях во многом создана самими IDE.&lt;/p&gt;&lt;p&gt;Давайте посмотрим по внимательнее например на навигацию. Думаете выжила бы джава сама по себе со своей безумной связью путей к исходникам и имён пакетов? Да ещё с необходимостью дублировать эту информацию в начале файла? Отсутствием относительных импортов? Только благодаря массовому использованию IDE этот ужас был хоть как-то жизнеспособен и во многом из за него на джаве трудно писать не имея громоздкой оболочки вокруг редактора, которая генерирует и сама же прячет бессмысленные строки.&lt;/p&gt;&lt;p&gt;Рефакторинг? Да то же самое, весь мой рефакторинг в питоне укладывается в grep и Ctrl+R. Просто нет дублирования информации о модулях и сама питонья культура не приветствует создание пакетов "просто так".&lt;/p&gt;&lt;p&gt;Отладка не менее переоценена. Да иногда полезно остановить программу и посмотреть что там как внутри. Но почти всегда ключ лежит в истории. И важно посмотреть историю создания или изменения какой-то структуры, а не текущий снимок и по вспоминать что ты видел 50 шагов назад. И помогает тут не остановка и прокликивание деревьев из объектов и ссылок а возможность легко оставить запись в логе из любого места программы и продуманное, настраиваемое представление объектов в этом логе.&lt;/p&gt;&lt;p&gt;Реальная польза от IDE - перетаскивание неудачных решений в дизайне языков и библиотек из области "фатальный бред" в область "можно терпеть". Не более. Бывает ли такое решение проблем необходимо? Конечно бывает. Но надо ли им пользоваться по умолчанию?&lt;/p&gt;&lt;p&gt;Печальна также и ситуация с оценкой проблем создаваемых IDE. Их наблюдается немало, но вспоминать про них - табу. Про то как джавовские null'ы несут зло и хаос написаны многие сотни страниц текстов, про то что IDEA последние 6 лет стабильно фризит на более-менее больших проектах почти никто не вспоминает.Или вернёмся опять к рефакторингу. Несмотря на то что идея изменения структуры кода без изменения его семантики в общем то здравая, тут тоже важна мера. Один из негативных эффектов наличия IDE в наборе инструментов - это откровенный спам рефакторингами. Не нравится имя? Две кнопки, вбить новое и готово! Захотелось перепилить структуру пакетов? Берём мышку, драг, дроп, кровь-кишки-мозги по стенам.&lt;/p&gt;&lt;p&gt;Это конечно хорошо точно подбирать имена под семантику если ты один, но если над проектом работает человек 5 надо немного аккуратнее делать такие вещи. К старому имени уже могло привыкнуть какое-то количество людей, отлаживая очередную ошибку они могут захотеть его найти и потерять много времени. Умные инструменты рефакторинга делают крупные изменения кода неоправданно лёгкими, опасно лёгкими.&lt;/p&gt;&lt;p&gt;Самая очевидная проблема - IDE скрывают реальное положение вещей в коде. Бессистемное именование, иерархии классов в 8 уровней, пинг-понг из вызовов перегрузок и super - всё это успешно маскируется навороченным Hierachy view. Проблема в том что инструменты могут что-то сделать с механической частью проблемы - найти все перегрузки, вызовы, ветвления. Но они бессильны с интеллектуальной частью - программисту всё так же надо разбираться в таких путаных структурах.&lt;/p&gt;&lt;p&gt;В коммерческой разработке на Java и C# сейчас наблюдается крайне болезненный культ IDE. Примерно треть половина что я видел не собиралась иначе чем экспортом из конкретной среды, примерно треть могла нормально разрабатываться в одной единственной среде из-за code style или кодогенерации или того что единственное описание зависимости между модулями - проект в проприетарном формате созданный 5 лет назад.&lt;/p&gt;&lt;p&gt;Самое печальное что при выборе между нормальным инструментом не поддерживаемым средой и костыльной конструкции с типа интеграцией - приоритет при остаётся за последней. Мой любимый пример - Git. Основная особенность этой VCS в том что она не устанавливает никаких связей между ветками и репозиториями. Ветки вашего личного репозитория могут быть связаны с произвольными ветками одного или нескольких удалённых. Эти связи должны определяться гайдлайнами в конкретном проекте, автоматизироваться созданием соответствующих скриптов и алиасов и, в особых случаях, контролироваться хуками. Git - принципиально требует настройки и расширения, без этих шагов он не очень удобен и прямо скажем создаёт проблемы.&lt;/p&gt;&lt;p&gt;Проблема в том что разработчики Git плагинов для IDEшек с которыми я работал либо просто не в курсе этой особенности, либо менеджеры соответствующей квалификации пояснили им что разноцветный дифф важнее для хомяков чем какая-то там расширяемость. Как следствие нельзя настраивать и даже использовать уже настроенные алиасы и нельзя удобно призывать на выполнение внешние скрипты. Зато есть кнопки Update и Commit&amp;Push... Ну можете представить как выглядит история когда проект резко переезжает с SVN, никто не пользуется гуглом а среда представляет такой easy по самое не могу функционал.&lt;/p&gt;&lt;p&gt;Ну и наконец о развитии - для сред разработки оно остановилось где-то в 90. IDEA 12 отличается от от JBuilder 2003 практически только разнообразными окошками навигаторов, а он в свою очередь от Turbo Pasсal 6 в основном наличием индекса символов и файлов. И все вместе они на фоне Squeak, скажем так, не выглядят достижениями трёх пятилеток.&lt;/p&gt;&lt;p&gt;Не хватает реальной интеграции компонентов. Например, как дебагер задействует редактор? Красная полоска в месте останова и попап со значением переменной. И то если программер позаботился о правильном toString, а если нет - пожалуйста прокликивайте дерево объектов. Это в две тысячи четырнадцатом году предел юзабилити и визуализации типа? Я LabView году так в 04-05 поюзабельнее дебагер рисовал.&lt;/p&gt;&lt;p&gt;И кстати о рисовании. В 2014 опять же году, когда всё прогрессивное человечество хреначит колбэки на жаваскрипте встраивает DSL в любой инструмент сложнее cat, для расширения любой IDE мне надо создать модуль(!) плагина, скомпилировать(!) его, положить в нужную папочку а то и прокликать пару форм и перезапустить(!) софтину. Future of programming, чо. Самый доступный способ расширения что предлагается - разлапистая форма настройки брекпоинта с condition и log message (в студии то небось до сих пор и того нет?).&lt;/p&gt;&lt;p&gt;Почему кроме строк в редакторе не подсветить методы и классы в навигаторах и аутлайне файла? Почему бы кроме плоского текстового лога не добавить к дебагеру какой-нибудь таймлайн и дерево вызовов где можно отставлять пометки? Почему бы не составлять небольшую карту задействованных виртуальных вызовов и их реализаций? Наконец почему не позволить программистам расширять и настраивать это всё по мере необходимости, скриптами и небольшими вставками кода?&lt;/p&gt;&lt;p&gt;Потому что так не делали в 1995 году? Я не вижу других причин.&lt;/p&gt;</description><pubDate>Wed, 26 Mar 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-03-17-land-of-lisp/</guid><link>https://cheatex.cc/posts-output/2014-03-17-land-of-lisp/</link><title>Land of Lisp</title><description>&lt;p&gt;Дочитал сабж. Как можно догадаться книга посвящена языку LISP и выстроена очень своеобразным образом. Основная идея: обучить языку через написание игр. Этот, на первый взгляд направленный на детей, подход в моём случае имел изрядный успех.&lt;/p&gt;&lt;p&gt;Писать игры по ходу книги отличная идея по нескольким причинам. Во-первых это заставляет автора начинать с практически важных, базовых элементов языка. С того с чем в будущем придётся сталкиваться чаще всего, а не с того что педагогически "правильнее". Во-вторых иллюстрации получаются заметно увлекательнее. Ну и наконец игры по своей природе открыты для хакинга, придумать дополнение к числам Фибоначчи гораздо сложнее чем к игре "угадай число".&lt;/p&gt;&lt;p&gt;Скажу честно не все примеры я аккуратно реализовывал и запускал, но примерно 60% задач из книги я выполнил. Что-то расширил, где-то поменял структуру кода - подход с созданием игр в книге даёт читателю очень высокий уровень вовлечённости и это прекрасно.&lt;/p&gt;&lt;p&gt;По содержанию... Книжка раскрывает все основные вопросы программирования: встроенные и пользовательские типы данных, основные конструкции языка, способы их расширения, ввод-вывод. Последовательность практических примеров как мне кажется совершенно логична, хотя порядок в котором вводятся языковые средства немного не отточен.&lt;/p&gt;&lt;p&gt;Код примеров на мой вкус немного грязноват. Много где можно радикально улучшить читабельность простыми изменениями вроде добавления структур вместо списков и магических ca*r'ов, заменой анонимных функций на именованные. Стиль который она оставляет после себя как мне кажется нельзя назвать изящным, но это мнение нуба явно тяготеющего к диалектам Scheme-семейства а не Common для которого написана книга.&lt;/p&gt;&lt;p&gt;И да, просто копировать примеры в таком виде было не очень интересно и решение нашлось само собой - я недавно начал ковырять Racket а книжка то написана под Common LISP! Вот и совместил приятное с полезным, &lt;a href='https://github.com/CheatEx/land-of-lisp-rkt'&gt;транслировал примеры&lt;/a&gt; на современный Racket. И я теперь практически лисп-переводчик с опытом работы :) Кстати благодаря этой книжке я сделал и небольшой (и кажется первый сколько-нибудь полезный) вклад в опенсурс: изрядно &lt;a href='https://github.com/follesoe/sublime-racket/pull/3'&gt;подвыправил&lt;/a&gt; Racket плагин для Sublime.&lt;/p&gt;&lt;p&gt;В общем несмотря на то что книжка вроде не блестящая при должном настрое и желании что-то поделать руками она приночит массу удовольствия. Рекомендую!&lt;/p&gt;</description><pubDate>Mon, 17 Mar 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-01-30-links-2/</guid><link>https://cheatex.cc/posts-output/2014-01-30-links-2/</link><title>Линкопост #2</title><description>&lt;p&gt; Пачка ссылок за последние... 4 месяца. Для начала связанное с Racket.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.infoq.com/presentations/Racket'&gt;The Racket Way&lt;/a&gt; - доклад на strange loop, рассказ о дизайне или даже скорее философии Racket. Несколько наглядных примеров потребности в мета-языках. Достаточно подробно показана возможность плавной эволюции по пути приложение, библиотека, internal DSL, подмножество языка и новый язык со специальным синтаксисом в конце. Полезно посмотреть и как введение в Racket и чтобы понять что можно делать с мета-языками. Мне такая схема показалось существенно более жизнеспособной чем применение MPS или создание external DSL с 0.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.greghendershott.com/fear-of-macros/'&gt;Fear of Macros&lt;/a&gt; - что-то вроде мини-книги или большого цикла статей о макросах в Racket. Вопрос раскрывается гораздо удачнее чем в основной документации. Автор начинает с простого но низкоуровнего примера и оттуда движется к высокоуровневым pattern-based macros. Оставляет целостное понимание что такое syntax object, expansion и т.д. Интересно будет тем что интересуется мета-программированием или изучает схему.&lt;/p&gt;&lt;p&gt;&lt;a href='https://github.com/greghendershott/frog'&gt;Frog&lt;/a&gt; - аналог Octopress на Racket, вроде попроще в инсталляции. Выглядит симпатично, использует модный Bootstrap. В качестве языка разметки в том числе можно использовать &lt;a href='http://docs.racket-lang.org/scribble/index.html'&gt;Scribble&lt;/a&gt; или Markdown. Код более менее читаемый, в общем неплохой проект для поиграться с языком и посмотреть как на нём пишут реальный софт.&lt;/p&gt;&lt;p&gt;Немного холиваров и вбросов.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=TS1lpKBMkgg'&gt;We're Doing It All Wrong&lt;/a&gt; - доклад от бывшего участника разработки компилятора Scala. Подробно, хотя и крайне эмоционально рассматривает различные проблемы в самом языке и текущей реализации компилятора. Немного сумбурно - неявно мешаются в кучу проблемы дизайна языка,  библиотеки, кода компилятора а в конце вообще выдвигается идея некоего идеального языка не совсем очевидно связанная с озвученными проблемами. Но в любом случае стоит уделить внимание если вы планируете куда-то внедрять скалу.&lt;/p&gt;&lt;p&gt;&lt;a href='http://damienkatz.net/2013/01/the_unreasonable_effectiveness_of_c.html'&gt;The Unreasonable Effectiveness of C&lt;/a&gt; - наверно одна из самых интересных статей из прочитанных мной за последнее время. Анализируется почему старый, низкоуровневый язык C был и остаётся популярным и весьма успешным. Строго рекомендовано к прочтению фанбоям хаскелей, скал, джаваскриптов, коков и всего остального что конвертирует силу мысли в быстрые и безбажные программы.&lt;/p&gt;&lt;p&gt;&lt;a href='http://jakobz.livejournal.com/236681.html'&gt;Честно про современные веб-технологии&lt;/a&gt; - запихнул в этот раздел, но вообще считаю все написанное в посте чистейшей правдой. Не могу не добавить что надвигающийся &lt;a href='http://tools.ietf.org/html/draft-ietf-httpbis-http2-09'&gt;HTTP 2.0&lt;/a&gt; обещает сделать реализацию и поддержку веб-сервера уделом пары-тройки корпораций.&lt;/p&gt;&lt;p&gt;Хорошие статьи по практике программирования.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.toptal.com/python/computational-geometry-in-python-from-theory-to-implementation'&gt;Computational Geometry in Python: From Theory to Implementation&lt;/a&gt; - понятный и краткий обзор вычислительной геометрии с точки зрения программиста. Хорошо проиллюстрирован кодом на питоне. Очень приятный способ размять мозги в новой области.&lt;/p&gt;&lt;p&gt;&lt;a href='http://fsharpforfunandprofit.com/posts/recipe-part1/'&gt;How to design and code a complete program&lt;/a&gt; - очень хорошая серия статей о дизайне в функциональном стиле. Построена вокруг одного примера - CRUD приложения для веба. Просто и наглядно излагаются некоторые неочевидные концепции. Код на хаскеле.&lt;/p&gt;&lt;p&gt;Ну и немного философии. &lt;a href='http://www.sfu.ca/~egan/Difficult-article.html'&gt;Why education is so difficult and contentious&lt;/a&gt; - большой обзор происхождения и актуальных проблем современного образования. Интересна тем что внятно формулирует цели образования и показывает что они не очень то совпадают с интересами современного индивида, да и во многом общества.&lt;/p&gt;&lt;p&gt;Последняя ссылка на тему личного управления задачами. &lt;a href='http://www.bulletjournal.com/'&gt;Bullet Journal&lt;/a&gt; - система ведения TODO/календаря в бумажном блокноте. Показалась удобной, сам тестирую.&lt;/p&gt;</description><pubDate>Thu, 30 Jan 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-01-21-drunkards-walk/</guid><link>https://cheatex.cc/posts-output/2014-01-21-drunkards-walk/</link><title>"(Не)совершенная случайность"</title><description>&lt;p&gt;Прочитал эту замечательную &lt;a href='http://www.ozon.ru/context/detail/id/5086716/'&gt;книгу&lt;/a&gt; буквально за 3 дня - наверно самое быстрое прочтение в моей жизни.&lt;/p&gt;&lt;p&gt;Книга посвящена теории вероятности и содержит её рассмотрение сразу с нескольких ракурсов и автор не старается как-то их разделять по ходу изложения. Теория рассказывается от простого к сложному с привлечением разных ракурсов по мере необходимости. В принципе в кинге уверенно распознаются три аспекта.&lt;/p&gt;&lt;p&gt;Во-первых рассказываются, именно рассказываются, сами тервер и матстат. Простым человеческим языком, без сигма-алгебры, условной вероятности и вообще без единой формулы. Очень понятно и просто, книга как ни одна сильна в том чтобы построить контекст вокруг объектов из мира статистики, добавить к заученным в универе терминам очень много семантики. По последовательности изложения она фактически совпадает с классическим курсом тервера и примерно первой третью курса статистики.&lt;/p&gt;&lt;p&gt;Второй предмет рассмотрения книги - история развития тервера. Изложения всех законов органично переплетено с рассказом истории их формирования. Много внимания уделено биографии учёных, их отношениям с другими науками. Для меня как для любителя истории науки этот аспект книги был наиболее интересен.&lt;/p&gt;&lt;p&gt;Третий, и кажется центральный для автора, аспект книги - психологический. При изложении очередной концепции рассказывается как люди склонны ошибаться при его применении к жизненным ситуациям. Всегда приводится несколько примеров наивного применения тервера к жизни. В каждом случае подробно рассматривается корректный способ анализа той или иной проблемы и какие ловушки психологии приводят массы (а иногда и уважаемых учёных) к заблуждениям. В частности подробно рассмотрена знаменитая задача Монти Холла, и кажется доступно даже для меня доказано решение.&lt;/p&gt;&lt;p&gt;Также хочется отметить перевод - действительно хороший и грамотный. Я не заметил ни одной шероховатости в терминологии и описании сложных ошибок использования тервера. Единственный момент который вызвал моё непонимание это название книги. На английском она называется "Drunkard's Walk" то есть "Походка пьяного" как я понимаю.&lt;/p&gt;&lt;p&gt;Книга однозначно рекомендуется и любителям истории, тем кто не теряет надежду понять тервер и даже увлекающимся психологией. Книга будет полезна абсолютно всем вовлечённым в процессы принятия решений, особенно тем кто управляет сложными тех. процессами вроде разработки ПО.&lt;/p&gt;</description><pubDate>Tue, 21 Jan 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-01-09-clojure-vs-racket/</guid><link>https://cheatex.cc/posts-output/2014-01-09-clojure-vs-racket/</link><title>Clojure vs. Racket - мои наблюдения</title><description>&lt;p&gt;Недавно потянуло меня подосвежить в памяти ЛИСП, в качестве учебного пособия и источника игрушечных проектов я без колебаний выбрал LoL. А вот над тем какой диалект выбрать призадумался на пару дней. Вообще сама ситуация довольно примечательна, ЛИСП насколько я понимаю сейчас является единственным языком с несколькими совершенно живыми и здравствующими диалектами. Встраиваемые я сразу отбросил, но и вполне себе самостоятельных осталось порядочно.&lt;/p&gt;&lt;p&gt;В финал вышли два - &lt;a href='http://clojure.org/'&gt;Clojure&lt;/a&gt; и &lt;a href='http://racket-lang.org/'&gt;Racket&lt;/a&gt;. Common Lisp я отбросил так как в нём многовато на мой вкус специальных форм, макросов и прочих интересных вещей, мне он показался достаточно непоследовательным. Для двух финалистов есть &lt;a href='http://programming-puzzler.blogspot.com/2010/08/racket-vs-clojure.html'&gt;известное и по сути очень хорошее сравнение&lt;/a&gt;. Его вывод достаточно однозначен - на практике программировать на Clojure гораздо удобнее, а для учебных целей у диалектов паритет. Однако пост от 2010 года и часть данных там устарели. Ниже я перечислю все устаревшие моменты в том посте ну и приведу пару фактов которые склонили мой выбор в пользу ракеты.&lt;/p&gt;&lt;p&gt;Первый довод автора - отсутствие общих интерфейсов у разных структур данных, в частности списка и вектора. На сколько я могу судить эта проблема решена. Во-первых введено понятие &lt;a href='http://docs.racket-lang.org/reference/sequences.html'&gt;последовательности&lt;/a&gt; и определён ряд удобных &lt;a href='http://docs.racket-lang.org/guide/for.html'&gt;форм и функкций&lt;/a&gt; для работы с ними. Кроме того добавлена наконец поддержка &lt;a href='http://docs.racket-lang.org/reference/struct-generics.html'&gt;абстрактных типов данных&lt;/a&gt;. Кажется полностью аналогична &lt;a href='http://clojure.org/protocols'&gt;протоколам&lt;/a&gt; из Clojure.&lt;/p&gt;&lt;p&gt;Вторая проблема: не консистентная работа со словарями. Она исправлена во-первых ведением &lt;a href='http://docs.racket-lang.org/reference/dicts.html'&gt;протокола для словарей&lt;/a&gt;, поддерживаемого из коробки хеш-таблицами и списками пар. Во-вторых богатым семейством функций &lt;a href='http://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._in-dict%29%29'&gt;in-dict*&lt;/a&gt; по преобразованию словарей в последовательности.&lt;/p&gt;&lt;p&gt;Последнее что не понравилось автору - отсутствие ленивых списков или потоков. Она тоже исправлена на настоящий момент - есть неплохая на мой взгляд &lt;a href='http://docs.racket-lang.org/reference/streams.html'&gt;библиотека потоков&lt;/a&gt;, хорошо прилегающая в нужных местах к последовательностям и словарям.&lt;/p&gt;&lt;p&gt;В принципе я согласен с тем что сейчас Clojure ближе к промышленности. Но связано это в основном с количество активных фанатов которые активно её рекламируют и, надеюсь, репортят баги.&lt;/p&gt;&lt;p&gt;Почему я в итоге выбрал Racket? Буквально две причины. Во-первых в Clojure слишком много на мой вкус синтаксических конструкций. Да да, ЛИСП с избытком конструкций, куда мир катится? Куча каких-то скобочек, шапочек, двоеточий и стрелочек... Всякие навороты вроде ключевых слов очень активно используются стандартной библиотекой. Вторая - JVM. Сейчас я уж слишком привязан к ней, надо как-то расширять кругозор.&lt;/p&gt;</description><pubDate>Thu, 09 Jan 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2010-02-25-what-to-ask/</guid><link>https://cheatex.cc/posts-output/2010-02-25-what-to-ask/</link><title>Что интересно спросить у работодателя</title><description>&lt;h3 id="анализ,&amp;#95;общение&amp;#95;с&amp;#95;пользователями"&gt;Анализ, общение с пользователями&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Откуда берутся требования?&lt;ul&gt;&lt;li&gt;Как оценивается их выполнение?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Требования пересматриваются?&lt;ul&gt;&lt;li&gt;По каким причинам?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Как часто пользователь получает результаты работы?&lt;/li&gt;&lt;li&gt;Участвуют ли пользователи и эксперты в разработке?&lt;ul&gt;&lt;li&gt;В каких формах?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Что предпринимается в случае выявления противоречивости требований?&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="процесс,&amp;#95;планирование"&gt;Процесс, планирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Как формируются задачи на основе требований?&lt;/li&gt;&lt;li&gt;Как оцениваются сроки их выполнения?&lt;/li&gt;&lt;li&gt;Что предпринимается в случае невозможности выполнения требований по&lt;ul&gt;&lt;li&gt;техническим причинам?&lt;/li&gt;&lt;li&gt;организационным причинам?&lt;/li&gt;&lt;li&gt;экономическим причинам?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="программирование"&gt;Программирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Какая VCS используется? Почему?&lt;/li&gt;&lt;li&gt;Есть-ли стандарт кодирования?&lt;ul&gt;&lt;li&gt;Какие аспекты кода он регламентирует?&lt;/li&gt;&lt;li&gt;Как контроллируется его соблюдение?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Сколько человек видят/рецензируют код до его попадания в production?&lt;ul&gt;&lt;li&gt;Как это обеспечивается?&lt;/li&gt;&lt;li&gt;Обязательно-ли исправление по итогам сбора отзывов?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Как происходит сборка продукта?&lt;/li&gt;&lt;li&gt;Есть-ли система автоматической сборки?&lt;ul&gt;&lt;li&gt;Какие действия она предпринимает в случае успеха/неудачи сборки?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Имеет-ли разработчик в своём распоряжении полный стенд разрабатываемого продукта или какие-то его части?&lt;ul&gt;&lt;li&gt;Этот стенд изолирован от других разработчиков?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="контроль&amp;#95;качества,&amp;#95;тестирование"&gt;Контроль качества, тестирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;На какие уровнях производится тестирование?&lt;ul&gt;&lt;li&gt;Как каждый из них автоматизирован?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Есть-ли люди ответственные за контроль качества?&lt;ul&gt;&lt;li&gt;Сколько их от общего числа разработчиков?&lt;/li&gt;&lt;li&gt;Какие задачи они решают?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Thu, 25 Feb 2010 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2008-10-22-jboss-per-app-logs/</guid><link>https://cheatex.cc/posts-output/2008-10-22-jboss-per-app-logs/</link><title>Раздельные логи приложений в JBoss</title><description>&lt;p&gt;Встала задача организовать раздельную запись логов для нескольких экземпляров одного и того-же приложения, запущенных на сервере(разделение экземпяров просто переименование war-ок). При этом дополнительно хотелось получить также: конфигурирование логов отдельно от самого сервера(читай не в серверном &lt;code&gt;jboss-log4j.xml&lt;/code&gt;, а в собственном конфиге приложения, один экземпляр log4j как на диске, так и в памяти.&lt;/p&gt;&lt;p&gt;Простая упаковка конфига вместе с приложением успеха, как и ожидалось, не принесла. Если верить форумам/мэйллистам причина в том, что по умолчанию JBoss подкладывает приложениям свои библиотеки в класспат, соответственно приложения используют уже инициализированный экземпляр log4j.&lt;/p&gt;&lt;p&gt;Вторым этапом стала попытка использовать хак со слушателем контекста и установкой в нём &lt;code&gt;RepositorySelector&lt;/code&gt; взятый &lt;a href='http://docs.jboss.org/process-guide/en/html/logging.html'&gt;тут&lt;/a&gt;, раздел 10.3.8(что примечательно попал он мне на глаза сначала в каком-то блоге, а не в оф. доке). Работал он плохо: при переразвёртываниии приложения падала ошибка при инициализации JBoss log4j plugin. Думаю из за того, что при этом старый ClassLoader убивается и все созданные им классы вместе с ним. Заниматься дебагом сервера было немного лень, а сообщение обошибке было, мягко говоря, кратким.&lt;/p&gt;&lt;p&gt;В третий заход применил подход описанный &lt;a href='http://docs.jboss.org/process-guide/en/html/logging.html'&gt;там-же&lt;/a&gt; в разделе 10.3.6. А именно: положил в папку &lt;code&gt;WEB-INF/lib&lt;/code&gt; log4j и commons-logging(в своём приложении на всякий случай решил использовать его, а не напряму log4j), положил в папку &lt;code&gt;WEB-INF/classes&lt;/code&gt; свой &lt;code&gt;log4j.xml&lt;/code&gt; а также создал файлик &lt;code&gt;jboss-web.xml&lt;/code&gt;(до этого обходился стандартным дескриптором) с содержимым, описанным в доке чуть ниже.&lt;/p&gt;&lt;p&gt;Потом ещё переучил оставшийся с прошлой попытки листенер записывать в системные свойства имена приложения(точнее контекста) и конфига(&lt;code&gt;log4j.xml&lt;/code&gt;). (В спринге есть специальный, более одарённый листенер для этих целей, но спринга пока в проекте нет и связываться было лень.)&lt;/p&gt;&lt;p&gt;Commons-logging увидел старшого брата без дополнительных манипуляций.&lt;/p&gt;&lt;p&gt;Результат: аккуратненький набор папочек в &lt;code&gt;/log&lt;/code&gt; сервера с подневными логами соответствующих приложений. Надо отметить, что это, между тем, не совсем нирвана ибо экземпляр log4j на каждое приложение - и память не по делу и место на диске... в эпоху гигабайтных планок не сильно проблемно, но всё-таки. Есть мнение, что если поглубже покопать в серверный класслоадинг (точнее хоть чуть-чуть копнуть, ибо то, что вписал в конфигурашку я понял приближённо) можно её и достичь...&lt;/p&gt;</description><pubDate>Wed, 22 Oct 2008 00:00:00 +0400</pubDate></item></channel></rss>