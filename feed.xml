<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://cheatex.cc/" rel="self" type="application/rss+xml"/><title>cheatex</title><link>https://cheatex.cc/</link><description>Yet another personal site</description><lastBuildDate>Sun, 08 Sep 2019 15:13:48 +0300</lastBuildDate><generator>clj-rss</generator><item><guid>https://cheatex.cc/posts-output/2019-08-23-understanding-computation/</guid><link>https://cheatex.cc/posts-output/2019-08-23-understanding-computation/</link><title>Understanding computation</title><description>&lt;p&gt;Я в полном восторге от книги. По содержанию - это введение в теорию вычислений. По форме - пошаговые инструкции на руби по реализации разных интерпретаторов и виртуальных машин. Она состоит из трёх больших разделов.&lt;/p&gt;&lt;p&gt;Первый про языки и интерпретаторы. Пробуем по разному задать семантику языка, собрать синтаксическое дерево и написать простой интерпретатор. Возня с парсерами естественно решена одной рубёвой библиотекой.&lt;/p&gt;&lt;p&gt;Второй про модели вычислений. Всё классически: детерминированые-недетерминированные машины с состояниями, машины с состояниями и памятью, разбор языков с их помощью. Только собственно берём и программируем их. Машина Тьринга, лямбда-исчисление. Чувак реально пишет fizz-buzz на одних лямбдах! Не то чтобы я не верил другим книжкам, но вот прям взял и убедился что оно реально рaботает. Под конец рассказывает о SKI и еще нескольких экзотических моделях.&lt;/p&gt;&lt;p&gt;Третья часть больше про теорию. Кратко и уже только с эскизами кода рассматриваем решаемые/нерешаемые машиной Тьюринга задачи. Ковыряем задачу останова. Смотрим на некоторые опции model-checking и пишем простой чекер.&lt;/p&gt;&lt;p&gt;В общем всё самое интересное и хоть как-то соотносящееся с практикой программирования в одном издании. У меня новая #1 рекомендованная книга по CS.&lt;/p&gt;</description><pubDate>Fri, 23 Aug 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-06-03-elements-of-programming/</guid><link>https://cheatex.cc/posts-output/2019-06-03-elements-of-programming/</link><title>Начала программирования</title><description>&lt;p&gt;У меня уже лет 5 в закромах лежала довольно занимательная книга "Начала программирования" Степанова. Что характерно я её купил на книжном развале за старухой за 50 рублей. Где-то полгода назад почувствовал что борода стала достаточно густой чтобы попробовать её открыть.&lt;/p&gt;&lt;p&gt;Книга неплоха, но тяжела для чтения без необходимости.&lt;/p&gt;&lt;p&gt;Основное внимание уделено отношению между математическими концепциями, их выражением в ЯП и непосредственно структурами в памяти. Это довольно интересный топкик, обычно как в литературе таки и во всяких блого-конференциях один из аспектов начисто игнорируется. Содержание построено грамотно и в принципе старается идти от простого к сложному. Автор не пытается объять всё сразу, а плавно строит инструментарий и применяет его в простых но имеющих смысл для бывалого программиста задачах. Математические аспекты напоминаются бегло и немного путанно, видимо пару раз на почитать чтонить по алгебре придётся отвлечься.&lt;/p&gt;&lt;p&gt;Язык крайне тяжёл. Много собственной терминологии. Причём термины многословны и похожи, много времени тратится на листание назад в поисках определения. Можно было радикально упростить восприятие небольшими врезками с напоминанием терминологии.  Также не хватает диаграмм, особенно при обсуждении бифуркатных координат, переупорядочений и вспомогательных "машин". Пришлось много рисовать самому чтобы въехать.&lt;/p&gt;&lt;p&gt;В общем типичный экземпляр позднесоветской литературы. Если есть хорошее представление что хочешь от книги получить и тебе повезло быть с автором примерно на одной волне то можно подчерпнуть много интересных идей. Если нет - идите нахер, у нас тут фундаментальное образование, мы тут не развлекаться собрались, надо привыкать  страдать.&lt;/p&gt;&lt;p&gt;Эксперты рекомендуют для расширения сознания.&lt;/p&gt;</description><pubDate>Mon, 03 Jun 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-03-27-web-improved/</guid><link>https://cheatex.cc/posts-output/2019-03-27-web-improved/</link><title>The HTML we shouldn't ever have</title><description>&lt;p&gt;Мне попался &lt;a href='http://skch.net/view.php?page=articles&amp;post=bhtml'&gt;проект как сделать вэб лучше&lt;/a&gt; и что-то мне кажется проработан он весьма поверхностно...&lt;/p&gt;&lt;p&gt;Для начала автор сетует что аттрибут &lt;code&gt;src&lt;/code&gt; не был внедрён повсеместно, а только для &lt;code&gt;img&lt;/code&gt;. В частности:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Everyone was fascinated with the new features, and most likely the reason why no one had a wit to ask: why don’t we let all the other HTML elements also use this attribute?  &lt;h1 src="/website/info/title"&gt; &lt;/h1&gt;  This code means that the browser must load the content of the heading from the provided URL. Maybe it doesn’t make much sense for such a small element, but what about a div or an article? &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Дальше больше, автор предлагает ввести подстановки в язык разметки, в духе&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;name&amp;quot;&amp;gt;George&amp;lt;/div&amp;gt;
&amp;lt;h1&amp;gt;Welcome, $name&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Дело тут какое. Во-первых src много где есть, например в &lt;a href='https://www.owasp.org/index.php/Cross_Frame_Scripting'&gt;полюбившемся всем&lt;/a&gt; &lt;code&gt;iframe&lt;/code&gt;. И кое-где он &lt;a href='https://www.owasp.org/index.php/Clickjacking'&gt;уже доставляет&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Во-вторых давайте почитаем что говорит один из авторов современного web про проблемы которые он пытался решить.&lt;/p&gt;&lt;p&gt;Что требовалось от HTML и где он не справился:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; HTML is an example of a media type that, for the most part, has good latency  characteristics. Information within early HTML could be rendered as it was received... &lt;/p&gt;&lt;p&gt; However, there are aspects of HTML that were not designed well for latency. Examples include: ...;&lt;br /&gt; embedded images without rendering size hints, requiring that the first few bytes of the image&lt;br /&gt; (the part that contains the layout size) be received before the rest of the surrounding HTML&lt;br /&gt; can be displayed; dynamically sized table columns, requiring that the renderer read&lt;br /&gt; and determine sizes for the entire table before it can start displaying the top; ... &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;В моём понимании рац. предложение из поста - сразу два шага назад. Первый - больше запросов на страницу, второй - еще больше компонентов которые не могут рисоваться до полной загрузки.&lt;/p&gt;&lt;p&gt;Теперь немного оценки &lt;code&gt;src&lt;/code&gt; в контексте &lt;code&gt;iframe&lt;/code&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; ... The introduction of “frames” to the Hypertext Markup Language (HTML) caused  similar confusion. Frames allow a browser window to be partitioned into subwindows,  each with its own navigational state. Link selections within a subwindow are  indistinguishable from normal transitions, but the resulting response representation is  rendered within the subwindow instead of the full browser application workspace. This is  fine provided that no link exits the realm of information that is intended for subwindow  treatment, but when it does occur the user finds themself viewing one application wedged  within the subcontext of another application. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Здесь нельзя указать на очевидную деградацию, own navigational state вроде не предлагается. Но предлагается использовать в src переменные с не совсем понятной областью видимости персистентностью. Ограничения на куда &lt;code&gt;src&lt;/code&gt; ходит типа тоже не нужны?&lt;/p&gt;&lt;p&gt;Ничего не сказано о том как читать/писать/переопределять стили и новые $-переменные в подгруженных из src элементах. Без модели каскадирования - это просто размахивание руками. Проблему с ней ведь и пытаемся решить, не?&lt;/p&gt;</description><pubDate>Wed, 27 Mar 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-03-23-on-interviews/</guid><link>https://cheatex.cc/posts-output/2019-03-23-on-interviews/</link><title>Про интервью</title><description>&lt;p&gt;На нтервью реально интересно узнать о гребце следующее.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Способность быстро въезжать в более менее значительное количество кода. Не 10 строк с кастами лонгов в байты а в десяток-другой тысяч со всем возможным креативом.&lt;/li&gt;&lt;li&gt;Большой рабочий диапазон на шкале говнокодим быстро - делаем на века медленно.&lt;/li&gt;&lt;li&gt;Уменее дебагать. На основе п. 1 и общих идей о том что не так строить путь из простых вопросов о поведении кода. И отвечаяя на них приходить к точке поломки.&lt;/li&gt;&lt;li&gt;Способность самостоятельно убедиться что его произведение работает в правдоподобных обстоятельствах. В идеале еще умение эти обстоятельства выяснить.&lt;/li&gt;&lt;li&gt;Ну и физическую способность грести хотя бы часов 20 в неделю, в перспективных стартапах и поболе. Я естественно про время в потоке, а не время за проходной.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Эти вопросы объединяет то что реалистичные ответы на них можно получить не раньше чем через месяц. Так что имеем на собесах то что имеем, смешное разбирательство с cultural fitом. Да, вращения деревья и отличия интерфейсов от абстрактных классов это культура и ничего общего с техническими навыками не имеют.&lt;/p&gt;</description><pubDate>Sat, 23 Mar 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-02-27-fire-and-motion-2019/</guid><link>https://cheatex.cc/posts-output/2019-02-27-fire-and-motion-2019/</link><title>Fire and motion 2019</title><description>&lt;p&gt; Немного реалий андроид программирования.&lt;/p&gt;&lt;p&gt;Сегодня понадобилось сделать тест работающий непосредственно на устройстве. (Никогда, слышите никогда не вводите зависимости между дествительно важным функционалом и любыми нативными API).&lt;/p&gt;&lt;p&gt;Сделал по гайду. Впилил зависимость &lt;code&gt;androidx.test:runner:1.1.0&lt;/code&gt;, повесил &lt;code&gt;@RunWith&amp;#40;AndroidJUnit4.class&amp;#41;&lt;/code&gt; на тест. Тут мне говорят ахтунг, 1.1.0 устарел, надо на 1.1.1 обновляться. Обновился, иду в код. Там снова ахтунг, &lt;code&gt;androidx.test.runner.AndroidJUnit4&lt;/code&gt; устарел, надо &lt;code&gt;androidx.test.ext.junit.runners.AndroidJUnit4&lt;/code&gt;. Поправил, одна беда - такого класса нет. Иду на SO, там советуют &lt;code&gt;androidx.test.ext:junit:1.1.0&lt;/code&gt;. Ну я то стаинг ап-ту-дейт, сразу на 1.1.1 поправил. Билдим - всё наёбывается, &lt;code&gt;androidx.test.ext:junit:1.1.1&lt;/code&gt; отсутсвует. Вдох, выдох, всё откатываем на 1.1.0. Билдим, билдицо. Запускаем тест - всё наёбывается, 2 экрана ошибок. Ещё глубже вдох, помедленнее выдох чтоб в голову не дало. Возвращаем аннотацию &lt;code&gt;androidx.test.runner.AndroidJUnit4&lt;/code&gt;. Работает!!!&lt;/p&gt;&lt;p&gt;А теперь 2 интересные детали. &lt;i&gt;Deprecation warning&lt;/i&gt; можно сапреснуть только во всём классе сразу. Gradle &lt;i&gt;dependency inspection&lt;/i&gt; нельзя сапреснуть вообще, только выключить полностью.&lt;/p&gt;&lt;p&gt;Интересно, зачем выпускать несовместимое обновление с изменением в 3 числе версии? Зачем рекомендовать миграцию с работающего класса на сломаный? Зачем заставлять делящихся прибылью разработчиков выбирать между кучей нерелевантных ворнингов и риском пропустить критичное изменение?&lt;/p&gt;&lt;p&gt;Классики проясняют &lt;a href='https://www.joelonsoftware.com/2002/01/06/fire-and-motion/'&gt;Fire And Motion&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Wed, 27 Feb 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-02-13-conditional-failures/</guid><link>https://cheatex.cc/posts-output/2019-02-13-conditional-failures/</link><title>Странный гайд по исключениям от гуавы</title><description>&lt;p&gt;Наткнулся тут на &lt;a href='https://github.com/google/guava/wiki/ConditionalFailuresExplained'&gt;гайд по пользованию исключениями в Guava&lt;/a&gt;, и видимо в джавовских проектах гугла.&lt;/p&gt;&lt;p&gt;Первое что бросается в глаза Rationale пропущен. Второе - 6 вариантов ответа для фундаментального вопроса это реально дохера. Если вчитаться тоже есть вопросы.&lt;/p&gt;&lt;p&gt;Мне показалось что основная проблема которая решается применением этой конвенции - поиск виноватых. Краткое изложение в табличке целиком про кто "messed up".&lt;/p&gt;&lt;p&gt;Не понятно зачем сюда втянут exceptional result. Типа контракт штуки такой, ожидаемое поведение. Test assertion его частный случай, ничего требующего выделения отдельного пункта не сказано. Дальше в табличке предлагают &lt;code&gt;AssertionError&lt;/code&gt; для него, видиом чтобы по ошибке не ловить падение теста вместо своего исключения. Но это стоило прояснять явно и в формате примечания к exceptional result.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Precondition&lt;/i&gt; check важный частный случай, всё-таки это ситуация когда у кода нет в принципе возможности сделать задуманое. Можно согласиться.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Assertion&lt;/i&gt; - понятно, поддерживаю.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Verification check&lt;/i&gt; пункт про поиск виноватых и пинг-понг. Никакой разницы почему вмерло нет, нарушено ожидание, действуем по плану assertion. А тут добавлен отдельный пункт и класс с утилитами под него.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Impossible-condition&lt;/i&gt; check вообще не понимаю зачем нужен, всё еще assertion.&lt;/p&gt;&lt;p&gt;В этой системе есть проблема: легко ловить что-то тебе не предназначенное. Если есть контракты с исключениями то в код который их использует может приехать и &lt;i&gt;precondition check&lt;/i&gt; и &lt;i&gt;verification check&lt;/i&gt;. Чтобы работало ко всей конструкции надо еще добавлять правило в духе "не ловим &lt;code&gt;Exception&lt;/code&gt; и &lt;code&gt;RuntimeException&lt;/code&gt; в прикладном коде". И правило какой код уже можно считать системным. А потом еще правило про catch который на самом деле finally. Ну вы поняли.&lt;/p&gt;&lt;p&gt;Вывод: там тоже всё плохо. На Java надо писать без ошибок или не писать вообще.&lt;/p&gt;</description><pubDate>Wed, 13 Feb 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-26-on-vs-code/</guid><link>https://cheatex.cc/posts-output/2018-12-26-on-vs-code/</link><title>Про VS Code</title><description>&lt;p&gt;Я тут еще довольно плотно посидел на VS Code. На удивление дельная вещь. Работает совсем неплохо в плане производительности и глючности. На жёсткие баги пока не налетал, не тормозит на i5 480M!&lt;/p&gt;&lt;p&gt;Из встроеных плюшек мне нравятся: всплывающий просмотр кода, терминал и его удобная интеграция с билдами, несколько вариантов навигации по табам.&lt;/p&gt;&lt;p&gt;Плагинов много на всё что можно придумать. Многие кажется ещё в процессе допила, явно не хватает функциональности.&lt;/p&gt;&lt;p&gt;Среда поддерживает двухсоставные хоткеи, когда жмёшь одну комбинацию и потом вторую. Простые хоткеи в основном разобраны самим редактором, а плагины используют двухсоставные. Сначала казалось дичью. Но потом понял что одна стартовая комбинация для плагина + мнемоника для конкретной функции очень удобно запоминается. В результате через небольшой промежуток времени хоткеи используются ативнее чем в других редакторах. Нет  конфликтов типа нужна мнемоника на eval а Ctrl+e и Alt+e заняты.&lt;/p&gt;&lt;p&gt;Я с ней связался  ради Clojure, по итогам считаю VS code наиболее цивилизованным вариантом. В emacs я не смог. В основном всё работает после установки одного плагина: Calva. Нельзя сказать что прям блестяще работает, но лучше чем франкенштейны которые у меня собирались на базе Sublime. Дешевле Cursive.&lt;/p&gt;</description><pubDate>Wed, 26 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-22-on-scala/</guid><link>https://cheatex.cc/posts-output/2018-12-22-on-scala/</link><title>Проблема со скалой</title><description>&lt;p&gt;Мне кажется очень большая беда языка scala в количестве понабежавших фанатиков хаскеля, упорно портирующих его бибилотеки и техники программирования. В своём порыве они мало на что обращают внимание (включая просьбы &lt;a href='https://twitter.com/odersky/status/382631934729277440'&gt;свалить подальше&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;При этом есть ряд техник которые в скажем так прикладном программировании не менее полезны, и языком очень хорошо поодерживаются. Это стиль больше похожий на ML модули и функторы. Про него есть &lt;a href='http://web.archive.org/web/20140815233646/http://blog.pellucid.com/post/94532532890/scalas-modular-roots-by-dan-james-earlier-this'&gt;отличное введение&lt;/a&gt; так и некоторые более серьёзные работы. Но сообщество как прикладников так и разработчиков бибилотек этот аспект языка в основном игнорирует. Беда понятна - техники всё ещё далеки от С++-style OOP и трудны в освоении. А чувства интеллектуального превосходства дают меньше, чем монад-трансформеры. В основном из отсутсвия стада евангелистов в твиттере.&lt;/p&gt;&lt;p&gt;Ещё пара ссылок для заинтересовавшихся:  &lt;a href='http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf'&gt;Scalable Component Abstractions&lt;/a&gt;  &lt;a href='https://pdfs.semanticscholar.org/84b1/d4f7c6d3e243508d153d7e8a10b3d7d33f2c.pdf'&gt;Objects + Views = Components?&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 22 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-07-makejavagreateagain/</guid><link>https://cheatex.cc/posts-output/2018-12-07-makejavagreateagain/</link><title>Make Java great again</title><description>&lt;h3 id="про&amp;#95;импорты"&gt;Про импорты&lt;/h3&gt;&lt;p&gt;Понял что одной из самых недостающих фич в яве являются алиасы в импортах. Крайне удобно и помогает в борьбе с многословностью. Нужен на всех уровнях, для пакетов, классов и методов. &lt;/p&gt;&lt;p&gt;Вместо&lt;/p&gt;&lt;pre&gt;&lt;code&gt;blah.blah.blah.views
∟EditView
∟ShareView
∟ProfileView
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;И обращений типа &lt;code&gt;myFrameworkRenderer.view&amp;#40;new ProfileView&amp;#40;&amp;#41;&amp;#41;&lt;/code&gt; везде.&lt;/p&gt;&lt;p&gt;Можно будет делать&lt;/p&gt;&lt;pre&gt;&lt;code&gt;blah.blah.blah.views
∟Edit
∟Share
∟Profile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В далёком-далёком коде писать &lt;code&gt;views.Profile.DATE&amp;#95;FORMAT&lt;/code&gt;, а гденить поближе &lt;code&gt;myFrameworkRenderer.view&amp;#40;new Profile&amp;#40;&amp;#41;&amp;#41;&lt;/code&gt;.&lt;/p&gt;&lt;h3 id="про&amp;#95;kwargs"&gt;Про kwargs&lt;/h3&gt;&lt;p&gt;Если еще чуть подумать то вторая довольно простая штука (с точки зрения накатать пост в телеге) которой не хватает - keyword arguments.&lt;/p&gt;&lt;p&gt;В основном со стороны вызова. Как ни крути бывают методы и с 4 и с 12 параметрами. Разбираться где что большая трата времени, тут редкий случай когда побольше слов пойдут на пользу.&lt;/p&gt;&lt;p&gt;Я вкурсе про идеевские хинты. Но они ломают форматирование и их нет в гитхабе. (Тут у меня возникло желание начать серию про перспективы структурных редакторов, но я мужественно держусь.)&lt;/p&gt;&lt;h3 id="про&amp;#95;культуру"&gt;Про культуру&lt;/h3&gt;&lt;p&gt;Реально основная проблема с программированием на яве - культура. Сегодня попал на глаза кусок старого кода. Много слов. Очень много слов. Когда я начинал работать все по привычке использовали отбивку 80 символов, потом 120, сейчас уже 150-180 норма. Только вот на 14'' код уже не прочитать. И это только ширина. И пофиксить то не проблема.&lt;/p&gt;&lt;p&gt;Названия больше 4х слов нахер. Ничего понять они не помогают. Читать новый код тяжело и травматично для самолюбия, deal with it. Придумывайте новые новые названия, используйте аналогии, вырабатывайте идиомы. Кто может без доки рассказать разницу между &lt;code&gt;StaticListableBeanFactory&lt;/code&gt; и &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; может бросить в меня камень. Использовать такие названия в письменно коммуникации боль в устной просто невозможно. Когда 5 классов делят 3-4 слова в префиксе или суффиксе никакой возможности завести для них отдельные места в голове нет, кодовая база сливается в невнятную жижу.&lt;/p&gt;&lt;p&gt;get/set нахер. Абсолютно бесполезная трата места на экране. Выдумана от безысходности С кодерами к которым пришли менеджеры и сказали что теперь надо программировать объектно-ориентировано. Никакой абстракции не даёт, вариантов реализации отличных от return/= просто нет. Пользовать &lt;code&gt;public final&lt;/code&gt; поля, если совсем приперает удалять &lt;code&gt;final&lt;/code&gt;. Я не имею в виду методы которые реально что-то ищут или создают, вроде любимого &lt;code&gt;getBean&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Ну это так, чисто площадку от мусора очистить. Хотя почти никто даже этого не делает.&lt;/p&gt;&lt;h3 id="ссылки"&gt;Ссылки&lt;/h3&gt;&lt;p&gt;&lt;a href='https://www.youtube.com/watch?v=ZsHMHukIlJY'&gt;Seven Ineffective Coding Habits of Many Programmers&lt;/a&gt; У чувака довольно дельные идеи по энтерпрайз стилю. Правда изложение крайне водянистое, эксперты советуют смотреть под сидр.&lt;/p&gt;</description><pubDate>Fri, 07 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-07-21-on-exceptions/</guid><link>https://cheatex.cc/posts-output/2018-07-21-on-exceptions/</link><title>Проблема с исключениями</title><description>&lt;p&gt;С исключениями есть одна большая проблема. В каждой команде которую мне довелось встречать было своё уникальное видение как их "правильно" применять.&lt;/p&gt;&lt;p&gt;Какие? Где кидать? Когда кидать? Где ловить? Все эти вопросы дают комбинаторный взрыв стилей и широкий простор для самовыражения. Каждый вариант ответа имеет свои фатальные недостатки, но их можно и проигнорировать для любимого набора. Носители альтернативного набора ответов обрекают всех окружающих на вечные муки и должны немедленно высылаться прямиком в ад. (Ну или в недельное кодревью хотя бы.)&lt;/p&gt;&lt;p&gt;Набор который мне нравится:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;В понятных ситуациях кидаем checked ловим как только можем с ними что-то сделать.&lt;/li&gt;&lt;li&gt;В непонятных делаем assert, в случае религиозно-операционных трудностей создаем AssertionError.&lt;/li&gt;&lt;li&gt;Сторонний код признающийся в выбросе исключений или замеченный за этим заворачивем.&lt;/li&gt;&lt;li&gt;Error ловим только на уровне точек входа, вроде запуска потоков или обработки сети.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Да, и у него тоже есть фатальные недостатки.&lt;/p&gt;&lt;p&gt;А еще я не разу встречал различных мнений по тому как использовать &lt;a href='https://www.scala-lang.org/api/2.9.3/scala/Either.html'&gt;Either&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Sat, 21 Jul 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-07-07-framework-evo/</guid><link>https://cheatex.cc/posts-output/2018-07-07-framework-evo/</link><title>Эволюция фреймворков</title><description>&lt;p&gt;Вначале была уютная джавочка с API для файлов-сокетов и интерфейсом в ODBC.&lt;/p&gt;&lt;p&gt;Потом решили что так программировать сложно и забахали пакет API для серверных приложений. Появилась куча аббревиатур которые до сих пор позволяют HRам писать вакансии не приходя в сознание.&lt;/p&gt;&lt;p&gt;Потом решили что собирать адаптеры и конвертеры между этими аббревиатурами руками сложно. Расцвела концепция inversion of control, появились контейнеры вроде спринга и guice.&lt;/p&gt;&lt;p&gt;Чтобы запуститься и на машине разраба и в тесте и собственно на сервере эти контейнерам требовалась куча конфигов. Расписывать их было не просто, "Правильно" запустить такую конструкцию получалось не у всякого. Пошли в дело оболочки для контейнеров вроде boot. На горизонте замаячил призрак совсем других контейнеров.&lt;/p&gt;&lt;p&gt;Успеть везде не возможно. И пока выкристаллизовывался верный способ завернуть перегонялку из таблички БД в JSON этих перегонялок для приличного приложения стало требоваться несколько сотен. И каждую надо "Правильно" оформить чтобы потраченные ранее усилия не пропали даром. Светлые умы быстренько подыскали выход: &lt;a href='https://www.jhipster.tech/presentation/#/'&gt;Java Hipster&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Хочется собрать всех этих инноваторов и провести с ними воспитательную беседу примерно такого формата: &lt;a href='https://www.youtube.com/watch?v=7n_1zsCVBxw&amp;t=7'&gt;https://www.youtube.com/watch?v=7n_1zsCVBxw&amp;t=7&lt;/a&gt; (Один из лучших гейм-артов, смотреть на самом большом экране что есть и сделать погромче)&lt;/p&gt;</description><pubDate>Sat, 07 Jul 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2015-02-04-complexity-birth/</guid><link>https://cheatex.cc/posts-output/2015-02-04-complexity-birth/</link><title>Рождение сложности</title><description>&lt;p&gt; Решил немного отвлечься от технического образования и заняться научно-популярной литературой. Был приятно удивлён простотой и доступностью книги вышедшей в оригинале на русском да ещё и написанной человеком работающим в Москве. Работа всё ещё не попадает в разряд лёгкого чтива, требует определённой концентрации и запоминания терминологии, но тем не менее доступна без специальной подготовки и даже приятна для людей со склонностью к разбиранию сложных штук.&lt;/p&gt;&lt;p&gt;Книга посвящена современному состоянию эволюционной биологии, в особенности тому что известно о ранних этапах развития жизни. Попутно делается краткий экскурс в современное состояние генетики и молекулярной биологии, которые изрядно продвинулись со времён написания учебников по которым я учился. Много врезок кратко описывающих результаты отдельных исследований конца 2010х годов и их место среди остального материала. Как и положенно научной книге большинство упомянутых фактов сопровождаются ссылками на соответствующие работы.&lt;/p&gt;&lt;p&gt;Медленно и неспешно, начиная с самых простых организмов автор рассматривает как устроен и мог возникнуть соответствующий тип. Начало, конечно, получается довольно насыщенным гипотетическими формами жизни, но это, по мере приближения во времени к современности а по уровню организации к современным многоклеточным и их сообществам, проходит. Приводится множество фактов палеонтологии и недавних открытий реликтовых видов, про которые неспециалисты вряд ли слышали. Огромный массив информации представляется как логически связанная цепочка фактов.&lt;/p&gt;&lt;p&gt;Неожиданно подробно для книги с такой направленностью разбираются химические механизмы регуляции в живых организмах, современное состояние молекулярной биологии. Все даётся в описательном виде, без технических деталей, что может быть небольши минусом для людей не страдающих страхом перед химией. Где уместно полностью рассматриваются цепочки обратной связи от гена до влияния на внешнюю среду и обратно, приводится несколько "интуитивных" доказательств что даже самые простые обратные связи могут эволюционировать в сторону усложнения и адаптации. Вообще одна из позитивных идей вынесенных мной из книги - математические модели и формальные доказательства становятся всё более важной частью биологии.&lt;/p&gt;&lt;p&gt;В общем книга оставляет в голове достаточно яркую и развёрнутую картину современной биологии и её взгляда на историю жизни. Бонусом читатель знакомится с существенно более детальным описанием микроскопического устройства клетки и её механизмов регуляции чем остаётся от школьного курса биологии. В целом дочитывал книгу в состоянии легкого восторга и немедленно приобрёл ещё одни труд автора, ждите ещё обзоров.&lt;/p&gt;</description><pubDate>Wed, 04 Feb 2015 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-10-12-links-3/</guid><link>https://cheatex.cc/posts-output/2014-10-12-links-3/</link><title>Линкопост #3</title><description>&lt;p&gt;Понял что умных своих мыслей не было уже пару месяцев и не предвидится. Давайте хоть чужими поделюсь чтобы блог не умер.&lt;/p&gt;&lt;p&gt;Для начала про хаскель и теорию:&lt;/p&gt;&lt;p&gt;&lt;a href='http://siek.blogspot.be/2012/07/crash-course-on-notation-in-programming.html'&gt;Crash Course on Notation in Programming Language Theory&lt;/a&gt; - название говорит само за себя. Позволяет не пропускать разделы с формальной семантикой в современных статьях по теории ЯП. В принципе материал достаточно уникальный, я например больше нигде не видел описания этой нотации.&lt;/p&gt;&lt;p&gt;Также наткнулся на две статьи с нормальным описанием подхода к IO в Haskell. &lt;a href='http://blog.jle.im/entry/first-class-statements'&gt;First-Class “Statements”&lt;/a&gt; и &lt;a href='https://web.archive.org/web/20151121193133/http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/'&gt;I/O Is Pure&lt;/a&gt;. Они наглядно показывают как устроен ввод-вывод в ленивых языках. Что такое тип IO и каков смысл основных операций с ним в терминах "read data" и "apply to result" а не выдуманнных эффектов и действий. Как небольшой побочный результат дают возможность понять что монады, функторы и прочие интересности которыми забиты все тьюториалы и ответы на SO никакого отношения к сути IO не имеют.&lt;/p&gt;&lt;p&gt;Нашлось за полгода и много интересного и про развитие языков программирования.&lt;/p&gt;&lt;p&gt;Всплыла демо-сессия посвящённая дебаггеру в Elm, &lt;a href='https://www.youtube.com/watch?v=lK0vph1zR8s'&gt;Bret Victor style reactive debugging&lt;/a&gt;. Сейчас этот проект уже влит в основную ветку разработки и доступен как &lt;a href='http://elm-lang.org/blog/Introducing-Elm-Reactor.elm'&gt;reactor&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Chris Granger написал пару стоящих прочтения статей о том что он дальше собирается делать с IDE. Первая, &lt;a href='http://www.chris-granger.com/2014/03/27/toward-a-better-programming/'&gt;Toward a better programming&lt;/a&gt;, неплохо рассмотрено почему софт пишется медленно и заброшена пара идей что с этим можно сделать. Также было сделано объявление о старте &lt;a href='http://www.chris-granger.com/2014/10/01/beyond-light-table/'&gt;EVE&lt;/a&gt;, по делу там достаточно мало, но всё-таки читать интересно. Фактически признано что Light Table превратился в "ещё один редактор" с парой секси фич. Чтож светлая ему память, у EVE есть все шансы таки сдвинуть идею "среды разработки" с мёртвой точки.&lt;/p&gt;&lt;p&gt;Интересная декларация создания двухуровневого языка программирования. Я так понял чистое прожектёрство, по проекту год не было новостей, но идея выглядит неплохо &lt;a href='http://fendrich.se/blog/2013/09/03/big-programming/'&gt;Big Programming, Small Programming&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Небольшой флешбэк, &lt;a href='http://www.youtube.com/watch?v=yJDv-zdhzMY'&gt;The Mother of All Demos&lt;/a&gt;. Презентация руководителя ARC о результатах работы лаборатории 1968 года. Показывается ряд интерактивных систем и озвучиваются идеи их развития. Пользуясь случаем хочу передать пламенный привет всем свидетелям Джобса придумавшего ПК.&lt;/p&gt;&lt;p&gt;Отдельно стоит найденная мной серия лекция Хэмминга (того самого) &lt;a href='http://www.youtube.com/playlist?list=PL2FF649D0C4407B30'&gt;Learning to Learn&lt;/a&gt;. Название говорит само за себя, Хэмминг рассказывает о том как он учился сам и советует как учиться студентам. Особого внимания достойна завершающая лекция &lt;a href='http://www.youtube.com/watch?v=a1zDuOPkMSw'&gt;You and Your Research&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Ну и немного по управлению, статья в духе капитана, но так нереально трудно усваиваемая людьми работающими в менеджменте &lt;a href='http://eao197.blogspot.ru/2014/04/work_14.html'&gt;Банальность: главный ингредиент в разработке ПО &amp;ndash; это люди&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Sun, 12 Oct 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-08-11-bullet-journal/</guid><link>https://cheatex.cc/posts-output/2014-08-11-bullet-journal/</link><title>Опыт с Bullet Journal</title><description>&lt;p&gt;Какое-то время назад я увидел сам и немного порекламировал окружающим аналоговую систему ведения списка дел: &lt;a href='http://bulletjournal.com/'&gt;Bullet Journal&lt;/a&gt;. Суть кратко: автор предлагает типографскую нотацию легко воспроизводимую от руки для управления списками дел на бумаге без помощи компьютера.&lt;/p&gt;&lt;p&gt;Сама идея весьма удобна. Во-первых аналоговая запись существенно расширяет диапазон артефактов которые можно хранить, в программировании часто нет слов зато есть небольшая схемка. Во-вторых записи можно обрабатывать и дополнять оффлайн, в вагоне поезда, в палатке за городом, когда лежишь на диване и боишься случайно засветиться в скайпе.&lt;/p&gt;&lt;p&gt;Однако некоторые детали этой системы меня не устроили и в процессе использования прижился ряд поправок. Последняя версия не подвергалась изменениям уже месяца 3, так что я решил ей поделиться.&lt;/p&gt;&lt;p&gt;Крупнейшее изменение которое я внёс состоит в разделении журнала на две книги. Одну для "текучки" и одну для "вечного". Первую я веду в блокноте чуть меньше А5, туда идут собственно кратковременные задачи и малозначимые заметки по разным топикам. Вторую я веду в обычной школьной тетради. Туда идут долговременные планы, эскизы по разным проектам, важные мысли. Обе книги оформлены как оригинальный журнал: содержат нумерацию страниц и оглавление.&lt;/p&gt;&lt;p&gt;Второе важное отличие: удаление контента. Меня существенно раздражает наличие в поле зрения ненужных вещей, в частности топиков которые уже точно не актуальны. И если оригинальный журнал был append-only, то мои книги подразумевают удаление. В книге с текучкой я просто вычёркиваю элементы оглавления и вырываю соответствующие страницы когда топик становится полностью закрыт или не актуален. Из книги с вечным я только вычёркиваю названия топиков как в оглавлении так и на странице.&lt;/p&gt;&lt;p&gt;Небольшим изменением подвергся набор иконок. Значок "звезда" долго рисовать и редко получается если пишешь на коленях. Иконка priority была заменена на восклицательный знак, соответственно для inspiration я использю простую молнию. Теперь все значки рисуются в пару касаний и узнаваемы даже когда добавлены в вагоне метро.&lt;/p&gt;&lt;p&gt;Я полностью не отказался от цифрового хранения тудушек. Для трекинга живого и эволюционирующего проекта оно подходит лучше. Ну и хранить ссылки на бумаге немного не удобно. Для таких задач я использую Trello. Топики иногда перемещаются между журналом и облаком. Для сохранения разума были выработаны два правила. Первое: никакой топик не живёт одновременно в двух системах. Второе: никогда не осуществлять перенос сразу, я всегда ставлю специальную пометку в названии и осуществляю перенос только когда на неё натыкаюсь.&lt;/p&gt;&lt;p&gt;Система в общем оказалась весьма полезной и после небольшого тюнинга достаточно удобной. Иногда приходится выделять полчаса на обзор текущего состояния журнала и чистку перенос части содержимого, но случается это примерно раз в два месяца. При том что я регулярно оказываюсь поездах, автобусах и т.п. без особого желания читать но с желанием о чём-то подумать бумажный журнал оказывается весьма кстати. Основная проблема не забыть книги дома, но надёжного способа борьбы с ней пока не придумано.&lt;/p&gt;</description><pubDate>Mon, 11 Aug 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-08-04-cg-books/</guid><link>https://cheatex.cc/posts-output/2014-08-04-cg-books/</link><title>"Mathematics for Computer Graphics" и "Computational Geometry: Algorithms and Applications"</title><description>&lt;p&gt; Последние полгода очень сильно ленился в плане чтения и справился всего с двумя книжками.&lt;/p&gt;&lt;p&gt;Первая &lt;a href='http://www.amazon.com/Mathematics-Computer-Graphics-Undergraduate-Science/dp/1849960224'&gt;Mathematics for Computer Graphics&lt;/a&gt; - краткое ревью математики полезной для программирования графики. Книга в принципе неплоха как напоминание и как компактная коллекция полезных математических инструментов. В качестве книги для начального изучения чего либо она к сожалению не очень хороша по нескольким причинам.&lt;/p&gt;&lt;p&gt;Во-первых книге катастрофически не достаёт иллюстративного материала, что фатально сказывается на скорости начального восприятия. Ко многим выкладкам и доказательствам приходится рисовать картинки самостоятельно, что исключает чтение книги в транспорте или на отдыхе.&lt;/p&gt;&lt;p&gt;Вторая проблема: разная глубина изложения в разных разделах. Какие-то направления представлены подборкой основных формул и их интерпретацией. Где-то есть пара примеров их применения, где-то вдруг приводятся доказательства. При сквозном чтении очень тяжело зацепиться за какой-то ритм и следовать ему.&lt;/p&gt;&lt;p&gt;В общем книга приемлема для полки в качестве справочника и не может использоваться для начального ознакомления с мат. аппаратом.&lt;/p&gt;&lt;p&gt;Вторая, &lt;a href='http://www.amazon.com/Computational-Geometry-Applications-Mark-Berg/dp/3540779736'&gt;Computational Geometry: Algorithms and Applications&lt;/a&gt;. Книга как раз противоположна предыдущей - она очень удачна в качестве учебника. Начинает с простого, продолжает непростым, заканчивает комбинацией ранее изложенного. Очень приятной деталью является отличное покрытие иллюстрациями. Все логические построения и алгоритмы сопровождаются удачными рисунками - мне практически не приходилось брать карандаш и бумагу в руки.&lt;/p&gt;&lt;p&gt;Рассматривается около полутора десятков проблем вычислительной геометрии. Каждая атакуется плавно. Нет хороших решений из коробки, всегда показывается эволюция алгоритма от простых идей и игнорирования предельных случаев до доказуемо корректного решения. Авторы часто приводят не лучший алгоритм предпочитая детально описать более простой и понятный.&lt;/p&gt;&lt;p&gt;Чтение не требует знаний выходящих за первый семестр курса алгоритмов. Используются самые базовые вещи: деревья, кучи, списки. Анализ алгоритмов предполагает только знакомство с нотацией асимптот и умение решать "recurrences".&lt;/p&gt;&lt;p&gt;Все главы сопровождаются небольшим ревью вопроса. Там даётся история изучения проблемы и наиболее сильные современные результаты. Часто есть обзор смежных областей, приложений и т.п. Список ссылок огромный.&lt;/p&gt;&lt;p&gt;Книга даёт приятный уровень нагрузки на мозг, каждая задача требует 10-15 сконцентрированных размышлений сверх времени на прочтение. Можно рекомендовать и как учебник если вдруг пришлось столкнуться с геометрическими проблемами так и для развивающего чтения. В целом книга мне исключительно понравилась.&lt;/p&gt;</description><pubDate>Mon, 04 Aug 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-06-19-whats-wrong-with-haskell/</guid><link>https://cheatex.cc/posts-output/2014-06-19-whats-wrong-with-haskell/</link><title>Что не так с Хаскелем</title><description>&lt;p&gt;Недавно тут &lt;a href='http://eax.me/eaxcast-s02e02/'&gt;вспомнилась&lt;/a&gt; забавная статья &lt;a href='http://habrahabr.ru/post/163283/'&gt;"Почему язык Haskell так непопулярен"&lt;/a&gt; &lt;a href='https://savepearlharbor.com/?p=163283'&gt;alt&lt;/a&gt; от одного из вождей соответствующего сообщества. Понял что со времён её публикации мой ответ на заголовок изменился с абстрактного "нихрена не понял" на список из нескольких достаточно конкретных проблем. Их я и попробую тут расписать.&lt;/p&gt;&lt;p&gt;Во-первых нет учебников и справочников по алгоритмам/структурам данных. Большая часть алгоритмов описана в расчёте на дешёвое присваивание и строгие вычисления. Найти описание и анализ нетривиального алгоритма для хаскельных реалий практически не возможно. У того же Окасаки, как я понимаю, половина книги - разработка аппарата для того чтобы только научиться иметь с этим дело.&lt;/p&gt;&lt;p&gt;К предыдущей плотно примыкает проблема номер два. Ленивые вычисления - это фактически полная передача компилятору баланса между потреблением памяти и процессора. Иногда он сдвигает его в совершенно неожиданное место и программа вдруг начинает требовать феерические объёмы ресурсов. Что с этим делать непонятно, гайды которые мне удавалось находить написаны для разрабов этого самого компилятора. В них в принципе нет введений, даже нет ссылок, предполагается что огромная масса знаний о реализации вычислительной модели уже в голове. Что делать человеку который прочитал LYHGG, написал первый алгоритм и получил время выполнение или потребление памяти в районе лунной орбиты непонятно.&lt;/p&gt;&lt;p&gt;Лирическое отступление. Пару лет назад я проходил на курсере курс по алгоритмам. Начать попробовал на хаскеле. Первым заданием было посчитать inversions, то есть нарушения порядка в массиве. Решение я написал сравнительно быстро, мин 40. Проблемы начались при запуске - программа пожирала всю доступную память. Несколько ритуальных плясок в обходе списка позволили программе вмещаться в пару гигабайт памяти и 20 минут. И да, выдавать &lt;a href='https://twitter.com/puffnfresh'&gt;корректный&lt;/a&gt; ответ для пары тысяч чисел в первой версии, спустя полтора часа...&lt;/p&gt;&lt;p&gt;Обзор тематических ресурсов подходы к решению проблемы найти не позволил. Консультация с коллегой-фаном хаскеля, который кстати тоже получил что-то не вменяемое в первой версии программы, и перестановка чего-то там в паре выражений (перед глазами встал призрак 2003 студии где перестановка инклудов иногда чинила access violation)  позволили сократить время до нескольких минут. Для интереса сделал тоже на питоне за 10 мин, 20 или 30 секунд выполнения и символическое потребление памяти. Искать с помощью Хаскеля минимальный разрез графа из нескольких тысяч узлов я уже не рискнул.&lt;/p&gt;&lt;p&gt;Ну и главное: нет примеров полномасштабных приложений. Какая нибудь обработка исключений от трёх функций с помощью стрелок находится легко. Исходник простого веб-сервера, без расширений языка, без 90% закопанного в библиотеки найти сложно. Хотелось бы увидеть простой аналог рисовалки или текстового редактора. Что угодно что демонстрирует в рамках 3-4 экранов дизайн полноценного приложения которое читает, пишет, показывает что-то пользователю, реагирует на ошибки и нарушения форматов. Таких примеров нет, невозможно оценить какой массив знаний необходим для создания полноценного приложения. Теркат? Трансформеры? Дисер Окасаки? Свободная навигация по исходникам компилятора? Я за три года так и не понял.&lt;/p&gt;&lt;p&gt;Ещё для меня серьёзной проблемой является типографический кретинизм большинства авторов. Он проявляется в нескольких аспектах. Во-первых для функции нормально &lt;a href='http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators'&gt;не иметь человеческого имени&lt;/a&gt;. Пишем &lt;*&gt;, в уме проговариваем "треугольная жопа", как описать код коллеге не понятно. Во-вторых статьи абсолютно всех уровней, от ICFP до очередного тьюториала по монадам в блоге программиста Васи наполнены типографскими аналогами собственно операторов языка, то есть вместо -&gt; везде →. Какая-нибудь тау с нижним и верхним индексом - тоже святое дело. Вообще обучение на примере кода который не запускается - норма для данного сообщества. В том же LYHGG процентов 30 не работало ещё три года назад когда я его читал.&lt;/p&gt;&lt;p&gt;Ну и сообщество. Я там выше давал ссылочку на любителя корректных программ, подпишитесь - понаблюдайте недельку. Подумайте что делать если к такому существу придётся обращаться за поддержкой или оно окажется у вас в команде. Справедливости ради надо заметить что те кто собственно что-то делает, разработчики самого компилятора и популярных билиотек более вменяемы и не лишены кругозора.&lt;/p&gt;&lt;p&gt;Чуть не забыл, данная заметка не претендует на полный охват предмета. Haskell имеет некоторое (конечное) количество положительных черт, но я тут про них умолчал. Жаждущие серебряных пуль могут найти их в интернете во множестве.&lt;/p&gt;&lt;p&gt;UPD: Буду сюда докидывать пруфы&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://www.haskell.org/pipermail/haskell-cafe/2014-June/114724.html'&gt;Need help - my haskell code is over 50 times slower than equivalent perl implementation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://codeflow.wordpress.com/2011/02/20/the-reasons-i-dont-write-all-my-code-in-haskell/'&gt;The reasons I don’t write all my code in Haskell&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2a310v/where_is_haskell_going_in_industry/'&gt;Where is Haskell going in industry?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2aerm7/whats_the_performance_bottleneck_in_this_prime/'&gt;What's the performance bottleneck in this prime sieve function?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2ain3c/beginner_parse_error_on_input/'&gt;Beginner - Parse Error on Input '='&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2al3vx/how_do_you_avoid_the_cabal_hell/'&gt;How do you avoid the Cabal Hell™?&lt;/a&gt; (третий пункт прекрасен, изящный функциональный дизайн типа)&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2ali12/complete_roadmap_from_total_novice_to_haskell/'&gt;Complete roadmap from total novice to Haskell mastery?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.reddit.com/r/haskell/comments/2fxjcg/how_do_you_structure_a_program_to_support_logging/'&gt;How do you structure a program to support logging?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.reddit.com/r/haskell/comments/2n0991/how_lazy_evaluation_works/cm9qx7v'&gt;Why is foldl bad?&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Thu, 19 Jun 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-05-26-untypical-ides/</guid><link>https://cheatex.cc/posts-output/2014-05-26-untypical-ides/</link><title>Нетипичные IDE</title><description>&lt;p&gt; Не так давно я написал довольно обстоятельный пост про проблемы современных IDE. В частности подробно отписался почему они могут нанести существенный ущерб проекту без должной осторожности и почему заметной пользы они не приносят. Что характерно пост получился самым популярным за историю блога и много народу не поленилось даже отстоять любимый инструмент в твиттере.&lt;/p&gt;&lt;p&gt;Пришло время перейти к конструктиву и немного посмотреть как их можно делать среды которые что-то меняют в процессе разработки. Есть изрядное количество инструментов которые пытаются продвинуться за пределы 95го года и существенно изменить способ взаимодействия программиста и разрабатываемой им программы.&lt;/p&gt;&lt;p&gt;Вот например &lt;a href='http://www.squeak.org/'&gt;Squeake&lt;/a&gt;, первый релиз 96 год. (Небось думали я с потолка год в прошлом посте взял? Правильно думали на самом деле, да и большинство обсуждаемых далее фич были в &lt;a href='http://weather-dimensions.com/tedkaehler/us/ted/resume/st80release-lic2.jpg'&gt;Smalltalk-80&lt;/a&gt;). Я наверно повторяю очень известную вещь, но всё таки: основной чертой Smalltalk является существование live image. В нём нет статического кода и времени исполнения, всё что делает программист порождает объекты в одном образе, этот образ несёт в себе и код и живые объекты на одинаковых правах. Образ содержит и ядро языка, и разрабатываемое приложение, и среду разработки одновременно, при поставке пользователю ненужные классы удаляются.&lt;/p&gt;&lt;p&gt;Подход этот конечно спорный, но он имеет несколько явно положительных результатов. Например при разработке графики можно весьма просто с ней управляться. Например имея нарисованную как-то картинку можно немного её покрутить, примерить к другой картинке, продублировать. &lt;a href='http://www.youtube.com/watch?v=oH-Jj_1v8BM#t=78'&gt;Как-то так&lt;/a&gt; или &lt;a href='https://www.hpi.uni-potsdam.de/hirschfeld/trac/SqueakCommunityProjects/raw-attachment/wiki/squeak_screencasts/Image-Halos.m4v'&gt;так&lt;/a&gt; (вторая ссылка покороче, но требует скачивания видяшки). А после соответствующего благоустройства среда позволяет &lt;a href='http://www.youtube.com/watch?v=34cWCnLC5nM'&gt;что-то программировать&lt;/a&gt; даже детям. Ну и вообще она полна простых приятностей, вот например Object inspector.&lt;/p&gt;&lt;p&gt;&lt;img src="/img/Exploring-ObjectExplorerInspector-2.jpg" alt="Object inspector" /&gt;&lt;/p&gt;&lt;p&gt;"Чего же тут такого интересного?" - многие спросят. Вроде и ничего, но вот 2014 год на дворе а все популярные среды разработки по-прежнему считают что цвет нормально показывать как десятизначное число.&lt;/p&gt;&lt;p&gt;Второй интересной наработкой Smalltalk является &lt;a href='http://wiki.squeak.org/squeak/1916'&gt;method finder&lt;/a&gt;. Первая его фича - поиск по ключевым словам более менее освоена современными IDE. А вот вторая, поиск по примеру и сейчас, спустя примерно 30 лет после создания насколько я знаю ни кем не повторена. Если кратко она позволяет ввести пример результата метода при заданных аргументах и получить список методов которые этому примеру удовлетворяют. Например на запрос ' trim my spaces '. 'trim my spaces' он ответит #withBlanksTrimmed.&lt;/p&gt;&lt;p&gt;Ладно, хватит истории, вот пара проектов которые прямо сейчас в разработке. Первый, собравший 300k$ на кикстартере, &lt;a href='http://www.lighttable.com/'&gt;Light table&lt;/a&gt;. Это IDE которая должна решить несколько известных проблем и серьёзно пересмотреть постановку других. На данный момент она нацелена на поддержку Clojure, JavaScript и Python. Среди наиболее интересных фичей:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Абстрагирование от файлов проекта, редактор показывает и даёт редактировать функции динамически компонуя их по мере просмотра и редактирования исходников.&lt;/li&gt;&lt;li&gt;Автоматический показ документации и/или исходников связанных функций.&lt;/li&gt;&lt;li&gt;Интерактивная отладка, как через горячую подмену кода так и через 'watches' которые позволяют записывать и отображать состояние программы в отдельных точках.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Текущие релизы правда пока сконцентрированы на разработке тюнингуемого редактора. Но разрабы &lt;a href='https://groups.google.com/d/topic/light-table-discussion/1Hyeia7TXag/discussion'&gt;полны решимости&lt;/a&gt; довести первоначальную идею до конца, вплоть до запила своего языка с блэкджеком и монадами.&lt;/p&gt;&lt;p&gt;Проект &lt;a href='http://peaker.github.io/lamdu/'&gt;Lamdu&lt;/a&gt; параллельно развивает язык и среду разработки для него. Язык построен на основе Haskell с изменениями направленными на большую явность конструкций и адаптацию для визуального представления структуры программ. В частности он вводит обязательные имена параметров для функций и явно отображает типы в лямбда-выражениях.&lt;/p&gt;&lt;p&gt;Среда построена вокруг структурированного представления и редактирования кода с выделением различных элементов шрифтом и цветом.  Редактор позволяет вводить код только в предназначенные для этого слоты, контролирует после ввода тип, предполагаются умные автодополнения. Ошибки типизации получаются хорошо локализованы (не могу не заметить что оригинальный хаскель тут от C++ ушёл совсем не далеко, точность ошибки компенсируется неопределённостью её местоположения).&lt;/p&gt;&lt;p&gt;Редактор автоматически применяет визуальную свёртку сложных языковых конструкций (вроде лямбд и аннотаций параметров как на картинке). Среди целей проекта предоставление билиотекам возможности настраивать отображение для своих структур данных и функций.&lt;/p&gt;&lt;p&gt;&lt;img src="/img/lamdu.png" alt="Lamdu" /&gt;&lt;/p&gt;&lt;p&gt;Также предполагается поддержка "regression debugging", то есть автоматический контроль хода выполнения теста и поиск изменения которое сломало тест. Примерно можно сказать что IDE будет запоминать все промежуточные результаты вычисления функций и сравнивать их для каждой версии. Хотя в контексте ленивости языка всё явно будет хитрее.&lt;/p&gt;&lt;p&gt;Помимо попыток привнести глобальные улучшения в IDE есть несколько инструментов реализующие какие-то конкретные компоненты гораздо лучше, чем принято в мэйнстриме.&lt;/p&gt;&lt;p&gt;Вот например &lt;a href='http://2013.cppnow.org/session/the-projucer-live-coding-with-c-and-the-llvm-jit-engine/'&gt;Projucer&lt;/a&gt;, инструмент визуальный разработки для &lt;a href='http://www.juce.com/'&gt;Juce&lt;/a&gt;. Ничего сверхъестественного, просто быстрая связь кода и картинки, но всё-таки поживее многочисленных SWING-дизайнеров, а пишется одним человеком.&lt;/p&gt;&lt;p&gt;Ещё один проект, коммерческий, &lt;a href='http://chrononsystems.com/what-is-chronon'&gt;Chronon&lt;/a&gt;. Включает в себя "Time Traveling Debugger". Это забавный инструмент который работает с полной записью исполнения программы. Записи получаются с помощью чёрной магии и второго компонента Chronon'а - "Recording Server". Нам же тут интересен дебаггер.&lt;/p&gt;&lt;p&gt;Его центральной фичей является возможность идти не только вперёд но и назад. Найдя ошибку можно вместо того чтобы расставлять бряки в подозрительных местах и перезапускать программу просто пойти назад и посмотреть "откуда пошло". Есть множество приятностей, вроде подсветки активных путей исполнения, истории состояний для переменных и вызовов методов. Много различных фильтров для поиска нужных значений в истории. Для примера можно посмотреть &lt;a href='http://www.youtube.com/watch?v=X80EdpI9z1Y'&gt;вот это видео&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Последний пример с совсем неожиданного направления, из мира железячных корпораций и кровавого геймдева. PhysX debugger - инструмент для физического движка от nVidia. Он создан для отладки поведения физической модели в сложных сценах. И демонстрирует очень высокий уровень использования различных визуализаций. Если вам интересно визуальное программирование я рекомендую потратить 15 мин и посмотреть обзорный ролик целиком: &lt;a href='https://www.youtube.com/watch?feature=player_embedded&amp;v=aKsY-U4kUBA'&gt;PVD tutorial video&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;В этом инструменте есть множество примеров визуализации разных аспектов динамических сцен и процесса их вычисления, вот &lt;a href='https://www.youtube.com/watch?feature=player_embedded&amp;v=aKsY-U4kUBA#t=434'&gt;интересный кусочек&lt;/a&gt; для ленивых (смотреть минуты три). Есть функции бэктрекинга, когда есть бажный объект, есть момент времени когда с ним что-то не так и надо найти откуда проблема появилась. Предусмотрены инструменты для командной работы, можно аннотировать дебаг-сессию оставляя каменты к объектам в определённые моменты времени. Сессия экспортируется и может быть передана коллеге для дальнейшего разбора проблемы. Действительно развитый инструмент для решения весьма нетривиальных задач.&lt;/p&gt;&lt;p&gt;Напоследок уже в который раз не могу не дать ссылку на сайт Bret Victor'а, которого авторы большинства описанных выше проектов называют в числе основных источников идей: &lt;a href='http://worrydream.com/'&gt;worrydream.com&lt;/a&gt;. Если Вы ещё не изучили все его материалы стоит немедленно начать.&lt;/p&gt;</description><pubDate>Mon, 26 May 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-04-08-racket-env/</guid><link>https://cheatex.cc/posts-output/2014-04-08-racket-env/</link><title>Альтернативная среда для Racket</title><description>&lt;p&gt;Это последний отчёт о моих опытах с Racket и посвящён он сугубо техническому вопросу, а именно среде разработки. По умолчанию новоиспечённому Racket-разработчику предлагается минимальная среда разработки. Она умеет открывать файлы с исходниками, подсвечивать синтаксис, загружать их в простой (ну очень простой) REPL и запускать под отладкой.&lt;/p&gt;&lt;p&gt;В принципе это не так и мало, но хотелось большего. А именно:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Полноценного REPL который бы помнил историю команд и умел подгружать изменения без полного перезапуска.&lt;/li&gt;&lt;li&gt;Быстрой навигации по именам функций и структур.&lt;/li&gt;&lt;li&gt;Богатого функционалом текстового редактора, в частности мультивыделения и быстрого поиска.&lt;/li&gt;&lt;li&gt;Поддержки проектов, по крайней мере коллекций файлов по которым можно искать.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;REPL достаточно быстро нашёлся, &lt;a href='http://docs.racket-lang.org/xrepl/'&gt;xrepl&lt;/a&gt;. Он прекрасно помнит историю, умеет (пере)загружать файлы, заходить в них чтобы тестировать не экспортированные функции и органично встраивается в shell. Инструкция по установке на сайте хорошо работает, для полного счастья только пришлось добавить в bash_aliases следующую строчку: &lt;code&gt;xracket=&amp;quot;racket -il xrepl&amp;quot;&lt;/code&gt;. Она запускает Racket в интерактивном режиме и загружает модуль xrepl. Модуль написан таким образом что сам применяет все необходимые хаки для создания полноценной оболочки.&lt;/p&gt;&lt;p&gt;Однако не сразу всё идеально заработало. Файлы с константами было невозможно перезагружать ,rr - Racket выдавал ошибку переопределения имён. Небольшое исследование вопроса показало что это связано с включенными по умолчанию оптимизациями и легко может быть исправлено одной командой, алиас принял вид &lt;code&gt;xracket=&amp;quot;racket -il xrepl --eval '&amp;#40;compile-enforce-module-constants #f&amp;#41;'&amp;quot;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Остальные 3 функции поставляет Sublime оставалось только подружить его немного с ЛИСПом, благо я не первый кто этим озадачился. Установка пары плагинов налаживает между крепкую дружбу между Racket и Sublime. Для упрощения жизни я использовал &lt;a href='https://sublime.wbond.net/installation#st2'&gt;Package Control&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Первый и самый насущный - конечно отступы :) &lt;a href='https://sublime.wbond.net/packages/lispindent'&gt;lispindent&lt;/a&gt; - отлично справляется с этой задачей и даже не пугается квадратных скобок.&lt;/p&gt;&lt;p&gt;Второй - &lt;a href='https://github.com/follesoe/sublime-racket'&gt;подсветка синтаксиса&lt;/a&gt;. В принципе она уже была, однако некоторые конструкции понимала не корректно. В частности совершенно убивали подсветку литералы #something а также функции и структуры не появлялись в списке символов. За пару дней поправил всё это и даже заслал патч в основную ветку проекта.&lt;/p&gt;&lt;p&gt;Ну и последняя доводка из области эстетства - красивая подсветка скобок и быстрый переход между ними. Делается плагином Bracket Highlighter. Очень удобно показывает границы блока слева, рядом с номерами строк а также позволяет включить "усиленную подсветку" - дополнительно подсветить весь текст принадлежащий выделенному блоку. Плюшки вроде удалить блок или перейти во внешний также присутствуют.&lt;/p&gt;&lt;p&gt;Для того чтобы всё это дружило потребовалось буквально пара настроек.&lt;/p&gt;&lt;p&gt;Во-первых надо включить lispindent для соответствующего языка следующей настройкой в &lt;code&gt;lispindent.sublime-settings&lt;/code&gt; (если используется Package Control то его можно открыть через меню Preferences-&gt;Package settings).&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;languages&amp;quot;: {
    &amp;quot;racket&amp;quot;: {
      &amp;quot;syntax&amp;quot;: &amp;quot;Racket.tmLanguage&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В настройках Bracket Highlighter, которые &lt;code&gt;bh&amp;#95;core.sublime-settings&lt;/code&gt; (также легко открываются через меню Preferences-&gt;Package settings) надо только найти и настроить под себя параметр &lt;code&gt;high&amp;#95;visibility&amp;#95;style&lt;/code&gt;, мне понравился &lt;code&gt;underline&lt;/code&gt;. Также удобно повесить переключение этого режима на хоткей, для этого в &lt;code&gt;Default.sublime-keymap&lt;/code&gt; надо дописать&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;keys&amp;quot;: &amp;#91;&amp;quot;ctrl+\\&amp;quot;&amp;#93;,
  &amp;quot;command&amp;quot;: &amp;quot;bh&amp;#95;toggle&amp;#95;high&amp;#95;visibility&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ну и проверить что файлы &lt;code&gt;.rkt&lt;/code&gt; открываются как Racket по умолчанию.&lt;/p&gt;&lt;p&gt;В принципе это всё. Я первый раз что-то глубоко копал в настройку Sublime и результат мне очень понравился. Всё, вплоть до написания своего плагина, решается достаточно легко и работает вполне безглючно.&lt;/p&gt;</description><pubDate>Tue, 08 Apr 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2010-02-25-what-to-ask/</guid><link>https://cheatex.cc/posts-output/2010-02-25-what-to-ask/</link><title>Что интересно спросить у работодателя</title><description>&lt;h3 id="анализ,&amp;#95;общение&amp;#95;с&amp;#95;пользователями"&gt;Анализ, общение с пользователями&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Откуда берутся требования?&lt;ul&gt;&lt;li&gt;Как оценивается их выполнение?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Требования пересматриваются?&lt;ul&gt;&lt;li&gt;По каким причинам?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Как часто пользователь получает результаты работы?&lt;/li&gt;&lt;li&gt;Участвуют ли пользователи и эксперты в разработке?&lt;ul&gt;&lt;li&gt;В каких формах?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Что предпринимается в случае выявления противоречивости требований?&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="процесс,&amp;#95;планирование"&gt;Процесс, планирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Как формируются задачи на основе требований?&lt;/li&gt;&lt;li&gt;Как оцениваются сроки их выполнения?&lt;/li&gt;&lt;li&gt;Что предпринимается в случае невозможности выполнения требований по&lt;ul&gt;&lt;li&gt;техническим причинам?&lt;/li&gt;&lt;li&gt;организационным причинам?&lt;/li&gt;&lt;li&gt;экономическим причинам?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="программирование"&gt;Программирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Какая VCS используется? Почему?&lt;/li&gt;&lt;li&gt;Есть-ли стандарт кодирования?&lt;ul&gt;&lt;li&gt;Какие аспекты кода он регламентирует?&lt;/li&gt;&lt;li&gt;Как контроллируется его соблюдение?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Сколько человек видят/рецензируют код до его попадания в production?&lt;ul&gt;&lt;li&gt;Как это обеспечивается?&lt;/li&gt;&lt;li&gt;Обязательно-ли исправление по итогам сбора отзывов?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Как происходит сборка продукта?&lt;/li&gt;&lt;li&gt;Есть-ли система автоматической сборки?&lt;ul&gt;&lt;li&gt;Какие действия она предпринимает в случае успеха/неудачи сборки?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Имеет-ли разработчик в своём распоряжении полный стенд разрабатываемого продукта или какие-то его части?&lt;ul&gt;&lt;li&gt;Этот стенд изолирован от других разработчиков?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="контроль&amp;#95;качества,&amp;#95;тестирование"&gt;Контроль качества, тестирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;На какие уровнях производится тестирование?&lt;ul&gt;&lt;li&gt;Как каждый из них автоматизирован?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Есть-ли люди ответственные за контроль качества?&lt;ul&gt;&lt;li&gt;Сколько их от общего числа разработчиков?&lt;/li&gt;&lt;li&gt;Какие задачи они решают?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Thu, 25 Feb 2010 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2008-10-22-jboss-per-app-logs/</guid><link>https://cheatex.cc/posts-output/2008-10-22-jboss-per-app-logs/</link><title>Раздельные логи приложений в JBoss</title><description>&lt;p&gt;Встала задача организовать раздельную запись логов для нескольких экземпляров одного и того-же приложения, запущенных на сервере(разделение экземпяров просто переименование war-ок). При этом дополнительно хотелось получить также: конфигурирование логов отдельно от самого сервера(читай не в серверном &lt;code&gt;jboss-log4j.xml&lt;/code&gt;, а в собственном конфиге приложения, один экземпляр log4j как на диске, так и в памяти.&lt;/p&gt;&lt;p&gt;Простая упаковка конфига вместе с приложением успеха, как и ожидалось, не принесла. Если верить форумам/мэйллистам причина в том, что по умолчанию JBoss подкладывает приложениям свои библиотеки в класспат, соответственно приложения используют уже инициализированный экземпляр log4j.&lt;/p&gt;&lt;p&gt;Вторым этапом стала попытка использовать хак со слушателем контекста и установкой в нём &lt;code&gt;RepositorySelector&lt;/code&gt; взятый &lt;a href='http://docs.jboss.org/process-guide/en/html/logging.html'&gt;тут&lt;/a&gt;, раздел 10.3.8(что примечательно попал он мне на глаза сначала в каком-то блоге, а не в оф. доке). Работал он плохо: при переразвёртываниии приложения падала ошибка при инициализации JBoss log4j plugin. Думаю из за того, что при этом старый ClassLoader убивается и все созданные им классы вместе с ним. Заниматься дебагом сервера было немного лень, а сообщение обошибке было, мягко говоря, кратким.&lt;/p&gt;&lt;p&gt;В третий заход применил подход описанный &lt;a href='http://docs.jboss.org/process-guide/en/html/logging.html'&gt;там-же&lt;/a&gt; в разделе 10.3.6. А именно: положил в папку &lt;code&gt;WEB-INF/lib&lt;/code&gt; log4j и commons-logging(в своём приложении на всякий случай решил использовать его, а не напряму log4j), положил в папку &lt;code&gt;WEB-INF/classes&lt;/code&gt; свой &lt;code&gt;log4j.xml&lt;/code&gt; а также создал файлик &lt;code&gt;jboss-web.xml&lt;/code&gt;(до этого обходился стандартным дескриптором) с содержимым, описанным в доке чуть ниже.&lt;/p&gt;&lt;p&gt;Потом ещё переучил оставшийся с прошлой попытки листенер записывать в системные свойства имена приложения(точнее контекста) и конфига(&lt;code&gt;log4j.xml&lt;/code&gt;). (В спринге есть специальный, более одарённый листенер для этих целей, но спринга пока в проекте нет и связываться было лень.)&lt;/p&gt;&lt;p&gt;Commons-logging увидел старшого брата без дополнительных манипуляций.&lt;/p&gt;&lt;p&gt;Результат: аккуратненький набор папочек в &lt;code&gt;/log&lt;/code&gt; сервера с подневными логами соответствующих приложений. Надо отметить, что это, между тем, не совсем нирвана ибо экземпляр log4j на каждое приложение - и память не по делу и место на диске... в эпоху гигабайтных планок не сильно проблемно, но всё-таки. Есть мнение, что если поглубже покопать в серверный класслоадинг (точнее хоть чуть-чуть копнуть, ибо то, что вписал в конфигурашку я понял приближённо) можно её и достичь...&lt;/p&gt;</description><pubDate>Wed, 22 Oct 2008 00:00:00 +0400</pubDate></item></channel></rss>