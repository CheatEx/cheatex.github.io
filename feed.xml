<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://cheatex.cc/" rel="self" type="application/rss+xml"/><title>cheatex</title><link>https://cheatex.cc/</link><description>Yet another personal site</description><lastBuildDate>Tue, 26 Nov 2019 22:26:51 +0300</lastBuildDate><generator>clj-rss</generator><item><guid>https://cheatex.cc/posts-output/2019-11-10-test-classification/</guid><link>https://cheatex.cc/posts-output/2019-11-10-test-classification/</link><title>Классификация тестов</title><description>&lt;p&gt;Традиционно тесты классифицируют как юнит, интеграционные, функциональные. Логика следующая:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Юнит - тестирует один модуль или класс с зависимостями компиляции, и по возможности без модулей которые нужны только в рантайме. Другими словами старается тестировать поведение одной штуки в изоляции.&lt;/li&gt;&lt;li&gt;Интеграционные - тестируют несколько модулей, примерно как они будут связаны в рантайме. Тестирует непосредственное взаимодействие нескольких штук.&lt;/li&gt;&lt;li&gt;Функциональные - более-менее вся система как она будет работать. Тестирует опосредованное взаимодействие, очень многих штук сразу.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Мне она уже давно кажется абсолютно бесполезной.&lt;/p&gt;&lt;p&gt;Одна проблема с ней - размазанные границы. Многие тесты попадают в пару категорий. Вроде "в основном у нас один модуль, но вот эту зависимость не замокать". Или "вообще тест функциональный, но с настоящей БД сложно запускать в тимсити".&lt;/p&gt;&lt;p&gt;Вторая проблема - плохая связанность с операционными характеристиками теста. Пример: есть интеграционные-тесты на процедуру логина и на драйвер чужого сервиса. Они оба и правда интеграционные - собирают пару модулей вместе, мокают зависимости такой сборки. Первый ходит в заглушку БД и отдаёт фиктивные данные, второй получает фиктивные запросы и ходит в заглушку сервиса. При этом у них сильно отличается время работы, у первого 3±1ms у второго 30±10ms. Гонять сотню аналогов первого можно каждый Ctrl+S, сотню аналогов второго - только в перерывах на чай.&lt;/p&gt;&lt;p&gt;На практике полезнее другая классификация. Не концептуальная, зато однозначная и позволяющая делать практические выводы об операционных свойствах теста.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Быстрые тесты. Пользуются только памятью и процессором, субквадратичные алгоритмы, входные данные менее 10MB.&lt;/li&gt;&lt;li&gt;Медленные тесты. Пользуются одним внешним ресурсом (файлы, сети, видяхи :) ), субквадратичные алгоритмы, входные данные менее 100MB.&lt;/li&gt;&lt;li&gt;Тяжёлые тесты. Пользуются многими внешними ресурсами, произвольные алгоритмы, произвольные объёмы данных.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;С некоторыми исключениями про такие категории можно сказать следующее:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Быстрые тесты&lt;/strong&gt; даже для крупного компонента займут не более минуты с пренебрежительно малым разбросом. Можно использовать агрессивные политики таймаута и ограничения памяти. Для компонента можно выполнять на каждое изменение в десяток строк, повестить на сохранение или фоновый прогон по кругу. Стоит выполнять для всего проекта для каждого коммита.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Медленные тесты&lt;/strong&gt; займут до 5 минут для компонента, и будут иметь небольшие выбросы. Можно применить сдержанные политики таймаутов и памяти. Стоит выполнять для одного или нескольких компонентов на каждом коммите. Для всего проекта может выполнять CI.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Тяжёлые тесты&lt;/strong&gt; занимают до 30 минут для компонента, могут иметь большие выбросы. Политики таймаутов и ограничения ресурсов будут работать только мягкие. Запускать их локально уместно только если есть инсайт на высокую вероятность поломки. В основном работают в CI.&lt;/p&gt;&lt;p&gt;Это конечно легко тюнится под конкретную кодовую базу, процессные и операционные реалии. Надеюсь идея понятна.&lt;/p&gt;&lt;p&gt;Кстати JUnit 5 добавил радикально улучшенную &lt;a href='https://junit.org/junit5/docs/current/user-guide/#writing-tests-meta-annotations'&gt;поддержку категоризации тестов&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Sun, 10 Nov 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-08-23-understanding-computation/</guid><link>https://cheatex.cc/posts-output/2019-08-23-understanding-computation/</link><title>Understanding computation</title><description>&lt;p&gt;Я в полном восторге от книги. По содержанию - это введение в теорию вычислений. По форме - пошаговые инструкции на руби по реализации разных интерпретаторов и виртуальных машин. Она состоит из трёх больших разделов.&lt;/p&gt;&lt;p&gt;Первый про языки и интерпретаторы. Пробуем по разному задать семантику языка, собрать синтаксическое дерево и написать простой интерпретатор. Возня с парсерами естественно решена одной рубёвой библиотекой.&lt;/p&gt;&lt;p&gt;Второй про модели вычислений. Всё классически: детерминированые-недетерминированные машины с состояниями, машины с состояниями и памятью, разбор языков с их помощью. Только собственно берём и программируем их. Машина Тьринга, лямбда-исчисление. Чувак реально пишет fizz-buzz на одних лямбдах! Не то чтобы я не верил другим книжкам, но вот прям взял и убедился что оно реально рaботает. Под конец рассказывает о SKI и еще нескольких экзотических моделях.&lt;/p&gt;&lt;p&gt;Третья часть больше про теорию. Кратко и уже только с эскизами кода рассматриваем решаемые/нерешаемые машиной Тьюринга задачи. Ковыряем задачу останова. Смотрим на некоторые опции model-checking и пишем простой чекер.&lt;/p&gt;&lt;p&gt;В общем всё самое интересное и хоть как-то соотносящееся с практикой программирования в одном издании. У меня новая #1 рекомендованная книга по CS.&lt;/p&gt;</description><pubDate>Fri, 23 Aug 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-06-03-elements-of-programming/</guid><link>https://cheatex.cc/posts-output/2019-06-03-elements-of-programming/</link><title>Начала программирования</title><description>&lt;p&gt;У меня уже лет 5 в закромах лежала довольно занимательная книга "Начала программирования" Степанова. Что характерно я её купил на книжном развале за старухой за 50 рублей. Где-то полгода назад почувствовал что борода стала достаточно густой чтобы попробовать её открыть.&lt;/p&gt;&lt;p&gt;Книга неплоха, но тяжела для чтения без необходимости.&lt;/p&gt;&lt;p&gt;Основное внимание уделено отношению между математическими концепциями, их выражением в ЯП и непосредственно структурами в памяти. Это довольно интересный топкик, обычно как в литературе таки и во всяких блого-конференциях один из аспектов начисто игнорируется. Содержание построено грамотно и в принципе старается идти от простого к сложному. Автор не пытается объять всё сразу, а плавно строит инструментарий и применяет его в простых но имеющих смысл для бывалого программиста задачах. Математические аспекты напоминаются бегло и немного путанно, видимо пару раз на почитать чтонить по алгебре придётся отвлечься.&lt;/p&gt;&lt;p&gt;Язык крайне тяжёл. Много собственной терминологии. Причём термины многословны и похожи, много времени тратится на листание назад в поисках определения. Можно было радикально упростить восприятие небольшими врезками с напоминанием терминологии.  Также не хватает диаграмм, особенно при обсуждении бифуркатных координат, переупорядочений и вспомогательных "машин". Пришлось много рисовать самому чтобы въехать.&lt;/p&gt;&lt;p&gt;В общем типичный экземпляр позднесоветской литературы. Если есть хорошее представление что хочешь от книги получить и тебе повезло быть с автором примерно на одной волне то можно подчерпнуть много интересных идей. Если нет - идите нахер, у нас тут фундаментальное образование, мы тут не развлекаться собрались, надо привыкать  страдать.&lt;/p&gt;&lt;p&gt;Эксперты рекомендуют для расширения сознания.&lt;/p&gt;</description><pubDate>Mon, 03 Jun 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-03-27-web-improved/</guid><link>https://cheatex.cc/posts-output/2019-03-27-web-improved/</link><title>The HTML we shouldn't ever have</title><description>&lt;p&gt;Мне попался &lt;a href='http://skch.net/view.php?page=articles&amp;post=bhtml'&gt;проект как сделать вэб лучше&lt;/a&gt; и что-то мне кажется проработан он весьма поверхностно...&lt;/p&gt;&lt;p&gt;Для начала автор сетует что аттрибут &lt;code&gt;src&lt;/code&gt; не был внедрён повсеместно, а только для &lt;code&gt;img&lt;/code&gt;. В частности:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Everyone was fascinated with the new features, and most likely the reason why no one had a wit to ask: why don’t we let all the other HTML elements also use this attribute?  &lt;h1 src="/website/info/title"&gt; &lt;/h1&gt;  This code means that the browser must load the content of the heading from the provided URL. Maybe it doesn’t make much sense for such a small element, but what about a div or an article? &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Дальше больше, автор предлагает ввести подстановки в язык разметки, в духе&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;name&amp;quot;&amp;gt;George&amp;lt;/div&amp;gt;
&amp;lt;h1&amp;gt;Welcome, $name&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Дело тут какое. Во-первых src много где есть, например в &lt;a href='https://www.owasp.org/index.php/Cross_Frame_Scripting'&gt;полюбившемся всем&lt;/a&gt; &lt;code&gt;iframe&lt;/code&gt;. И кое-где он &lt;a href='https://www.owasp.org/index.php/Clickjacking'&gt;уже доставляет&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Во-вторых давайте почитаем что говорит один из авторов современного web про проблемы которые он пытался решить.&lt;/p&gt;&lt;p&gt;Что требовалось от HTML и где он не справился:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; HTML is an example of a media type that, for the most part, has good latency  characteristics. Information within early HTML could be rendered as it was received... &lt;/p&gt;&lt;p&gt; However, there are aspects of HTML that were not designed well for latency. Examples include: ...;&lt;br /&gt; embedded images without rendering size hints, requiring that the first few bytes of the image&lt;br /&gt; (the part that contains the layout size) be received before the rest of the surrounding HTML&lt;br /&gt; can be displayed; dynamically sized table columns, requiring that the renderer read&lt;br /&gt; and determine sizes for the entire table before it can start displaying the top; ... &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;В моём понимании рац. предложение из поста - сразу два шага назад. Первый - больше запросов на страницу, второй - еще больше компонентов которые не могут рисоваться до полной загрузки.&lt;/p&gt;&lt;p&gt;Теперь немного оценки &lt;code&gt;src&lt;/code&gt; в контексте &lt;code&gt;iframe&lt;/code&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; ... The introduction of “frames” to the Hypertext Markup Language (HTML) caused  similar confusion. Frames allow a browser window to be partitioned into subwindows,  each with its own navigational state. Link selections within a subwindow are  indistinguishable from normal transitions, but the resulting response representation is  rendered within the subwindow instead of the full browser application workspace. This is  fine provided that no link exits the realm of information that is intended for subwindow  treatment, but when it does occur the user finds themself viewing one application wedged  within the subcontext of another application. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Здесь нельзя указать на очевидную деградацию, own navigational state вроде не предлагается. Но предлагается использовать в src переменные с не совсем понятной областью видимости персистентностью. Ограничения на куда &lt;code&gt;src&lt;/code&gt; ходит типа тоже не нужны?&lt;/p&gt;&lt;p&gt;Ничего не сказано о том как читать/писать/переопределять стили и новые $-переменные в подгруженных из src элементах. Без модели каскадирования - это просто размахивание руками. Проблему с ней ведь и пытаемся решить, не?&lt;/p&gt;</description><pubDate>Wed, 27 Mar 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-03-23-on-interviews/</guid><link>https://cheatex.cc/posts-output/2019-03-23-on-interviews/</link><title>Про интервью</title><description>&lt;p&gt;На интервью реально интересно узнать о гребце следующее.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Способность быстро въезжать в более менее значительное количество кода. Не 10 строк с кастами лонгов в байты а в десяток-другой тысяч со всем возможным креативом.&lt;/li&gt;&lt;li&gt;Большой рабочий диапазон на шкале говнокодим быстро - делаем на века медленно.&lt;/li&gt;&lt;li&gt;Умение дебагать. На основе п. 1 и общих идей о том что не так строить путь из простых вопросов о поведении кода. И отвечаяя на них приходить к точке поломки.&lt;/li&gt;&lt;li&gt;Способность самостоятельно убедиться что его произведение работает в правдоподобных обстоятельствах. В идеале еще умение эти обстоятельства выяснить.&lt;/li&gt;&lt;li&gt;Ну и физическую способность грести хотя бы часов 20 в неделю, в перспективных стартапах и поболе. Я естественно про время в потоке, а не время за проходной.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Эти вопросы объединяет то что реалистичные ответы на них можно получить не раньше чем через месяц. Так что имеем на собесах то что имеем, смешное разбирательство с cultural fitом. Да, вращения деревья и отличия интерфейсов от абстрактных классов это культура и ничего общего с техническими навыками не имеют.&lt;/p&gt;</description><pubDate>Sat, 23 Mar 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-02-27-fire-and-motion-2019/</guid><link>https://cheatex.cc/posts-output/2019-02-27-fire-and-motion-2019/</link><title>Fire and motion 2019</title><description>&lt;p&gt; Немного реалий андроид программирования.&lt;/p&gt;&lt;p&gt;Сегодня понадобилось сделать тест работающий непосредственно на устройстве. (Никогда, слышите никогда не вводите зависимости между дествительно важным функционалом и любыми нативными API).&lt;/p&gt;&lt;p&gt;Сделал по гайду. Впилил зависимость &lt;code&gt;androidx.test:runner:1.1.0&lt;/code&gt;, повесил &lt;code&gt;@RunWith&amp;#40;AndroidJUnit4.class&amp;#41;&lt;/code&gt; на тест. Тут мне говорят ахтунг, 1.1.0 устарел, надо на 1.1.1 обновляться. Обновился, иду в код. Там снова ахтунг, &lt;code&gt;androidx.test.runner.AndroidJUnit4&lt;/code&gt; устарел, надо &lt;code&gt;androidx.test.ext.junit.runners.AndroidJUnit4&lt;/code&gt;. Поправил, одна беда - такого класса нет. Иду на SO, там советуют &lt;code&gt;androidx.test.ext:junit:1.1.0&lt;/code&gt;. Ну я то стаинг ап-ту-дейт, сразу на 1.1.1 поправил. Билдим - всё наёбывается, &lt;code&gt;androidx.test.ext:junit:1.1.1&lt;/code&gt; отсутсвует. Вдох, выдох, всё откатываем на 1.1.0. Билдим, билдицо. Запускаем тест - всё наёбывается, 2 экрана ошибок. Ещё глубже вдох, помедленнее выдох чтоб в голову не дало. Возвращаем аннотацию &lt;code&gt;androidx.test.runner.AndroidJUnit4&lt;/code&gt;. Работает!!!&lt;/p&gt;&lt;p&gt;А теперь 2 интересные детали. &lt;i&gt;Deprecation warning&lt;/i&gt; можно сапреснуть только во всём классе сразу. Gradle &lt;i&gt;dependency inspection&lt;/i&gt; нельзя сапреснуть вообще, только выключить полностью.&lt;/p&gt;&lt;p&gt;Интересно, зачем выпускать несовместимое обновление с изменением в 3 числе версии? Зачем рекомендовать миграцию с работающего класса на сломаный? Зачем заставлять делящихся прибылью разработчиков выбирать между кучей нерелевантных ворнингов и риском пропустить критичное изменение?&lt;/p&gt;&lt;p&gt;Классики проясняют &lt;a href='https://www.joelonsoftware.com/2002/01/06/fire-and-motion/'&gt;Fire And Motion&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Wed, 27 Feb 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2019-02-13-conditional-failures/</guid><link>https://cheatex.cc/posts-output/2019-02-13-conditional-failures/</link><title>Странный гайд по исключениям от гуавы</title><description>&lt;p&gt;Наткнулся тут на &lt;a href='https://github.com/google/guava/wiki/ConditionalFailuresExplained'&gt;гайд по пользованию исключениями в Guava&lt;/a&gt;, и видимо в джавовских проектах гугла.&lt;/p&gt;&lt;p&gt;Первое что бросается в глаза Rationale пропущен. Второе - 6 вариантов ответа для фундаментального вопроса это реально дохера. Если вчитаться тоже есть вопросы.&lt;/p&gt;&lt;p&gt;Мне показалось что основная проблема которая решается применением этой конвенции - поиск виноватых. Краткое изложение в табличке целиком про кто "messed up".&lt;/p&gt;&lt;p&gt;Не понятно зачем сюда втянут exceptional result. Типа контракт штуки такой, ожидаемое поведение. Test assertion его частный случай, ничего требующего выделения отдельного пункта не сказано. Дальше в табличке предлагают &lt;code&gt;AssertionError&lt;/code&gt; для него, видиом чтобы по ошибке не ловить падение теста вместо своего исключения. Но это стоило прояснять явно и в формате примечания к exceptional result.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Precondition&lt;/i&gt; check важный частный случай, всё-таки это ситуация когда у кода нет в принципе возможности сделать задуманое. Можно согласиться.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Assertion&lt;/i&gt; - понятно, поддерживаю.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Verification check&lt;/i&gt; пункт про поиск виноватых и пинг-понг. Никакой разницы почему вмерло нет, нарушено ожидание, действуем по плану assertion. А тут добавлен отдельный пункт и класс с утилитами под него.&lt;/p&gt;&lt;p&gt;&lt;i&gt;Impossible-condition&lt;/i&gt; check вообще не понимаю зачем нужен, всё еще assertion.&lt;/p&gt;&lt;p&gt;В этой системе есть проблема: легко ловить что-то тебе не предназначенное. Если есть контракты с исключениями то в код который их использует может приехать и &lt;i&gt;precondition check&lt;/i&gt; и &lt;i&gt;verification check&lt;/i&gt;. Чтобы работало ко всей конструкции надо еще добавлять правило в духе "не ловим &lt;code&gt;Exception&lt;/code&gt; и &lt;code&gt;RuntimeException&lt;/code&gt; в прикладном коде". И правило какой код уже можно считать системным. А потом еще правило про catch который на самом деле finally. Ну вы поняли.&lt;/p&gt;&lt;p&gt;Вывод: там тоже всё плохо. На Java надо писать без ошибок или не писать вообще.&lt;/p&gt;</description><pubDate>Wed, 13 Feb 2019 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-26-on-vs-code/</guid><link>https://cheatex.cc/posts-output/2018-12-26-on-vs-code/</link><title>Про VS Code</title><description>&lt;p&gt;Я тут еще довольно плотно посидел на VS Code. На удивление дельная вещь. Работает совсем неплохо в плане производительности и глючности. На жёсткие баги пока не налетал, не тормозит на i5 480M!&lt;/p&gt;&lt;p&gt;Из встроеных плюшек мне нравятся: всплывающий просмотр кода, терминал и его удобная интеграция с билдами, несколько вариантов навигации по табам.&lt;/p&gt;&lt;p&gt;Плагинов много на всё что можно придумать. Многие кажется ещё в процессе допила, явно не хватает функциональности.&lt;/p&gt;&lt;p&gt;Среда поддерживает двухсоставные хоткеи, когда жмёшь одну комбинацию и потом вторую. Простые хоткеи в основном разобраны самим редактором, а плагины используют двухсоставные. Сначала казалось дичью. Но потом понял что одна стартовая комбинация для плагина + мнемоника для конкретной функции очень удобно запоминается. В результате через небольшой промежуток времени хоткеи используются ативнее чем в других редакторах. Нет  конфликтов типа нужна мнемоника на eval а Ctrl+e и Alt+e заняты.&lt;/p&gt;&lt;p&gt;Я с ней связался  ради Clojure, по итогам считаю VS code наиболее цивилизованным вариантом. В emacs я не смог. В основном всё работает после установки одного плагина: Calva. Нельзя сказать что прям блестяще работает, но лучше чем франкенштейны которые у меня собирались на базе Sublime. Дешевле Cursive.&lt;/p&gt;</description><pubDate>Wed, 26 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-22-on-scala/</guid><link>https://cheatex.cc/posts-output/2018-12-22-on-scala/</link><title>Проблема со скалой</title><description>&lt;p&gt;Мне кажется очень большая беда языка scala в количестве понабежавших фанатиков хаскеля, упорно портирующих его бибилотеки и техники программирования. В своём порыве они мало на что обращают внимание (включая просьбы &lt;a href='https://twitter.com/odersky/status/382631934729277440'&gt;свалить подальше&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;При этом есть ряд техник которые в скажем так прикладном программировании не менее полезны, и языком очень хорошо поодерживаются. Это стиль больше похожий на ML модули и функторы. Про него есть &lt;a href='http://web.archive.org/web/20140815233646/http://blog.pellucid.com/post/94532532890/scalas-modular-roots-by-dan-james-earlier-this'&gt;отличное введение&lt;/a&gt; так и некоторые более серьёзные работы. Но сообщество как прикладников так и разработчиков бибилотек этот аспект языка в основном игнорирует. Беда понятна - техники всё ещё далеки от С++-style OOP и трудны в освоении. А чувства интеллектуального превосходства дают меньше, чем монад-трансформеры. В основном из отсутсвия стада евангелистов в твиттере.&lt;/p&gt;&lt;p&gt;Ещё пара ссылок для заинтересовавшихся:  &lt;a href='http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf'&gt;Scalable Component Abstractions&lt;/a&gt;  &lt;a href='https://pdfs.semanticscholar.org/84b1/d4f7c6d3e243508d153d7e8a10b3d7d33f2c.pdf'&gt;Objects + Views = Components?&lt;/a&gt;&lt;/p&gt;</description><pubDate>Sat, 22 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-12-07-makejavagreateagain/</guid><link>https://cheatex.cc/posts-output/2018-12-07-makejavagreateagain/</link><title>Make Java great again</title><description>&lt;h3 id="про&amp;#95;импорты"&gt;Про импорты&lt;/h3&gt;&lt;p&gt;Понял что одной из самых недостающих фич в яве являются алиасы в импортах. Крайне удобно и помогает в борьбе с многословностью. Нужен на всех уровнях, для пакетов, классов и методов. &lt;/p&gt;&lt;p&gt;Вместо&lt;/p&gt;&lt;pre&gt;&lt;code&gt;blah.blah.blah.views
∟EditView
∟ShareView
∟ProfileView
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;И обращений типа &lt;code&gt;myFrameworkRenderer.view&amp;#40;new ProfileView&amp;#40;&amp;#41;&amp;#41;&lt;/code&gt; везде.&lt;/p&gt;&lt;p&gt;Можно будет делать&lt;/p&gt;&lt;pre&gt;&lt;code&gt;blah.blah.blah.views
∟Edit
∟Share
∟Profile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В далёком-далёком коде писать &lt;code&gt;views.Profile.DATE&amp;#95;FORMAT&lt;/code&gt;, а гденить поближе &lt;code&gt;myFrameworkRenderer.view&amp;#40;new Profile&amp;#40;&amp;#41;&amp;#41;&lt;/code&gt;.&lt;/p&gt;&lt;h3 id="про&amp;#95;kwargs"&gt;Про kwargs&lt;/h3&gt;&lt;p&gt;Если еще чуть подумать то вторая довольно простая штука (с точки зрения накатать пост в телеге) которой не хватает - keyword arguments.&lt;/p&gt;&lt;p&gt;В основном со стороны вызова. Как ни крути бывают методы и с 4 и с 12 параметрами. Разбираться где что большая трата времени, тут редкий случай когда побольше слов пойдут на пользу.&lt;/p&gt;&lt;p&gt;Я вкурсе про идеевские хинты. Но они ломают форматирование и их нет в гитхабе. (Тут у меня возникло желание начать серию про перспективы структурных редакторов, но я мужественно держусь.)&lt;/p&gt;&lt;h3 id="про&amp;#95;культуру"&gt;Про культуру&lt;/h3&gt;&lt;p&gt;Реально основная проблема с программированием на яве - культура. Сегодня попал на глаза кусок старого кода. Много слов. Очень много слов. Когда я начинал работать все по привычке использовали отбивку 80 символов, потом 120, сейчас уже 150-180 норма. Только вот на 14'' код уже не прочитать. И это только ширина. И пофиксить то не проблема.&lt;/p&gt;&lt;p&gt;Названия больше 4х слов нахер. Ничего понять они не помогают. Читать новый код тяжело и травматично для самолюбия, deal with it. Придумывайте новые новые названия, используйте аналогии, вырабатывайте идиомы. Кто может без доки рассказать разницу между &lt;code&gt;StaticListableBeanFactory&lt;/code&gt; и &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; может бросить в меня камень. Использовать такие названия в письменно коммуникации боль в устной просто невозможно. Когда 5 классов делят 3-4 слова в префиксе или суффиксе никакой возможности завести для них отдельные места в голове нет, кодовая база сливается в невнятную жижу.&lt;/p&gt;&lt;p&gt;get/set нахер. Абсолютно бесполезная трата места на экране. Выдумана от безысходности С кодерами к которым пришли менеджеры и сказали что теперь надо программировать объектно-ориентировано. Никакой абстракции не даёт, вариантов реализации отличных от return/= просто нет. Пользовать &lt;code&gt;public final&lt;/code&gt; поля, если совсем приперает удалять &lt;code&gt;final&lt;/code&gt;. Я не имею в виду методы которые реально что-то ищут или создают, вроде любимого &lt;code&gt;getBean&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Ну это так, чисто площадку от мусора очистить. Хотя почти никто даже этого не делает.&lt;/p&gt;&lt;h3 id="ссылки"&gt;Ссылки&lt;/h3&gt;&lt;p&gt;&lt;a href='https://www.youtube.com/watch?v=ZsHMHukIlJY'&gt;Seven Ineffective Coding Habits of Many Programmers&lt;/a&gt; У чувака довольно дельные идеи по энтерпрайз стилю. Правда изложение крайне водянистое, эксперты советуют смотреть под сидр.&lt;/p&gt;</description><pubDate>Fri, 07 Dec 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-07-21-on-exceptions/</guid><link>https://cheatex.cc/posts-output/2018-07-21-on-exceptions/</link><title>Проблема с исключениями</title><description>&lt;p&gt;С исключениями есть одна большая проблема. В каждой команде которую мне довелось встречать было своё уникальное видение как их "правильно" применять.&lt;/p&gt;&lt;p&gt;Какие? Где кидать? Когда кидать? Где ловить? Все эти вопросы дают комбинаторный взрыв стилей и широкий простор для самовыражения. Каждый вариант ответа имеет свои фатальные недостатки, но их можно и проигнорировать для любимого набора. Носители альтернативного набора ответов обрекают всех окружающих на вечные муки и должны немедленно высылаться прямиком в ад. (Ну или в недельное кодревью хотя бы.)&lt;/p&gt;&lt;p&gt;Набор который мне нравится:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;В понятных ситуациях кидаем checked ловим как только можем с ними что-то сделать.&lt;/li&gt;&lt;li&gt;В непонятных делаем assert, в случае религиозно-операционных трудностей создаем AssertionError.&lt;/li&gt;&lt;li&gt;Сторонний код признающийся в выбросе исключений или замеченный за этим заворачивем.&lt;/li&gt;&lt;li&gt;Error ловим только на уровне точек входа, вроде запуска потоков или обработки сети.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Да, и у него тоже есть фатальные недостатки.&lt;/p&gt;&lt;p&gt;А еще я не разу встречал различных мнений по тому как использовать &lt;a href='https://www.scala-lang.org/api/2.9.3/scala/Either.html'&gt;Either&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Sat, 21 Jul 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2018-07-07-framework-evo/</guid><link>https://cheatex.cc/posts-output/2018-07-07-framework-evo/</link><title>Эволюция фреймворков</title><description>&lt;p&gt;Вначале была уютная джавочка с API для файлов-сокетов и интерфейсом в ODBC.&lt;/p&gt;&lt;p&gt;Потом решили что так программировать сложно и забахали пакет API для серверных приложений. Появилась куча аббревиатур которые до сих пор позволяют HRам писать вакансии не приходя в сознание.&lt;/p&gt;&lt;p&gt;Потом решили что собирать адаптеры и конвертеры между этими аббревиатурами руками сложно. Расцвела концепция inversion of control, появились контейнеры вроде спринга и guice.&lt;/p&gt;&lt;p&gt;Чтобы запуститься и на машине разраба и в тесте и собственно на сервере эти контейнерам требовалась куча конфигов. Расписывать их было не просто, "Правильно" запустить такую конструкцию получалось не у всякого. Пошли в дело оболочки для контейнеров вроде boot. На горизонте замаячил призрак совсем других контейнеров.&lt;/p&gt;&lt;p&gt;Успеть везде не возможно. И пока выкристаллизовывался верный способ завернуть перегонялку из таблички БД в JSON этих перегонялок для приличного приложения стало требоваться несколько сотен. И каждую надо "Правильно" оформить чтобы потраченные ранее усилия не пропали даром. Светлые умы быстренько подыскали выход: &lt;a href='https://www.jhipster.tech/presentation/#/'&gt;Java Hipster&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Хочется собрать всех этих инноваторов и провести с ними воспитательную беседу примерно такого формата: &lt;a href='https://www.youtube.com/watch?v=7n_1zsCVBxw&amp;t=7'&gt;https://www.youtube.com/watch?v=7n_1zsCVBxw&amp;t=7&lt;/a&gt; (Один из лучших гейм-артов, смотреть на самом большом экране что есть и сделать погромче)&lt;/p&gt;</description><pubDate>Sat, 07 Jul 2018 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2015-02-04-complexity-birth/</guid><link>https://cheatex.cc/posts-output/2015-02-04-complexity-birth/</link><title>Рождение сложности</title><description>&lt;p&gt; Решил немного отвлечься от технического образования и заняться научно-популярной литературой. Был приятно удивлён простотой и доступностью книги вышедшей в оригинале на русском да ещё и написанной человеком работающим в Москве. Работа всё ещё не попадает в разряд лёгкого чтива, требует определённой концентрации и запоминания терминологии, но тем не менее доступна без специальной подготовки и даже приятна для людей со склонностью к разбиранию сложных штук.&lt;/p&gt;&lt;p&gt;Книга посвящена современному состоянию эволюционной биологии, в особенности тому что известно о ранних этапах развития жизни. Попутно делается краткий экскурс в современное состояние генетики и молекулярной биологии, которые изрядно продвинулись со времён написания учебников по которым я учился. Много врезок кратко описывающих результаты отдельных исследований конца 2010х годов и их место среди остального материала. Как и положенно научной книге большинство упомянутых фактов сопровождаются ссылками на соответствующие работы.&lt;/p&gt;&lt;p&gt;Медленно и неспешно, начиная с самых простых организмов автор рассматривает как устроен и мог возникнуть соответствующий тип. Начало, конечно, получается довольно насыщенным гипотетическими формами жизни, но это, по мере приближения во времени к современности а по уровню организации к современным многоклеточным и их сообществам, проходит. Приводится множество фактов палеонтологии и недавних открытий реликтовых видов, про которые неспециалисты вряд ли слышали. Огромный массив информации представляется как логически связанная цепочка фактов.&lt;/p&gt;&lt;p&gt;Неожиданно подробно для книги с такой направленностью разбираются химические механизмы регуляции в живых организмах, современное состояние молекулярной биологии. Все даётся в описательном виде, без технических деталей, что может быть небольши минусом для людей не страдающих страхом перед химией. Где уместно полностью рассматриваются цепочки обратной связи от гена до влияния на внешнюю среду и обратно, приводится несколько "интуитивных" доказательств что даже самые простые обратные связи могут эволюционировать в сторону усложнения и адаптации. Вообще одна из позитивных идей вынесенных мной из книги - математические модели и формальные доказательства становятся всё более важной частью биологии.&lt;/p&gt;&lt;p&gt;В общем книга оставляет в голове достаточно яркую и развёрнутую картину современной биологии и её взгляда на историю жизни. Бонусом читатель знакомится с существенно более детальным описанием микроскопического устройства клетки и её механизмов регуляции чем остаётся от школьного курса биологии. В целом дочитывал книгу в состоянии легкого восторга и немедленно приобрёл ещё одни труд автора, ждите ещё обзоров.&lt;/p&gt;</description><pubDate>Wed, 04 Feb 2015 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-10-12-links-3/</guid><link>https://cheatex.cc/posts-output/2014-10-12-links-3/</link><title>Линкопост #3</title><description>&lt;p&gt;Понял что умных своих мыслей не было уже пару месяцев и не предвидится. Давайте хоть чужими поделюсь чтобы блог не умер.&lt;/p&gt;&lt;p&gt;Для начала про хаскель и теорию:&lt;/p&gt;&lt;p&gt;&lt;a href='http://siek.blogspot.be/2012/07/crash-course-on-notation-in-programming.html'&gt;Crash Course on Notation in Programming Language Theory&lt;/a&gt; - название говорит само за себя. Позволяет не пропускать разделы с формальной семантикой в современных статьях по теории ЯП. В принципе материал достаточно уникальный, я например больше нигде не видел описания этой нотации.&lt;/p&gt;&lt;p&gt;Также наткнулся на две статьи с нормальным описанием подхода к IO в Haskell. &lt;a href='http://blog.jle.im/entry/first-class-statements'&gt;First-Class “Statements”&lt;/a&gt; и &lt;a href='https://web.archive.org/web/20151121193133/http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/'&gt;I/O Is Pure&lt;/a&gt;. Они наглядно показывают как устроен ввод-вывод в ленивых языках. Что такое тип IO и каков смысл основных операций с ним в терминах "read data" и "apply to result" а не выдуманнных эффектов и действий. Как небольшой побочный результат дают возможность понять что монады, функторы и прочие интересности которыми забиты все тьюториалы и ответы на SO никакого отношения к сути IO не имеют.&lt;/p&gt;&lt;p&gt;Нашлось за полгода и много интересного и про развитие языков программирования.&lt;/p&gt;&lt;p&gt;Всплыла демо-сессия посвящённая дебаггеру в Elm, &lt;a href='https://www.youtube.com/watch?v=lK0vph1zR8s'&gt;Bret Victor style reactive debugging&lt;/a&gt;. Сейчас этот проект уже влит в основную ветку разработки и доступен как &lt;a href='http://elm-lang.org/blog/Introducing-Elm-Reactor.elm'&gt;reactor&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Chris Granger написал пару стоящих прочтения статей о том что он дальше собирается делать с IDE. Первая, &lt;a href='http://www.chris-granger.com/2014/03/27/toward-a-better-programming/'&gt;Toward a better programming&lt;/a&gt;, неплохо рассмотрено почему софт пишется медленно и заброшена пара идей что с этим можно сделать. Также было сделано объявление о старте &lt;a href='http://www.chris-granger.com/2014/10/01/beyond-light-table/'&gt;EVE&lt;/a&gt;, по делу там достаточно мало, но всё-таки читать интересно. Фактически признано что Light Table превратился в "ещё один редактор" с парой секси фич. Чтож светлая ему память, у EVE есть все шансы таки сдвинуть идею "среды разработки" с мёртвой точки.&lt;/p&gt;&lt;p&gt;Интересная декларация создания двухуровневого языка программирования. Я так понял чистое прожектёрство, по проекту год не было новостей, но идея выглядит неплохо &lt;a href='http://fendrich.se/blog/2013/09/03/big-programming/'&gt;Big Programming, Small Programming&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Небольшой флешбэк, &lt;a href='http://www.youtube.com/watch?v=yJDv-zdhzMY'&gt;The Mother of All Demos&lt;/a&gt;. Презентация руководителя ARC о результатах работы лаборатории 1968 года. Показывается ряд интерактивных систем и озвучиваются идеи их развития. Пользуясь случаем хочу передать пламенный привет всем свидетелям Джобса придумавшего ПК.&lt;/p&gt;&lt;p&gt;Отдельно стоит найденная мной серия лекция Хэмминга (того самого) &lt;a href='http://www.youtube.com/playlist?list=PL2FF649D0C4407B30'&gt;Learning to Learn&lt;/a&gt;. Название говорит само за себя, Хэмминг рассказывает о том как он учился сам и советует как учиться студентам. Особого внимания достойна завершающая лекция &lt;a href='http://www.youtube.com/watch?v=a1zDuOPkMSw'&gt;You and Your Research&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Ну и немного по управлению, статья в духе капитана, но так нереально трудно усваиваемая людьми работающими в менеджменте &lt;a href='http://eao197.blogspot.ru/2014/04/work_14.html'&gt;Банальность: главный ингредиент в разработке ПО &amp;ndash; это люди&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Sun, 12 Oct 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-08-11-bullet-journal/</guid><link>https://cheatex.cc/posts-output/2014-08-11-bullet-journal/</link><title>Опыт с Bullet Journal</title><description>&lt;p&gt;Какое-то время назад я увидел сам и немного порекламировал окружающим аналоговую систему ведения списка дел: &lt;a href='http://bulletjournal.com/'&gt;Bullet Journal&lt;/a&gt;. Суть кратко: автор предлагает типографскую нотацию легко воспроизводимую от руки для управления списками дел на бумаге без помощи компьютера.&lt;/p&gt;&lt;p&gt;Сама идея весьма удобна. Во-первых аналоговая запись существенно расширяет диапазон артефактов которые можно хранить, в программировании часто нет слов зато есть небольшая схемка. Во-вторых записи можно обрабатывать и дополнять оффлайн, в вагоне поезда, в палатке за городом, когда лежишь на диване и боишься случайно засветиться в скайпе.&lt;/p&gt;&lt;p&gt;Однако некоторые детали этой системы меня не устроили и в процессе использования прижился ряд поправок. Последняя версия не подвергалась изменениям уже месяца 3, так что я решил ей поделиться.&lt;/p&gt;&lt;p&gt;Крупнейшее изменение которое я внёс состоит в разделении журнала на две книги. Одну для "текучки" и одну для "вечного". Первую я веду в блокноте чуть меньше А5, туда идут собственно кратковременные задачи и малозначимые заметки по разным топикам. Вторую я веду в обычной школьной тетради. Туда идут долговременные планы, эскизы по разным проектам, важные мысли. Обе книги оформлены как оригинальный журнал: содержат нумерацию страниц и оглавление.&lt;/p&gt;&lt;p&gt;Второе важное отличие: удаление контента. Меня существенно раздражает наличие в поле зрения ненужных вещей, в частности топиков которые уже точно не актуальны. И если оригинальный журнал был append-only, то мои книги подразумевают удаление. В книге с текучкой я просто вычёркиваю элементы оглавления и вырываю соответствующие страницы когда топик становится полностью закрыт или не актуален. Из книги с вечным я только вычёркиваю названия топиков как в оглавлении так и на странице.&lt;/p&gt;&lt;p&gt;Небольшим изменением подвергся набор иконок. Значок "звезда" долго рисовать и редко получается если пишешь на коленях. Иконка priority была заменена на восклицательный знак, соответственно для inspiration я использю простую молнию. Теперь все значки рисуются в пару касаний и узнаваемы даже когда добавлены в вагоне метро.&lt;/p&gt;&lt;p&gt;Я полностью не отказался от цифрового хранения тудушек. Для трекинга живого и эволюционирующего проекта оно подходит лучше. Ну и хранить ссылки на бумаге немного не удобно. Для таких задач я использую Trello. Топики иногда перемещаются между журналом и облаком. Для сохранения разума были выработаны два правила. Первое: никакой топик не живёт одновременно в двух системах. Второе: никогда не осуществлять перенос сразу, я всегда ставлю специальную пометку в названии и осуществляю перенос только когда на неё натыкаюсь.&lt;/p&gt;&lt;p&gt;Система в общем оказалась весьма полезной и после небольшого тюнинга достаточно удобной. Иногда приходится выделять полчаса на обзор текущего состояния журнала и чистку перенос части содержимого, но случается это примерно раз в два месяца. При том что я регулярно оказываюсь поездах, автобусах и т.п. без особого желания читать но с желанием о чём-то подумать бумажный журнал оказывается весьма кстати. Основная проблема не забыть книги дома, но надёжного способа борьбы с ней пока не придумано.&lt;/p&gt;</description><pubDate>Mon, 11 Aug 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-08-04-cg-books/</guid><link>https://cheatex.cc/posts-output/2014-08-04-cg-books/</link><title>"Mathematics for Computer Graphics" и "Computational Geometry: Algorithms and Applications"</title><description>&lt;p&gt; Последние полгода очень сильно ленился в плане чтения и справился всего с двумя книжками.&lt;/p&gt;&lt;p&gt;Первая &lt;a href='http://www.amazon.com/Mathematics-Computer-Graphics-Undergraduate-Science/dp/1849960224'&gt;Mathematics for Computer Graphics&lt;/a&gt; - краткое ревью математики полезной для программирования графики. Книга в принципе неплоха как напоминание и как компактная коллекция полезных математических инструментов. В качестве книги для начального изучения чего либо она к сожалению не очень хороша по нескольким причинам.&lt;/p&gt;&lt;p&gt;Во-первых книге катастрофически не достаёт иллюстративного материала, что фатально сказывается на скорости начального восприятия. Ко многим выкладкам и доказательствам приходится рисовать картинки самостоятельно, что исключает чтение книги в транспорте или на отдыхе.&lt;/p&gt;&lt;p&gt;Вторая проблема: разная глубина изложения в разных разделах. Какие-то направления представлены подборкой основных формул и их интерпретацией. Где-то есть пара примеров их применения, где-то вдруг приводятся доказательства. При сквозном чтении очень тяжело зацепиться за какой-то ритм и следовать ему.&lt;/p&gt;&lt;p&gt;В общем книга приемлема для полки в качестве справочника и не может использоваться для начального ознакомления с мат. аппаратом.&lt;/p&gt;&lt;p&gt;Вторая, &lt;a href='http://www.amazon.com/Computational-Geometry-Applications-Mark-Berg/dp/3540779736'&gt;Computational Geometry: Algorithms and Applications&lt;/a&gt;. Книга как раз противоположна предыдущей - она очень удачна в качестве учебника. Начинает с простого, продолжает непростым, заканчивает комбинацией ранее изложенного. Очень приятной деталью является отличное покрытие иллюстрациями. Все логические построения и алгоритмы сопровождаются удачными рисунками - мне практически не приходилось брать карандаш и бумагу в руки.&lt;/p&gt;&lt;p&gt;Рассматривается около полутора десятков проблем вычислительной геометрии. Каждая атакуется плавно. Нет хороших решений из коробки, всегда показывается эволюция алгоритма от простых идей и игнорирования предельных случаев до доказуемо корректного решения. Авторы часто приводят не лучший алгоритм предпочитая детально описать более простой и понятный.&lt;/p&gt;&lt;p&gt;Чтение не требует знаний выходящих за первый семестр курса алгоритмов. Используются самые базовые вещи: деревья, кучи, списки. Анализ алгоритмов предполагает только знакомство с нотацией асимптот и умение решать "recurrences".&lt;/p&gt;&lt;p&gt;Все главы сопровождаются небольшим ревью вопроса. Там даётся история изучения проблемы и наиболее сильные современные результаты. Часто есть обзор смежных областей, приложений и т.п. Список ссылок огромный.&lt;/p&gt;&lt;p&gt;Книга даёт приятный уровень нагрузки на мозг, каждая задача требует 10-15 сконцентрированных размышлений сверх времени на прочтение. Можно рекомендовать и как учебник если вдруг пришлось столкнуться с геометрическими проблемами так и для развивающего чтения. В целом книга мне исключительно понравилась.&lt;/p&gt;</description><pubDate>Mon, 04 Aug 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-06-19-whats-wrong-with-haskell/</guid><link>https://cheatex.cc/posts-output/2014-06-19-whats-wrong-with-haskell/</link><title>Что не так с Хаскелем</title><description>&lt;p&gt;Недавно тут &lt;a href='http://eax.me/eaxcast-s02e02/'&gt;вспомнилась&lt;/a&gt; забавная статья &lt;a href='http://habrahabr.ru/post/163283/'&gt;"Почему язык Haskell так непопулярен"&lt;/a&gt; &lt;a href='https://savepearlharbor.com/?p=163283'&gt;alt&lt;/a&gt; от одного из вождей соответствующего сообщества. Понял что со времён её публикации мой ответ на заголовок изменился с абстрактного "нихрена не понял" на список из нескольких достаточно конкретных проблем. Их я и попробую тут расписать.&lt;/p&gt;&lt;p&gt;Во-первых нет учебников и справочников по алгоритмам/структурам данных. Большая часть алгоритмов описана в расчёте на дешёвое присваивание и строгие вычисления. Найти описание и анализ нетривиального алгоритма для хаскельных реалий практически не возможно. У того же Окасаки, как я понимаю, половина книги - разработка аппарата для того чтобы только научиться иметь с этим дело.&lt;/p&gt;&lt;p&gt;К предыдущей плотно примыкает проблема номер два. Ленивые вычисления - это фактически полная передача компилятору баланса между потреблением памяти и процессора. Иногда он сдвигает его в совершенно неожиданное место и программа вдруг начинает требовать феерические объёмы ресурсов. Что с этим делать непонятно, гайды которые мне удавалось находить написаны для разрабов этого самого компилятора. В них в принципе нет введений, даже нет ссылок, предполагается что огромная масса знаний о реализации вычислительной модели уже в голове. Что делать человеку который прочитал LYHGG, написал первый алгоритм и получил время выполнение или потребление памяти в районе лунной орбиты непонятно.&lt;/p&gt;&lt;p&gt;Лирическое отступление. Пару лет назад я проходил на курсере курс по алгоритмам. Начать попробовал на хаскеле. Первым заданием было посчитать inversions, то есть нарушения порядка в массиве. Решение я написал сравнительно быстро, мин 40. Проблемы начались при запуске - программа пожирала всю доступную память. Несколько ритуальных плясок в обходе списка позволили программе вмещаться в пару гигабайт памяти и 20 минут. И да, выдавать &lt;a href='https://twitter.com/puffnfresh'&gt;корректный&lt;/a&gt; ответ для пары тысяч чисел в первой версии, спустя полтора часа...&lt;/p&gt;&lt;p&gt;Обзор тематических ресурсов подходы к решению проблемы найти не позволил. Консультация с коллегой-фаном хаскеля, который кстати тоже получил что-то не вменяемое в первой версии программы, и перестановка чего-то там в паре выражений (перед глазами встал призрак 2003 студии где перестановка инклудов иногда чинила access violation)  позволили сократить время до нескольких минут. Для интереса сделал тоже на питоне за 10 мин, 20 или 30 секунд выполнения и символическое потребление памяти. Искать с помощью Хаскеля минимальный разрез графа из нескольких тысяч узлов я уже не рискнул.&lt;/p&gt;&lt;p&gt;Ну и главное: нет примеров полномасштабных приложений. Какая нибудь обработка исключений от трёх функций с помощью стрелок находится легко. Исходник простого веб-сервера, без расширений языка, без 90% закопанного в библиотеки найти сложно. Хотелось бы увидеть простой аналог рисовалки или текстового редактора. Что угодно что демонстрирует в рамках 3-4 экранов дизайн полноценного приложения которое читает, пишет, показывает что-то пользователю, реагирует на ошибки и нарушения форматов. Таких примеров нет, невозможно оценить какой массив знаний необходим для создания полноценного приложения. Теркат? Трансформеры? Дисер Окасаки? Свободная навигация по исходникам компилятора? Я за три года так и не понял.&lt;/p&gt;&lt;p&gt;Ещё для меня серьёзной проблемой является типографический кретинизм большинства авторов. Он проявляется в нескольких аспектах. Во-первых для функции нормально &lt;a href='http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators'&gt;не иметь человеческого имени&lt;/a&gt;. Пишем &lt;*&gt;, в уме проговариваем "треугольная жопа", как описать код коллеге не понятно. Во-вторых статьи абсолютно всех уровней, от ICFP до очередного тьюториала по монадам в блоге программиста Васи наполнены типографскими аналогами собственно операторов языка, то есть вместо -&gt; везде →. Какая-нибудь тау с нижним и верхним индексом - тоже святое дело. Вообще обучение на примере кода который не запускается - норма для данного сообщества. В том же LYHGG процентов 30 не работало ещё три года назад когда я его читал.&lt;/p&gt;&lt;p&gt;Ну и сообщество. Я там выше давал ссылочку на любителя корректных программ, подпишитесь - понаблюдайте недельку. Подумайте что делать если к такому существу придётся обращаться за поддержкой или оно окажется у вас в команде. Справедливости ради надо заметить что те кто собственно что-то делает, разработчики самого компилятора и популярных билиотек более вменяемы и не лишены кругозора.&lt;/p&gt;&lt;p&gt;Чуть не забыл, данная заметка не претендует на полный охват предмета. Haskell имеет некоторое (конечное) количество положительных черт, но я тут про них умолчал. Жаждущие серебряных пуль могут найти их в интернете во множестве.&lt;/p&gt;&lt;p&gt;UPD: Буду сюда докидывать пруфы&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://www.haskell.org/pipermail/haskell-cafe/2014-June/114724.html'&gt;Need help - my haskell code is over 50 times slower than equivalent perl implementation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://codeflow.wordpress.com/2011/02/20/the-reasons-i-dont-write-all-my-code-in-haskell/'&gt;The reasons I don’t write all my code in Haskell&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2a310v/where_is_haskell_going_in_industry/'&gt;Where is Haskell going in industry?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2aerm7/whats_the_performance_bottleneck_in_this_prime/'&gt;What's the performance bottleneck in this prime sieve function?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2ain3c/beginner_parse_error_on_input/'&gt;Beginner - Parse Error on Input '='&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2al3vx/how_do_you_avoid_the_cabal_hell/'&gt;How do you avoid the Cabal Hell™?&lt;/a&gt; (третий пункт прекрасен, изящный функциональный дизайн типа)&lt;/li&gt;&lt;li&gt;&lt;a href='http://ru.reddit.com/r/haskell/comments/2ali12/complete_roadmap_from_total_novice_to_haskell/'&gt;Complete roadmap from total novice to Haskell mastery?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.reddit.com/r/haskell/comments/2fxjcg/how_do_you_structure_a_program_to_support_logging/'&gt;How do you structure a program to support logging?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.reddit.com/r/haskell/comments/2n0991/how_lazy_evaluation_works/cm9qx7v'&gt;Why is foldl bad?&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Thu, 19 Jun 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-05-26-untypical-ides/</guid><link>https://cheatex.cc/posts-output/2014-05-26-untypical-ides/</link><title>Нетипичные IDE</title><description>&lt;p&gt; Не так давно я написал довольно обстоятельный пост про проблемы современных IDE. В частности подробно отписался почему они могут нанести существенный ущерб проекту без должной осторожности и почему заметной пользы они не приносят. Что характерно пост получился самым популярным за историю блога и много народу не поленилось даже отстоять любимый инструмент в твиттере.&lt;/p&gt;&lt;p&gt;Пришло время перейти к конструктиву и немного посмотреть как их можно делать среды которые что-то меняют в процессе разработки. Есть изрядное количество инструментов которые пытаются продвинуться за пределы 95го года и существенно изменить способ взаимодействия программиста и разрабатываемой им программы.&lt;/p&gt;&lt;p&gt;Вот например &lt;a href='http://www.squeak.org/'&gt;Squeake&lt;/a&gt;, первый релиз 96 год. (Небось думали я с потолка год в прошлом посте взял? Правильно думали на самом деле, да и большинство обсуждаемых далее фич были в &lt;a href='http://weather-dimensions.com/tedkaehler/us/ted/resume/st80release-lic2.jpg'&gt;Smalltalk-80&lt;/a&gt;). Я наверно повторяю очень известную вещь, но всё таки: основной чертой Smalltalk является существование live image. В нём нет статического кода и времени исполнения, всё что делает программист порождает объекты в одном образе, этот образ несёт в себе и код и живые объекты на одинаковых правах. Образ содержит и ядро языка, и разрабатываемое приложение, и среду разработки одновременно, при поставке пользователю ненужные классы удаляются.&lt;/p&gt;&lt;p&gt;Подход этот конечно спорный, но он имеет несколько явно положительных результатов. Например при разработке графики можно весьма просто с ней управляться. Например имея нарисованную как-то картинку можно немного её покрутить, примерить к другой картинке, продублировать. &lt;a href='http://www.youtube.com/watch?v=oH-Jj_1v8BM#t=78'&gt;Как-то так&lt;/a&gt; или &lt;a href='https://www.hpi.uni-potsdam.de/hirschfeld/trac/SqueakCommunityProjects/raw-attachment/wiki/squeak_screencasts/Image-Halos.m4v'&gt;так&lt;/a&gt; (вторая ссылка покороче, но требует скачивания видяшки). А после соответствующего благоустройства среда позволяет &lt;a href='http://www.youtube.com/watch?v=34cWCnLC5nM'&gt;что-то программировать&lt;/a&gt; даже детям. Ну и вообще она полна простых приятностей, вот например Object inspector.&lt;/p&gt;&lt;p&gt;&lt;img src="/img/Exploring-ObjectExplorerInspector-2.jpg" alt="Object inspector" /&gt;&lt;/p&gt;&lt;p&gt;"Чего же тут такого интересного?" - многие спросят. Вроде и ничего, но вот 2014 год на дворе а все популярные среды разработки по-прежнему считают что цвет нормально показывать как десятизначное число.&lt;/p&gt;&lt;p&gt;Второй интересной наработкой Smalltalk является &lt;a href='http://wiki.squeak.org/squeak/1916'&gt;method finder&lt;/a&gt;. Первая его фича - поиск по ключевым словам более менее освоена современными IDE. А вот вторая, поиск по примеру и сейчас, спустя примерно 30 лет после создания насколько я знаю ни кем не повторена. Если кратко она позволяет ввести пример результата метода при заданных аргументах и получить список методов которые этому примеру удовлетворяют. Например на запрос ' trim my spaces '. 'trim my spaces' он ответит #withBlanksTrimmed.&lt;/p&gt;&lt;p&gt;Ладно, хватит истории, вот пара проектов которые прямо сейчас в разработке. Первый, собравший 300k$ на кикстартере, &lt;a href='http://www.lighttable.com/'&gt;Light table&lt;/a&gt;. Это IDE которая должна решить несколько известных проблем и серьёзно пересмотреть постановку других. На данный момент она нацелена на поддержку Clojure, JavaScript и Python. Среди наиболее интересных фичей:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Абстрагирование от файлов проекта, редактор показывает и даёт редактировать функции динамически компонуя их по мере просмотра и редактирования исходников.&lt;/li&gt;&lt;li&gt;Автоматический показ документации и/или исходников связанных функций.&lt;/li&gt;&lt;li&gt;Интерактивная отладка, как через горячую подмену кода так и через 'watches' которые позволяют записывать и отображать состояние программы в отдельных точках.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Текущие релизы правда пока сконцентрированы на разработке тюнингуемого редактора. Но разрабы &lt;a href='https://groups.google.com/d/topic/light-table-discussion/1Hyeia7TXag/discussion'&gt;полны решимости&lt;/a&gt; довести первоначальную идею до конца, вплоть до запила своего языка с блэкджеком и монадами.&lt;/p&gt;&lt;p&gt;Проект &lt;a href='http://peaker.github.io/lamdu/'&gt;Lamdu&lt;/a&gt; параллельно развивает язык и среду разработки для него. Язык построен на основе Haskell с изменениями направленными на большую явность конструкций и адаптацию для визуального представления структуры программ. В частности он вводит обязательные имена параметров для функций и явно отображает типы в лямбда-выражениях.&lt;/p&gt;&lt;p&gt;Среда построена вокруг структурированного представления и редактирования кода с выделением различных элементов шрифтом и цветом.  Редактор позволяет вводить код только в предназначенные для этого слоты, контролирует после ввода тип, предполагаются умные автодополнения. Ошибки типизации получаются хорошо локализованы (не могу не заметить что оригинальный хаскель тут от C++ ушёл совсем не далеко, точность ошибки компенсируется неопределённостью её местоположения).&lt;/p&gt;&lt;p&gt;Редактор автоматически применяет визуальную свёртку сложных языковых конструкций (вроде лямбд и аннотаций параметров как на картинке). Среди целей проекта предоставление билиотекам возможности настраивать отображение для своих структур данных и функций.&lt;/p&gt;&lt;p&gt;&lt;img src="/img/lamdu.png" alt="Lamdu" /&gt;&lt;/p&gt;&lt;p&gt;Также предполагается поддержка "regression debugging", то есть автоматический контроль хода выполнения теста и поиск изменения которое сломало тест. Примерно можно сказать что IDE будет запоминать все промежуточные результаты вычисления функций и сравнивать их для каждой версии. Хотя в контексте ленивости языка всё явно будет хитрее.&lt;/p&gt;&lt;p&gt;Помимо попыток привнести глобальные улучшения в IDE есть несколько инструментов реализующие какие-то конкретные компоненты гораздо лучше, чем принято в мэйнстриме.&lt;/p&gt;&lt;p&gt;Вот например &lt;a href='http://2013.cppnow.org/session/the-projucer-live-coding-with-c-and-the-llvm-jit-engine/'&gt;Projucer&lt;/a&gt;, инструмент визуальный разработки для &lt;a href='http://www.juce.com/'&gt;Juce&lt;/a&gt;. Ничего сверхъестественного, просто быстрая связь кода и картинки, но всё-таки поживее многочисленных SWING-дизайнеров, а пишется одним человеком.&lt;/p&gt;&lt;p&gt;Ещё один проект, коммерческий, &lt;a href='http://chrononsystems.com/what-is-chronon'&gt;Chronon&lt;/a&gt;. Включает в себя "Time Traveling Debugger". Это забавный инструмент который работает с полной записью исполнения программы. Записи получаются с помощью чёрной магии и второго компонента Chronon'а - "Recording Server". Нам же тут интересен дебаггер.&lt;/p&gt;&lt;p&gt;Его центральной фичей является возможность идти не только вперёд но и назад. Найдя ошибку можно вместо того чтобы расставлять бряки в подозрительных местах и перезапускать программу просто пойти назад и посмотреть "откуда пошло". Есть множество приятностей, вроде подсветки активных путей исполнения, истории состояний для переменных и вызовов методов. Много различных фильтров для поиска нужных значений в истории. Для примера можно посмотреть &lt;a href='http://www.youtube.com/watch?v=X80EdpI9z1Y'&gt;вот это видео&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Последний пример с совсем неожиданного направления, из мира железячных корпораций и кровавого геймдева. PhysX debugger - инструмент для физического движка от nVidia. Он создан для отладки поведения физической модели в сложных сценах. И демонстрирует очень высокий уровень использования различных визуализаций. Если вам интересно визуальное программирование я рекомендую потратить 15 мин и посмотреть обзорный ролик целиком: &lt;a href='https://www.youtube.com/watch?feature=player_embedded&amp;v=aKsY-U4kUBA'&gt;PVD tutorial video&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;В этом инструменте есть множество примеров визуализации разных аспектов динамических сцен и процесса их вычисления, вот &lt;a href='https://www.youtube.com/watch?feature=player_embedded&amp;v=aKsY-U4kUBA#t=434'&gt;интересный кусочек&lt;/a&gt; для ленивых (смотреть минуты три). Есть функции бэктрекинга, когда есть бажный объект, есть момент времени когда с ним что-то не так и надо найти откуда проблема появилась. Предусмотрены инструменты для командной работы, можно аннотировать дебаг-сессию оставляя каменты к объектам в определённые моменты времени. Сессия экспортируется и может быть передана коллеге для дальнейшего разбора проблемы. Действительно развитый инструмент для решения весьма нетривиальных задач.&lt;/p&gt;&lt;p&gt;Напоследок уже в который раз не могу не дать ссылку на сайт Bret Victor'а, которого авторы большинства описанных выше проектов называют в числе основных источников идей: &lt;a href='http://worrydream.com/'&gt;worrydream.com&lt;/a&gt;. Если Вы ещё не изучили все его материалы стоит немедленно начать.&lt;/p&gt;</description><pubDate>Mon, 26 May 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-04-08-racket-env/</guid><link>https://cheatex.cc/posts-output/2014-04-08-racket-env/</link><title>Альтернативная среда для Racket</title><description>&lt;p&gt;Это последний отчёт о моих опытах с Racket и посвящён он сугубо техническому вопросу, а именно среде разработки. По умолчанию новоиспечённому Racket-разработчику предлагается минимальная среда разработки. Она умеет открывать файлы с исходниками, подсвечивать синтаксис, загружать их в простой (ну очень простой) REPL и запускать под отладкой.&lt;/p&gt;&lt;p&gt;В принципе это не так и мало, но хотелось большего. А именно:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Полноценного REPL который бы помнил историю команд и умел подгружать изменения без полного перезапуска.&lt;/li&gt;&lt;li&gt;Быстрой навигации по именам функций и структур.&lt;/li&gt;&lt;li&gt;Богатого функционалом текстового редактора, в частности мультивыделения и быстрого поиска.&lt;/li&gt;&lt;li&gt;Поддержки проектов, по крайней мере коллекций файлов по которым можно искать.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;REPL достаточно быстро нашёлся, &lt;a href='http://docs.racket-lang.org/xrepl/'&gt;xrepl&lt;/a&gt;. Он прекрасно помнит историю, умеет (пере)загружать файлы, заходить в них чтобы тестировать не экспортированные функции и органично встраивается в shell. Инструкция по установке на сайте хорошо работает, для полного счастья только пришлось добавить в bash_aliases следующую строчку: &lt;code&gt;xracket=&amp;quot;racket -il xrepl&amp;quot;&lt;/code&gt;. Она запускает Racket в интерактивном режиме и загружает модуль xrepl. Модуль написан таким образом что сам применяет все необходимые хаки для создания полноценной оболочки.&lt;/p&gt;&lt;p&gt;Однако не сразу всё идеально заработало. Файлы с константами было невозможно перезагружать ,rr - Racket выдавал ошибку переопределения имён. Небольшое исследование вопроса показало что это связано с включенными по умолчанию оптимизациями и легко может быть исправлено одной командой, алиас принял вид &lt;code&gt;xracket=&amp;quot;racket -il xrepl --eval '&amp;#40;compile-enforce-module-constants #f&amp;#41;'&amp;quot;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Остальные 3 функции поставляет Sublime оставалось только подружить его немного с ЛИСПом, благо я не первый кто этим озадачился. Установка пары плагинов налаживает между крепкую дружбу между Racket и Sublime. Для упрощения жизни я использовал &lt;a href='https://sublime.wbond.net/installation#st2'&gt;Package Control&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Первый и самый насущный - конечно отступы :) &lt;a href='https://sublime.wbond.net/packages/lispindent'&gt;lispindent&lt;/a&gt; - отлично справляется с этой задачей и даже не пугается квадратных скобок.&lt;/p&gt;&lt;p&gt;Второй - &lt;a href='https://github.com/follesoe/sublime-racket'&gt;подсветка синтаксиса&lt;/a&gt;. В принципе она уже была, однако некоторые конструкции понимала не корректно. В частности совершенно убивали подсветку литералы #something а также функции и структуры не появлялись в списке символов. За пару дней поправил всё это и даже заслал патч в основную ветку проекта.&lt;/p&gt;&lt;p&gt;Ну и последняя доводка из области эстетства - красивая подсветка скобок и быстрый переход между ними. Делается плагином Bracket Highlighter. Очень удобно показывает границы блока слева, рядом с номерами строк а также позволяет включить "усиленную подсветку" - дополнительно подсветить весь текст принадлежащий выделенному блоку. Плюшки вроде удалить блок или перейти во внешний также присутствуют.&lt;/p&gt;&lt;p&gt;Для того чтобы всё это дружило потребовалось буквально пара настроек.&lt;/p&gt;&lt;p&gt;Во-первых надо включить lispindent для соответствующего языка следующей настройкой в &lt;code&gt;lispindent.sublime-settings&lt;/code&gt; (если используется Package Control то его можно открыть через меню Preferences-&gt;Package settings).&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;languages&amp;quot;: {
    &amp;quot;racket&amp;quot;: {
      &amp;quot;syntax&amp;quot;: &amp;quot;Racket.tmLanguage&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В настройках Bracket Highlighter, которые &lt;code&gt;bh&amp;#95;core.sublime-settings&lt;/code&gt; (также легко открываются через меню Preferences-&gt;Package settings) надо только найти и настроить под себя параметр &lt;code&gt;high&amp;#95;visibility&amp;#95;style&lt;/code&gt;, мне понравился &lt;code&gt;underline&lt;/code&gt;. Также удобно повесить переключение этого режима на хоткей, для этого в &lt;code&gt;Default.sublime-keymap&lt;/code&gt; надо дописать&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;keys&amp;quot;: &amp;#91;&amp;quot;ctrl+\\&amp;quot;&amp;#93;,
  &amp;quot;command&amp;quot;: &amp;quot;bh&amp;#95;toggle&amp;#95;high&amp;#95;visibility&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ну и проверить что файлы &lt;code&gt;.rkt&lt;/code&gt; открываются как Racket по умолчанию.&lt;/p&gt;&lt;p&gt;В принципе это всё. Я первый раз что-то глубоко копал в настройку Sublime и результат мне очень понравился. Всё, вплоть до написания своего плагина, решается достаточно легко и работает вполне безглючно.&lt;/p&gt;</description><pubDate>Tue, 08 Apr 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-03-26-evil-ide/</guid><link>https://cheatex.cc/posts-output/2014-03-26-evil-ide/</link><title>IDE как зло</title><description>&lt;p&gt; Уже очень давно начиная новый проект с запуска IDE и создания проекта в ней я чувствую смутное беспокойство. Лёгкий страх, что я принимаю решение которое не смогу пересмотреть, что проект получает пробную дозу и не сможет жить без новых.&lt;/p&gt;&lt;p&gt;Этот пост скорее дамп мыслей чем законченная идея. Однако мысли эти посещают меня довольно давно и мне кажется неплохой идей их зафиксировать. Мыслей этих примерно 4:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Общая польза от IDE крайне переоценена&lt;/li&gt;&lt;li&gt;Вред от них практически никогда осознанно не рассматривается&lt;/li&gt;&lt;li&gt;Во многих [коммерческих] проектах есть крайне не здоровая зависимость от них&lt;/li&gt;&lt;li&gt;Производящие их компании и сообщества уже много лет ничего реально не улучшали&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Польза переоценена очень сильно. Очень многие буквально считаю что без них нельзя работать. Другие думаю что IDE ускоряет разработку в разы. Основными функциями которые считаются незаменимыми являются поиск, навигация, рефакторинг и, иногда, дебагер. Как мне кажется потребность в этих функциях во многом создана самими IDE.&lt;/p&gt;&lt;p&gt;Давайте посмотрим по внимательнее например на навигацию. Думаете выжила бы джава сама по себе со своей безумной связью путей к исходникам и имён пакетов? Да ещё с необходимостью дублировать эту информацию в начале файла? Отсутствием относительных импортов? Только благодаря массовому использованию IDE этот ужас был хоть как-то жизнеспособен и во многом из за него на джаве трудно писать не имея громоздкой оболочки вокруг редактора, которая генерирует и сама же прячет бессмысленные строки.&lt;/p&gt;&lt;p&gt;Рефакторинг? Да то же самое, весь мой рефакторинг в питоне укладывается в grep и Ctrl+R. Просто нет дублирования информации о модулях и сама питонья культура не приветствует создание пакетов "просто так".&lt;/p&gt;&lt;p&gt;Отладка не менее переоценена. Да иногда полезно остановить программу и посмотреть что там как внутри. Но почти всегда ключ лежит в истории. И важно посмотреть историю создания или изменения какой-то структуры, а не текущий снимок и по вспоминать что ты видел 50 шагов назад. И помогает тут не остановка и прокликивание деревьев из объектов и ссылок а возможность легко оставить запись в логе из любого места программы и продуманное, настраиваемое представление объектов в этом логе.&lt;/p&gt;&lt;p&gt;Реальная польза от IDE - перетаскивание неудачных решений в дизайне языков и библиотек из области "фатальный бред" в область "можно терпеть". Не более. Бывает ли такое решение проблем необходимо? Конечно бывает. Но надо ли им пользоваться по умолчанию?&lt;/p&gt;&lt;p&gt;Печальна также и ситуация с оценкой проблем создаваемых IDE. Их наблюдается немало, но вспоминать про них - табу. Про то как джавовские null'ы несут зло и хаос написаны многие сотни страниц текстов, про то что IDEA последние 6 лет стабильно фризит на более-менее больших проектах почти никто не вспоминает.Или вернёмся опять к рефакторингу. Несмотря на то что идея изменения структуры кода без изменения его семантики в общем то здравая, тут тоже важна мера. Один из негативных эффектов наличия IDE в наборе инструментов - это откровенный спам рефакторингами. Не нравится имя? Две кнопки, вбить новое и готово! Захотелось перепилить структуру пакетов? Берём мышку, драг, дроп, кровь-кишки-мозги по стенам.&lt;/p&gt;&lt;p&gt;Это конечно хорошо точно подбирать имена под семантику если ты один, но если над проектом работает человек 5 надо немного аккуратнее делать такие вещи. К старому имени уже могло привыкнуть какое-то количество людей, отлаживая очередную ошибку они могут захотеть его найти и потерять много времени. Умные инструменты рефакторинга делают крупные изменения кода неоправданно лёгкими, опасно лёгкими.&lt;/p&gt;&lt;p&gt;Самая очевидная проблема - IDE скрывают реальное положение вещей в коде. Бессистемное именование, иерархии классов в 8 уровней, пинг-понг из вызовов перегрузок и super - всё это успешно маскируется навороченным Hierachy view. Проблема в том что инструменты могут что-то сделать с механической частью проблемы - найти все перегрузки, вызовы, ветвления. Но они бессильны с интеллектуальной частью - программисту всё так же надо разбираться в таких путаных структурах.&lt;/p&gt;&lt;p&gt;В коммерческой разработке на Java и C# сейчас наблюдается крайне болезненный культ IDE. Примерно треть половина что я видел не собиралась иначе чем экспортом из конкретной среды, примерно треть могла нормально разрабатываться в одной единственной среде из-за code style или кодогенерации или того что единственное описание зависимости между модулями - проект в проприетарном формате созданный 5 лет назад.&lt;/p&gt;&lt;p&gt;Самое печальное что при выборе между нормальным инструментом не поддерживаемым средой и костыльной конструкции с типа интеграцией - приоритет при остаётся за последней. Мой любимый пример - Git. Основная особенность этой VCS в том что она не устанавливает никаких связей между ветками и репозиториями. Ветки вашего личного репозитория могут быть связаны с произвольными ветками одного или нескольких удалённых. Эти связи должны определяться гайдлайнами в конкретном проекте, автоматизироваться созданием соответствующих скриптов и алиасов и, в особых случаях, контролироваться хуками. Git - принципиально требует настройки и расширения, без этих шагов он не очень удобен и прямо скажем создаёт проблемы.&lt;/p&gt;&lt;p&gt;Проблема в том что разработчики Git плагинов для IDEшек с которыми я работал либо просто не в курсе этой особенности, либо менеджеры соответствующей квалификации пояснили им что разноцветный дифф важнее для хомяков чем какая-то там расширяемость. Как следствие нельзя настраивать и даже использовать уже настроенные алиасы и нельзя удобно призывать на выполнение внешние скрипты. Зато есть кнопки Update и Commit&amp;Push... Ну можете представить как выглядит история когда проект резко переезжает с SVN, никто не пользуется гуглом а среда представляет такой easy по самое не могу функционал.&lt;/p&gt;&lt;p&gt;Ну и наконец о развитии - для сред разработки оно остановилось где-то в 90. IDEA 12 отличается от от JBuilder 2003 практически только разнообразными окошками навигаторов, а он в свою очередь от Turbo Pasсal 6 в основном наличием индекса символов и файлов. И все вместе они на фоне Squeak, скажем так, не выглядят достижениями трёх пятилеток.&lt;/p&gt;&lt;p&gt;Не хватает реальной интеграции компонентов. Например, как дебагер задействует редактор? Красная полоска в месте останова и попап со значением переменной. И то если программер позаботился о правильном toString, а если нет - пожалуйста прокликивайте дерево объектов. Это в две тысячи четырнадцатом году предел юзабилити и визуализации типа? Я LabView году так в 04-05 поюзабельнее дебагер рисовал.&lt;/p&gt;&lt;p&gt;И кстати о рисовании. В 2014 опять же году, когда всё прогрессивное человечество хреначит колбэки на жаваскрипте встраивает DSL в любой инструмент сложнее cat, для расширения любой IDE мне надо создать модуль(!) плагина, скомпилировать(!) его, положить в нужную папочку а то и прокликать пару форм и перезапустить(!) софтину. Future of programming, чо. Самый доступный способ расширения что предлагается - разлапистая форма настройки брекпоинта с condition и log message (в студии то небось до сих пор и того нет?).&lt;/p&gt;&lt;p&gt;Почему кроме строк в редакторе не подсветить методы и классы в навигаторах и аутлайне файла? Почему бы кроме плоского текстового лога не добавить к дебагеру какой-нибудь таймлайн и дерево вызовов где можно отставлять пометки? Почему бы не составлять небольшую карту задействованных виртуальных вызовов и их реализаций? Наконец почему не позволить программистам расширять и настраивать это всё по мере необходимости, скриптами и небольшими вставками кода?&lt;/p&gt;&lt;p&gt;Потому что так не делали в 1995 году? Я не вижу других причин.&lt;/p&gt;</description><pubDate>Wed, 26 Mar 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-03-17-land-of-lisp/</guid><link>https://cheatex.cc/posts-output/2014-03-17-land-of-lisp/</link><title>Land of Lisp</title><description>&lt;p&gt;Дочитал сабж. Как можно догадаться книга посвящена языку LISP и выстроена очень своеобразным образом. Основная идея: обучить языку через написание игр. Этот, на первый взгляд направленный на детей, подход в моём случае имел изрядный успех.&lt;/p&gt;&lt;p&gt;Писать игры по ходу книги отличная идея по нескольким причинам. Во-первых это заставляет автора начинать с практически важных, базовых элементов языка. С того с чем в будущем придётся сталкиваться чаще всего, а не с того что педагогически "правильнее". Во-вторых иллюстрации получаются заметно увлекательнее. Ну и наконец игры по своей природе открыты для хакинга, придумать дополнение к числам Фибоначчи гораздо сложнее чем к игре "угадай число".&lt;/p&gt;&lt;p&gt;Скажу честно не все примеры я аккуратно реализовывал и запускал, но примерно 60% задач из книги я выполнил. Что-то расширил, где-то поменял структуру кода - подход с созданием игр в книге даёт читателю очень высокий уровень вовлечённости и это прекрасно.&lt;/p&gt;&lt;p&gt;По содержанию... Книжка раскрывает все основные вопросы программирования: встроенные и пользовательские типы данных, основные конструкции языка, способы их расширения, ввод-вывод. Последовательность практических примеров как мне кажется совершенно логична, хотя порядок в котором вводятся языковые средства немного не отточен.&lt;/p&gt;&lt;p&gt;Код примеров на мой вкус немного грязноват. Много где можно радикально улучшить читабельность простыми изменениями вроде добавления структур вместо списков и магических ca*r'ов, заменой анонимных функций на именованные. Стиль который она оставляет после себя как мне кажется нельзя назвать изящным, но это мнение нуба явно тяготеющего к диалектам Scheme-семейства а не Common для которого написана книга.&lt;/p&gt;&lt;p&gt;И да, просто копировать примеры в таком виде было не очень интересно и решение нашлось само собой - я недавно начал ковырять Racket а книжка то написана под Common LISP! Вот и совместил приятное с полезным, &lt;a href='https://github.com/CheatEx/land-of-lisp-rkt'&gt;транслировал примеры&lt;/a&gt; на современный Racket. И я теперь практически лисп-переводчик с опытом работы :) Кстати благодаря этой книжке я сделал и небольшой (и кажется первый сколько-нибудь полезный) вклад в опенсурс: изрядно &lt;a href='https://github.com/follesoe/sublime-racket/pull/3'&gt;подвыправил&lt;/a&gt; Racket плагин для Sublime.&lt;/p&gt;&lt;p&gt;В общем несмотря на то что книжка вроде не блестящая при должном настрое и желании что-то поделать руками она приночит массу удовольствия. Рекомендую!&lt;/p&gt;</description><pubDate>Mon, 17 Mar 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-01-30-links-2/</guid><link>https://cheatex.cc/posts-output/2014-01-30-links-2/</link><title>Линкопост #2</title><description>&lt;p&gt; Пачка ссылок за последние... 4 месяца. Для начала связанное с Racket.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.infoq.com/presentations/Racket'&gt;The Racket Way&lt;/a&gt; - доклад на strange loop, рассказ о дизайне или даже скорее философии Racket. Несколько наглядных примеров потребности в мета-языках. Достаточно подробно показана возможность плавной эволюции по пути приложение, библиотека, internal DSL, подмножество языка и новый язык со специальным синтаксисом в конце. Полезно посмотреть и как введение в Racket и чтобы понять что можно делать с мета-языками. Мне такая схема показалось существенно более жизнеспособной чем применение MPS или создание external DSL с 0.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.greghendershott.com/fear-of-macros/'&gt;Fear of Macros&lt;/a&gt; - что-то вроде мини-книги или большого цикла статей о макросах в Racket. Вопрос раскрывается гораздо удачнее чем в основной документации. Автор начинает с простого но низкоуровнего примера и оттуда движется к высокоуровневым pattern-based macros. Оставляет целостное понимание что такое syntax object, expansion и т.д. Интересно будет тем что интересуется мета-программированием или изучает схему.&lt;/p&gt;&lt;p&gt;&lt;a href='https://github.com/greghendershott/frog'&gt;Frog&lt;/a&gt; - аналог Octopress на Racket, вроде попроще в инсталляции. Выглядит симпатично, использует модный Bootstrap. В качестве языка разметки в том числе можно использовать &lt;a href='http://docs.racket-lang.org/scribble/index.html'&gt;Scribble&lt;/a&gt; или Markdown. Код более менее читаемый, в общем неплохой проект для поиграться с языком и посмотреть как на нём пишут реальный софт.&lt;/p&gt;&lt;p&gt;Немного холиваров и вбросов.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=TS1lpKBMkgg'&gt;We're Doing It All Wrong&lt;/a&gt; - доклад от бывшего участника разработки компилятора Scala. Подробно, хотя и крайне эмоционально рассматривает различные проблемы в самом языке и текущей реализации компилятора. Немного сумбурно - неявно мешаются в кучу проблемы дизайна языка,  библиотеки, кода компилятора а в конце вообще выдвигается идея некоего идеального языка не совсем очевидно связанная с озвученными проблемами. Но в любом случае стоит уделить внимание если вы планируете куда-то внедрять скалу.&lt;/p&gt;&lt;p&gt;&lt;a href='http://damienkatz.net/2013/01/the_unreasonable_effectiveness_of_c.html'&gt;The Unreasonable Effectiveness of C&lt;/a&gt; - наверно одна из самых интересных статей из прочитанных мной за последнее время. Анализируется почему старый, низкоуровневый язык C был и остаётся популярным и весьма успешным. Строго рекомендовано к прочтению фанбоям хаскелей, скал, джаваскриптов, коков и всего остального что конвертирует силу мысли в быстрые и безбажные программы.&lt;/p&gt;&lt;p&gt;&lt;a href='http://jakobz.livejournal.com/236681.html'&gt;Честно про современные веб-технологии&lt;/a&gt; - запихнул в этот раздел, но вообще считаю все написанное в посте чистейшей правдой. Не могу не добавить что надвигающийся &lt;a href='http://tools.ietf.org/html/draft-ietf-httpbis-http2-09'&gt;HTTP 2.0&lt;/a&gt; обещает сделать реализацию и поддержку веб-сервера уделом пары-тройки корпораций.&lt;/p&gt;&lt;p&gt;Хорошие статьи по практике программирования.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.toptal.com/python/computational-geometry-in-python-from-theory-to-implementation'&gt;Computational Geometry in Python: From Theory to Implementation&lt;/a&gt; - понятный и краткий обзор вычислительной геометрии с точки зрения программиста. Хорошо проиллюстрирован кодом на питоне. Очень приятный способ размять мозги в новой области.&lt;/p&gt;&lt;p&gt;&lt;a href='http://fsharpforfunandprofit.com/posts/recipe-part1/'&gt;How to design and code a complete program&lt;/a&gt; - очень хорошая серия статей о дизайне в функциональном стиле. Построена вокруг одного примера - CRUD приложения для веба. Просто и наглядно излагаются некоторые неочевидные концепции. Код на хаскеле.&lt;/p&gt;&lt;p&gt;Ну и немного философии. &lt;a href='http://www.sfu.ca/~egan/Difficult-article.html'&gt;Why education is so difficult and contentious&lt;/a&gt; - большой обзор происхождения и актуальных проблем современного образования. Интересна тем что внятно формулирует цели образования и показывает что они не очень то совпадают с интересами современного индивида, да и во многом общества.&lt;/p&gt;&lt;p&gt;Последняя ссылка на тему личного управления задачами. &lt;a href='http://www.bulletjournal.com/'&gt;Bullet Journal&lt;/a&gt; - система ведения TODO/календаря в бумажном блокноте. Показалась удобной, сам тестирую.&lt;/p&gt;</description><pubDate>Thu, 30 Jan 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-01-21-drunkards-walk/</guid><link>https://cheatex.cc/posts-output/2014-01-21-drunkards-walk/</link><title>"(Не)совершенная случайность"</title><description>&lt;p&gt;Прочитал эту замечательную &lt;a href='http://www.ozon.ru/context/detail/id/5086716/'&gt;книгу&lt;/a&gt; буквально за 3 дня - наверно самое быстрое прочтение в моей жизни.&lt;/p&gt;&lt;p&gt;Книга посвящена теории вероятности и содержит её рассмотрение сразу с нескольких ракурсов и автор не старается как-то их разделять по ходу изложения. Теория рассказывается от простого к сложному с привлечением разных ракурсов по мере необходимости. В принципе в кинге уверенно распознаются три аспекта.&lt;/p&gt;&lt;p&gt;Во-первых рассказываются, именно рассказываются, сами тервер и матстат. Простым человеческим языком, без сигма-алгебры, условной вероятности и вообще без единой формулы. Очень понятно и просто, книга как ни одна сильна в том чтобы построить контекст вокруг объектов из мира статистики, добавить к заученным в универе терминам очень много семантики. По последовательности изложения она фактически совпадает с классическим курсом тервера и примерно первой третью курса статистики.&lt;/p&gt;&lt;p&gt;Второй предмет рассмотрения книги - история развития тервера. Изложения всех законов органично переплетено с рассказом истории их формирования. Много внимания уделено биографии учёных, их отношениям с другими науками. Для меня как для любителя истории науки этот аспект книги был наиболее интересен.&lt;/p&gt;&lt;p&gt;Третий, и кажется центральный для автора, аспект книги - психологический. При изложении очередной концепции рассказывается как люди склонны ошибаться при его применении к жизненным ситуациям. Всегда приводится несколько примеров наивного применения тервера к жизни. В каждом случае подробно рассматривается корректный способ анализа той или иной проблемы и какие ловушки психологии приводят массы (а иногда и уважаемых учёных) к заблуждениям. В частности подробно рассмотрена знаменитая задача Монти Холла, и кажется доступно даже для меня доказано решение.&lt;/p&gt;&lt;p&gt;Также хочется отметить перевод - действительно хороший и грамотный. Я не заметил ни одной шероховатости в терминологии и описании сложных ошибок использования тервера. Единственный момент который вызвал моё непонимание это название книги. На английском она называется "Drunkard's Walk" то есть "Походка пьяного" как я понимаю.&lt;/p&gt;&lt;p&gt;Книга однозначно рекомендуется и любителям истории, тем кто не теряет надежду понять тервер и даже увлекающимся психологией. Книга будет полезна абсолютно всем вовлечённым в процессы принятия решений, особенно тем кто управляет сложными тех. процессами вроде разработки ПО.&lt;/p&gt;</description><pubDate>Tue, 21 Jan 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2014-01-09-clojure-vs-racket/</guid><link>https://cheatex.cc/posts-output/2014-01-09-clojure-vs-racket/</link><title>Clojure vs. Racket - мои наблюдения</title><description>&lt;p&gt;Недавно потянуло меня подосвежить в памяти ЛИСП, в качестве учебного пособия и источника игрушечных проектов я без колебаний выбрал LoL. А вот над тем какой диалект выбрать призадумался на пару дней. Вообще сама ситуация довольно примечательна, ЛИСП насколько я понимаю сейчас является единственным языком с несколькими совершенно живыми и здравствующими диалектами. Встраиваемые я сразу отбросил, но и вполне себе самостоятельных осталось порядочно.&lt;/p&gt;&lt;p&gt;В финал вышли два - &lt;a href='http://clojure.org/'&gt;Clojure&lt;/a&gt; и &lt;a href='http://racket-lang.org/'&gt;Racket&lt;/a&gt;. Common Lisp я отбросил так как в нём многовато на мой вкус специальных форм, макросов и прочих интересных вещей, мне он показался достаточно непоследовательным. Для двух финалистов есть &lt;a href='http://programming-puzzler.blogspot.com/2010/08/racket-vs-clojure.html'&gt;известное и по сути очень хорошее сравнение&lt;/a&gt;. Его вывод достаточно однозначен - на практике программировать на Clojure гораздо удобнее, а для учебных целей у диалектов паритет. Однако пост от 2010 года и часть данных там устарели. Ниже я перечислю все устаревшие моменты в том посте ну и приведу пару фактов которые склонили мой выбор в пользу ракеты.&lt;/p&gt;&lt;p&gt;Первый довод автора - отсутствие общих интерфейсов у разных структур данных, в частности списка и вектора. На сколько я могу судить эта проблема решена. Во-первых введено понятие &lt;a href='http://docs.racket-lang.org/reference/sequences.html'&gt;последовательности&lt;/a&gt; и определён ряд удобных &lt;a href='http://docs.racket-lang.org/guide/for.html'&gt;форм и функкций&lt;/a&gt; для работы с ними. Кроме того добавлена наконец поддержка &lt;a href='http://docs.racket-lang.org/reference/struct-generics.html'&gt;абстрактных типов данных&lt;/a&gt;. Кажется полностью аналогична &lt;a href='http://clojure.org/protocols'&gt;протоколам&lt;/a&gt; из Clojure.&lt;/p&gt;&lt;p&gt;Вторая проблема: не консистентная работа со словарями. Она исправлена во-первых ведением &lt;a href='http://docs.racket-lang.org/reference/dicts.html'&gt;протокола для словарей&lt;/a&gt;, поддерживаемого из коробки хеш-таблицами и списками пар. Во-вторых богатым семейством функций &lt;a href='http://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._in-dict%29%29'&gt;in-dict*&lt;/a&gt; по преобразованию словарей в последовательности.&lt;/p&gt;&lt;p&gt;Последнее что не понравилось автору - отсутствие ленивых списков или потоков. Она тоже исправлена на настоящий момент - есть неплохая на мой взгляд &lt;a href='http://docs.racket-lang.org/reference/streams.html'&gt;библиотека потоков&lt;/a&gt;, хорошо прилегающая в нужных местах к последовательностям и словарям.&lt;/p&gt;&lt;p&gt;В принципе я согласен с тем что сейчас Clojure ближе к промышленности. Но связано это в основном с количество активных фанатов которые активно её рекламируют и, надеюсь, репортят баги.&lt;/p&gt;&lt;p&gt;Почему я в итоге выбрал Racket? Буквально две причины. Во-первых в Clojure слишком много на мой вкус синтаксических конструкций. Да да, ЛИСП с избытком конструкций, куда мир катится? Куча каких-то скобочек, шапочек, двоеточий и стрелочек... Всякие навороты вроде ключевых слов очень активно используются стандартной библиотекой. Вторая - JVM. Сейчас я уж слишком привязан к ней, надо как-то расширять кругозор.&lt;/p&gt;</description><pubDate>Thu, 09 Jan 2014 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2013-12-23-text/</guid><link>https://cheatex.cc/posts-output/2013-12-23-text/</link><title>Чем хорош текст</title><description>&lt;p&gt; Недавно отсмотрел &lt;a href='http://vimeo.com/worrydream'&gt;серию презентаций&lt;/a&gt; небезызвестного Брета Виктора. Кстати всем их рекомендую. Последнюю из них, "The Future Of Programming", я бы назвал вторым лучшим техническим докладом что я видел (Угадайте какой первый?).&lt;/p&gt;&lt;p&gt;Теперь собственно о чём хотел написать. Если не вдаваться в детали, то основная мысль Виктора - графические интерфейсы должны полностью доминировать над текстово-командными. Причём не столько в области весёлых фермеров, сколько в сложных ответственных областях, таких как разработка ПО.&lt;/p&gt;&lt;p&gt;За деталями и доказательствами я предлагаю отправится к самим презентациям. Здесь же я хочу рассмотреть несколько свойств текста которые, как мне кажется, пока не присущи графике. Возможно не в силу каких фундаментальных проблем, но из за малого количества исследований в этих направлениях. Буду рад опровержениям моей точки зрения в виде ссылок на статьи а может работающий софт.&lt;/p&gt;&lt;p&gt;Первое и важнейшее свойство - переносимость. Искажение картинки - может радикально изменить её восприятие а добиться одинакового отображения какой-то графики на разных устройствах - сложная задача. Я не говорю что она не решается, тем более что не всякие искажения фатальны для разных типов информации, но она по крайней мере есть. Для текста практически любое разумное искажение (читай шрифт) не мешает восприятию.&lt;/p&gt;&lt;p&gt;Кусок текста можно послать коллеге в скайпе или вставить в научную статью с минимальными затратами. Текст ничего не потеряет, хитрая визуализация динамически скрывающая часть свойств и связей объектов может оказаться не пригодной для простой пересылки если на другом конце нет ПО которое её переваривает. В конце концов текст можно перенести на бумагу и (если он разумного размера) взять с собой на необитаемый остров.&lt;/p&gt;&lt;p&gt;Вторым важным достоинством текстов является регулярность структуры. Один символ идёт за другим. В отличии от графов, где очень трудно выделить какой-то тип регулярности. Для нашего мозга это не самая большая помеха, но для алгоритмической обработки серьёзная проблема. Простые проблемы вроде поиска по шаблону превращаются очень интересные если их перевести из мира текстов в мир графики. Просто понять что здесь может значить "шаблон" уже сложно.&lt;/p&gt;&lt;p&gt;У этого достоинства есть пара очень важных подпунктов. Первый - это валидация. Для текстов есть развитая теория грамматик и не менее развитая практика написания парсеров. Есть ли они для графов/картинок?&lt;/p&gt;&lt;p&gt;Второй - возможность получения разницы между двумя объектами. Да да, тот самый diff. Он жизненно важен для поддержки софта, без него нельзя говорить о более-менее масштабном применении визуальных языков.&lt;/p&gt;&lt;p&gt;Думаю именно этими преимуществами текста вызвана примерно нулевая популярность всяческих графических языков и сред разработки для них.&lt;/p&gt;</description><pubDate>Mon, 23 Dec 2013 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2013-10-22-joker/</guid><link>https://cheatex.cc/posts-output/2013-10-22-joker/</link><title>Joker</title><description>&lt;p&gt;Сходил 15 октября на конференцию &lt;a href='http://jokerconf.com/'&gt;Joker&lt;/a&gt;. Было хорошо, организация на 5- (минус за грустного чувака в костюме бетменовского джокера, Леджер негодует с того света), подбор докладов на 4. Далее краткий обзор докладов на которых я присутствовал.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=mc9NaoDX5bU'&gt;Факты и заблуждения о Java-сериализации&lt;/a&gt; Хороший доклад, я так понимаю ничего что нельзя прочитать в спеке сказано не было... Но ктож её читал. Достаточно компактно рассказано о основных возможностях стандартной джавовской сериализации, и случаях когда не надо искать ей замену. По крайней мере для меня было познавательно.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=G6LJkWwZGuc'&gt;Парадигмы ООП, основы здравого дизайна и архитектуры Java приложений&lt;/a&gt; Не очень понравился. Рассказывал какой-то коуч, так что представление было бодрым. Но и рассказ согласно званию автора был про очевидные вещи вроде SOLID и DRY. Много ссылок на "авторитеты" вместо рассмотрения каки-то конкретных решений и их последствий. Много проталкивания одной позиции в давних холиварах вроде interface vs. abstract class или setters/getters vs. public field.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=CX_K1r0Vklg'&gt;Компромиссы, или Как проектируются языки программирования&lt;/a&gt; Неплохо. Но в основном содержание свелось к "В Kotlin всё збс.". Я пару раз попробовал набросить на тему что хаки в компиляторе склонные выявляться в самые интересные моменты. Мне сказали что встроили аккуратно но крепко, никто ничего не заметит. Ага...&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=2bDZj9_hpuI'&gt;Платформа для Видео сроком в квартал&lt;/a&gt; Хороший доклад от техлида Одноклассников. Рассказ был про их хостинг видео. Всё кратко и по делу. Вопросы не отставали от доклада. Очень понравилось. Не так часто разрабы сервисов такого уровня делятся архитектурными решениями и цифрами. Яндекс вон всё больше норовит мап-редьюс фреймворк какой заопенсурсить.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=5XWgjSHZlQw'&gt;The (not so) dark art of Performance Tuning&lt;/a&gt; Откровенная муть. Какие-то эмпирические правила на тему что смотреть при проблемах с производительностью и куда крутить когда что-то увидели. Мало описания смысла циферок в табличках, мало идей на тему как искать проблему когда она не на поверхности. Долгое и непонятное демо в конце.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=kPWxDQ27nqM'&gt;Разработка API в Java-проекте: как оказывать влияние на людей и не приобрести врагов&lt;/a&gt; Попытка обобщить хорошие практики в дизайне API на джаве. Много очевидных вещей, но зато автор не ленился приводить альтернативы и трэйд-оффы. Подача мягко говоря хромала, очень монотонная без намёка на акценты речь. Каких-то новых для себя идей не заметил, но как обобщение пойдёт.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=Zq&amp;ndash;4Vh5RLI'&gt;JDK8: Stream style&lt;/a&gt; Хороший технический доклад от ораклового инженера. Довольно кратко и по делу. После него достаточно понятно становится чего ждать от 8го релиза джавы. Были приведены кое-какие интересные детали дизайна. Докладчик опытный, подача на отл. Рекомендуется к просмотру.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=Azf4oUL-Dqc'&gt;В поисках Tommy Hilfiger&lt;/a&gt; Интересный рассказ про внутренности &lt;a href='http://lucene.apache.org/core/'&gt;Lucene&lt;/a&gt;. Немного дизайна немного алгоритмов, много задачек ушло в зал, на что-то я даже ответил. Докладчик молодец что (а) выбрал техническую тему, без лирики, (б) с самого начала наладил взаимодействие с аудиторией. Если Кормен на полке покрылся пылью то рекомендуется к просмотру с паузами на вопросах в зал.&lt;/p&gt;</description><pubDate>Tue, 22 Oct 2013 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2013-10-16-GEB/</guid><link>https://cheatex.cc/posts-output/2013-10-16-GEB/</link><title>ГЭБ</title><description>&lt;p&gt;Прочитал &lt;a href='http://www.ozon.ru/context/detail/id/5540786/'&gt;сабж&lt;/a&gt;. Ещё буду выборочно перечитывать, по крайней мере доказательства...&lt;/p&gt;&lt;p&gt;Что можно сказать?... Автор неимоверно крут. Что бы по науке, технике или искусству вы сейчас не читали - бросайте, читайте эту книгу. Всё-рано после неё захочется перечитать и передумать заново...&lt;/p&gt;&lt;p&gt;От прочтения есть важный бонус. Когда встречается какой-нибудь просветитель рассказывающий что мол нельзя так запросто объяснить зачем там какой-нибудь теркат нужен и что он такое из себя представляет - можно смело говорить что он бездарен и тыкать книжкой в качестве пруфа. Хотя скорее всего будет просто грустно и хотеться уйти...&lt;/p&gt;&lt;p&gt;Ладно хватит абстрактной воды, пора немного рассказать о чём книга. В предисловии Хофштадтер приводит мнения разных людей о том про что эта книга. Так вот, дочитав до конца я понял что очень важного предположения там не хватает. Эта книга - о сложности!&lt;/p&gt;&lt;p&gt;Действительно одна из центральных концепций книги - "странные петли". Системы с обратной связью, но только между всеми уровнями, без начала. Про этакие гармошки свёрнутые в бублик. Про проблемы которые можно начать изучать откуда угодно и и никогда не закончить. Про всю эту жуть которая пугает технаря со стажем, так же как пугала всех математиков ещё 100 лет назад. А может и им до сих пор страшновато?&lt;/p&gt;&lt;p&gt;Сама структура книги образует петлю. Каждая глава начинается с небольшого диалога разыгрывающего очередную концепцию. Она подхватывается текстом который немного расшифровывает её и немного диалоги предыдущих глав. Каждая новая глава привносит больше понимания в предыдущие, открывает незаметные детали.&lt;/p&gt;&lt;p&gt;Книга рассматривает в деталях как можно всё запутать, как сама природа это делает. И вместе с тем показывает как можно что угодно распутать назад, понять, построить устойчивую модель. Например очень кратко и интересно рассказывается про синтез белков и передачу наследственной информации. Не просто о физике процесса, но о семантике разных его компонентов. Я немало времени потратил на биологию в своё время, и уверен что если в профильных книгах такое и можно найти, то в очень немногих.&lt;/p&gt;&lt;p&gt;Книгу стоит прочитать хотя бы ради того чтобы увидеть что даже для бесконечно сложных объектов мы всегда можем найти средства описания, способ думать о них простым и непротиворечивым способом. Найти объяснение очень глубинным свойствам используя очень примитивный базис. Автор не обещает что такие способы мышления будут очень легки, но убеждает в том что они существуют.&lt;/p&gt;</description><pubDate>Wed, 16 Oct 2013 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2013-09-08-real-scala-problems/</guid><link>https://cheatex.cc/posts-output/2013-09-08-real-scala-problems/</link><title>Пара слов о реальных проблемах со Scala</title><description>&lt;p&gt;Как то давно я накатал изрядную стену текста на тему что хорошо в Scala и почему  люди рассказывающие что на ней невозможно писать не вызывают у меня доверия: &lt;a href='http://it-talk.org/post82738.html#p82738'&gt;http://it-talk.org/post82738.html#p82738&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Пришло время востановить баланс и немного поговорить о конкретных проблемах, которые я в ней вижу.&lt;/p&gt;&lt;p&gt;Первое что раздражает после перехода с Java - время компиляции. Можно сказать что от среднеполезного проекта можно ожидать времени компиляции от 2 минут. Это крайне печально. Отложенный фидбэк замедляет разработку. Для склонных отвлекаться людей вроде меня фатально замедляет; частенько запустив компиляцию я обнаруживаю себя мин через 20 читающим какую-нибудь мало относящуюся к задаче статейку. В то время как всё прогрессивное человечество минимизирует циклы работы, разработчики компилятора не занимаются этой проблемой уже много лет. fsc по моему опыту радикально ситуацию не улучшает.&lt;/p&gt;&lt;p&gt;Существенно лучше показывает себя sbt и волшебная ~. Однако тул это не простой, когда я следил за его развитием совместимость ломалась чуть не каждый релиз. А если надо развивать проект с историей, то смену системы сборки в серьёз никто не рассматривает. В итоге сейчас я вижу скорость работы компилятора главной проблемой scala.&lt;/p&gt;&lt;p&gt;Вторая серьёзная проблема - это подготовка пишущих. Часто можно слышать позитивные рассказы про так один человек взял и внедрил и вся команда в функциональном экстазе залабала в разы быстрее. Это не правда. Если дать скалу человеку, которого в универе учили на паскале а потом он 5 лет писал на джаве, вы получите кучу (в смысле втрое больше чем того требует задача) джава-кода в другом синтаксисе но компилирующегося в 8 раз медленнее. Более менее окупающее в моём понимании применение скалы требует нескольких вещей от всех кто её использует.&lt;/p&gt;&lt;p&gt;Во-первых это понимания почему собственно этот язык. Если люди уверены что new ArrayList/for/add лучше map, он и правда будет лучше!&lt;/p&gt;&lt;p&gt;Во-вторых базового навыка программирование в функциональном стиле. Ничего космического, но надо ясно видеть в коде простые паттерны роде map/filter. Не заводить переменные без повода. Понимать что функции можно параметризовать не только данными но и операциями. Уметь создавать простые АТД по мере необходимости (а не мега бины со сложной символикой null'ов в разных полях). Вообще этерпрайзие мозга сводит на нет потуги эффективно применить языки моложе 20 лет :)&lt;/p&gt;&lt;p&gt;По большому счёту это все серьёзные проблемы, но есть еще пара неприятностей.&lt;/p&gt;&lt;p&gt;Не совсем уравновешенное сообщество. В том смысле что нельзя смотреть лежащий на гитхабе код и стабильно учиться. Не устоялся стиль, не сформировались практики. Нет общепринятой границы хорошо-плохо (что на самом деле хорошо, но не в самом начале). Кто-то пишет на самом деле на хаскеле, у кого-то джава с замыканиями. Нужно очень критическое восприятие для того чтобы отбирать решения и техники для своего проекта. Пруф: &lt;a href='http://ru-scala.livejournal.com/39341.html'&gt;http://ru-scala.livejournal.com/39341.html&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Переусложнена на мой взгляд библиотека коллекций. Множество методов преобразования с неочевидными результатами. Куча классов и методов время работы которых непросто удержать в голове.&lt;/p&gt;&lt;p&gt;Противоречивый, сложный фреймворк Akka. Который позиционируется как аналог OTP выполненный на JVM, но на самом деле принципиально от него отличается.&lt;/p&gt;&lt;p&gt;Вот вроде и всё. Ваши мысли по сабжу?&lt;/p&gt;</description><pubDate>Sun, 08 Sep 2013 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2013-09-08-links-1/</guid><link>https://cheatex.cc/posts-output/2013-09-08-links-1/</link><title>Линкопост</title><description>&lt;p&gt;Решил вот для поддержания блога живым поделиться подборкой ссылок. Это тут отнюдь не новые статьи, скорее то что отметилось актуальностью а не новизной..&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.faqs.org/docs/artu/ch01s06.html'&gt;Basics of the Unix Philosophy&lt;/a&gt; - в статье рассказывается история "философии Юникс", в форме примеров её формулировок разными людьми в разное время. Очень интересно показывается развитие идей в области дизайна программ.&lt;/p&gt;&lt;p&gt;&lt;a href='http://www.linusakesson.net/programming/tty/'&gt;The TTY demystified&lt;/a&gt; - подробно рассматривается архитектура TTY, то как особенности железа разных эпох влияли и продолжают влиять на устройство современных (уже исключительно виртуальных) терминалов. Очень интересная история, красивый и пугающий пример врмирования legacy.&lt;/p&gt;&lt;p&gt;&lt;a href='http://steve-yegge.blogspot.ru/2007/12/codes-worst-enemy.html'&gt;Code's Worst Enemy&lt;/a&gt; - древний пост в ныне уже мёртвом блоге. Однако в связи со спецификой нынешней работы я прочувствовал его в полную силу только сейчас. В статье рассматриваются динамика и последствия раздувания кодовой базы. Очень помогает критически посмотреть на цену добавления "ещё одной фичи".&lt;/p&gt;&lt;p&gt;&lt;a href='http://lionet.livejournal.com/123634.html'&gt;Как эффективно обучать инженеров?&lt;/a&gt; - изыскания небезызвестного Валкина на тему. Две очень полезные ссылки внутри.&lt;/p&gt;&lt;p&gt;&lt;a href='http://wadler.blogspot.ru/2011/04/vs-naipauls-seven-rules-for-beginners.html'&gt;VS Naipaul’s Seven Rules for Beginners&lt;/a&gt; - В продолжение темы, 7 простых правил написания текстов. Подкупает именно простотой. Вот, практикуюсь...&lt;/p&gt;&lt;p&gt;&lt;a href='http://aphyr.com/tags/Jepsen'&gt;Jepsen&lt;/a&gt; - большая серия статей в которой рассматриваются проблемы поведения распределённых систем при сегментации. Интересна тем что автор предлагает простой тест, выражающих в конкретных цифрах утерянных данных и применяет его к ряду очень модных "scalable, fault-tolerant, NoSQL" баз данных. Серия ценна подробным анализом и объяснениями результатов тестов. Must read для всех практикующих модерновые БД в полях.&lt;/p&gt;&lt;p&gt;&lt;a href='http://brooker.co.za/blog/2012/11/13/increment.html'&gt;Java's Atomic and volatile, under the hood on x86&lt;/a&gt; - подробный разбор особенностей реализации атомиков в Java. Содержит целый ряд заслуживающих внимания ссылок на смежные темы.&lt;/p&gt;&lt;p&gt;&lt;a href='http://lwn.net/Articles/262464/'&gt;What is RCU, Fundamentally?&lt;/a&gt; - рассматривает семейство неблокирующих алгоритмов типа Read-Copy-Update и то как они поддерживаются Linux Kernel. Содержит массу примеров того как легко получить некорректный алгоритм такого типа, упустив из виду нюансы моделей памяти. Попутно даётся и обзор моделей памяти современных процессоров. Весь код на С, но не очень суровом, типичному Java-программисту было понятно.&lt;/p&gt;</description><pubDate>Sun, 08 Sep 2013 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2012-09-24-DSLs-and-CPJ/</guid><link>https://cheatex.cc/posts-output/2012-09-24-DSLs-and-CPJ/</link><title>"DSLs in action" и "Concurrent programming in java"</title><description>&lt;p&gt; Набег студентов, лето и смена работы в который раз привели этот блог к глубокому запустению. Ну да попробую исправится. Для начала расскажу о паре книжек, прочитанных мной за последние полгода (стыдно, стыдно, стыдно, 180 дней и всего сотен 5 страниц).&lt;/p&gt;&lt;p&gt;Итак, первая это "DSLs in action", пролежавшая, кстати, в очереди на прочтение без малого год. Начинается она довольно вяло, где-то на 100 странице было уже неслабое желание бросить. Введение полно рассуждениями на тему места DSL, их экономической целесообразности и классификаций. Не чтобы это было совсем не нужно, но ИМХО такие вещи должны быть в конце. Падать на читателя уже, так сказать, замотивированного дойти до конца. Ну да хватит о грустном.&lt;/p&gt;&lt;p&gt;По мере появления конкретных примеров и расширения списка языков в которых автор пробует свои силы книга быстро приковывает внимание. Очень похоже на руководство по Scala, о котором я писал ранее, вторые две трети пролетают заметно быстрее первой одной. Перед читателем предстаёт захватывающая карусель из техник ФП, дизайна собственно языков, метапрограммирования и всё это в нескольких вариантах на разных языках.&lt;/p&gt;&lt;p&gt;Автор без сомнения проделал огромную работу готовя примеры и выбирая подход к решению каждой задачи. Книгу стоит прочитать даже людям совершенно не интересующимся DSL просто полюбоваться многообразием современных языков и тем диапазоном техник программирования который они предлагают.&lt;/p&gt;&lt;p&gt;Вторая книга которую я осилил за последнее время это небезызвестная "Concurrent Programming in Java". Наверно не стоит лишний раз её описывать, тем более, что даже на русском отзывов более чем достаточно, могу точно сказать что мне она без сомнения пошла на пользу.&lt;/p&gt;&lt;p&gt;Ктоме того замечу, что по контенту она практически не пересекается с прочитанной ранее "Java Concurrency in Practice". Если в гниге Lea рассматриваются в первую очередь примитивы многопоточности, в том числе и пути их реализации, то Goetz концентрируется на корректном их применениии в коде приложений. И естественно последний оперирует util.concurent как данностью. В общем можно заключить, что книги стоит читать обе, наверно даже в любой последовательности.&lt;/p&gt;</description><pubDate>Mon, 24 Sep 2012 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2012-09-24-validations-and-exceptions/</guid><link>https://cheatex.cc/posts-output/2012-09-24-validations-and-exceptions/</link><title>Validation и исключения: совместная жизнь</title><description>&lt;p&gt; Итак, после ознакомления с основными техниками применения валидаций давайте подумаем как их можно использовать в "реальном" проекте. "Реальный" проект подразумевает работу не в интерпретаторе в течении пары миллисекунд, под чутким присмотром автора, а на сервере далеко за океаном. И лишь изредка суровый незнакомый админ будет проверять не сожрала ли программа всю имеющуюся память...&lt;/p&gt;&lt;p&gt;Это значит,что будет происходить много чего о чём автор кода мог даже не догадываться. А о таких вещах JVM извещает код бросая исключения. Да да, возьмёт и бросит, и плевать ей на чистоту.&lt;/p&gt;&lt;p&gt;Ну и есть ещё один момент, не каждый алгоритм так уж легко записать, обрабатывая ошибки с помощью валидаций. Вот, например, такая штука была в какой-то момент у меня в проекте:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def readFields&amp;#40;rec: DBObject, ...&amp;#41;: GzVal&amp;#91;DataRecord&amp;#93; = {
  val deletedBy =
    for {
      userId &amp;lt;- get&amp;#91;ObjectId&amp;#93;&amp;#40;rec, &amp;quot;deleted&amp;#95;by&amp;quot;&amp;#41;;
      user &amp;lt;- getUserData&amp;#40;userId&amp;#41;.toSuccess&amp;#40;MissedEntity&amp;#40;userId.toString, &amp;quot;user&amp;quot;&amp;#41;&amp;#41;
    } yield user
  for {
    id &amp;lt;- get&amp;#91;String&amp;#93;&amp;#40;rec, &amp;quot;&amp;#95;id&amp;quot;&amp;#41;
    content &amp;lt;- get&amp;#91;String&amp;#93;&amp;#40;rec, &amp;quot;content&amp;quot;&amp;#41;
    updated &amp;lt;- asValidOption&amp;#40;get&amp;#91;DateTime&amp;#93;&amp;#40;rec, &amp;quot;upd&amp;quot;&amp;#41;&amp;#41;
    //twelve more
    user &amp;lt;- getUserById&amp;#40;userId, currentUserId map &amp;#40;new ObjectId&amp;#40;&amp;#95;&amp;#41;&amp;#41;&amp;#41;
      .toSuccess&amp;#40;MissedEntity&amp;#40;userId.toString, &amp;quot;user&amp;quot;&amp;#41;: ValidationError&amp;#41;
  } yield DataRecord&amp;#40;/&amp;#42;you not gonna like it&amp;#42;/&amp;#41;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В общем-то ничего сложного - берём запись из БД, разбираем проверяем значения, создаём объект. При этом что-то может упасть, но что и как упало на этом уровне никого не волнует. Разбор записи надо прекращать сразу независим от от того нарушилась ли консистентность или умерло соединение с БД.&lt;/p&gt;&lt;p&gt;Мои основные мысли на тему Exceptions vs. Validations можно выразить таким вот набором тезисов:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Валидации позволяют очень выразительно и кратко обрабатывать ошибки в чистом коде.&lt;/li&gt;&lt;li&gt;При этом используя и смешивая разные стили обработки ошибок.&lt;/li&gt;&lt;li&gt;Они требуют небольшой синтаксической избыточности на каждую операцию.&lt;/li&gt;&lt;li&gt;В то же время исключения часто являются вполне достойной абстракцией для обработки ошибок.&lt;/li&gt;&lt;li&gt;Они создают значительную синтаксическую избыточность, зато сразу на группу операций.&lt;/li&gt;&lt;li&gt;Суммируя эти наблюдения с тем фактом, что неожиданные исключения всё-равно будут пролетать, я принял на вооружение следующие принципы:&lt;/li&gt;&lt;li&gt;Высокоуровневые абстракции в приложении стоит строить используя валидации, однако страховать их на случай совсем внезапной ошибки.&lt;/li&gt;&lt;li&gt;Тот код который легче написать с использованием исключений нужно писать с использованием исключений.&lt;/li&gt;&lt;li&gt;Исключения из такого кода надо ловить и преобразовывать в валидации.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Далее я попробую описать основные детали того, как я пытался преобразовать эти принципы в работающую архитектуру. Для начала общая картина, срисованная с моего доклада в Минске.&lt;/p&gt;&lt;p&gt;&lt;img src="/img/validations-context.png" alt="Architecture diagram" /&gt;&lt;/p&gt;&lt;p&gt;Слева располагается достаточно грязный код, связанный с внешними службами вроде хранилища данных. Он бросает исключения как часть логики. Для него нужно выделить некоторый набор интерфейсных методов, которые перехватывают исключения и преобразовывают их в ошибки (символическая зелёная рамка). Преобразование это является по сути простой функцией, которую (не в случае бибилиотечного кода) вполне можно статически задать просто одну на систему ('Exception converter' на диаграмме).&lt;/p&gt;&lt;p&gt;Те, кто находятся правее написаны в более чистом стиле, игнорируют исключения (в смысле прозрачного пробрасывания наверх, а не в смысле подавления). Об их существовании вновь вспоминает лишь тонкая прослойка, между нашим кодом и внешним миром (в моём случае это был Lift, в других может быть сетевая библиотека или GUI). Давайте рассмотрим несколько фрагментов кода, для более точного представления этих идей. Скажем для нашего HTTP сервиса из предыдущих примеров мы отказались от строки как от типа ошибки, определив такой класс:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;abstract class Error&amp;#40;
  val httpCode: Int,
  val code: String&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;И каких-то его потомков, например так:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;case class MissedEntity&amp;#40;
  id: String, type: String&amp;#41;
extends Error&amp;#40;404, &amp;quot;MISSED&amp;#95;ENTITY&amp;quot;&amp;#41;

case class InternalError&amp;#40;
  @transient Throwable cause&amp;#41;
extends Error&amp;#40;cause, &amp;quot;INTERNAL&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Тогда можно легко задать функцию преобразования:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;val dispatchException: Function&amp;#91;Throwable, Error&amp;#93; = {
  case UserNotFound&amp;#40;name&amp;#41; =&amp;gt;
    MissedEntity&amp;#40;name, &amp;quot;user&amp;quot;&amp;#41;
  ...
  // Don't remove it!!!
  case t =&amp;gt; InternalError&amp;#40;t&amp;#41;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Имея на руках такую функцию можно написать систему из методов-врапперов для экранирования интерфейсных методов (зелёная рамочка) и собрать из них более или менее абстрактный модуль. Это будет выглядеть примерно так:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def safeVal&amp;#91;T&amp;#93;: Catch&amp;#91;ReqVal&amp;#91;T&amp;#93;&amp;#93; =
  handling&amp;#40;classOf&amp;#91;Throwable&amp;#93;&amp;#41; by { e =&amp;gt;
    dispatchException&amp;#40;e&amp;#41;.fail
  }

def safe&amp;#91;T&amp;#93;&amp;#40;block: =&amp;gt; T&amp;#41;: ReqVal&amp;#91;T&amp;#93; =
  safeVal&amp;#40; block.success &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Здесь используется стандартный модуль &lt;code&gt;control.Exception&lt;/code&gt;. Описывающий  обработку исключений в функциональном стиле. Если бы хотелось иметь более гибкую связь исключений с нашими ошибками, например иметь несколько стратегий отображения, то именно соединяя этот модуль с разными функциями отображения мы могли бы добиться необходимой адаптивности кода.&lt;/p&gt;&lt;p&gt;Пользоваться этими служебными функциями можно так:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def editData&amp;#40;e: Edit&amp;#41;:
  ReqVal&amp;#91;Data&amp;#93; = safe {
    //all dangerous stuff here
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Экранируя подобным образом методы компонентов связанных с вводом-выводом (или ещё чем-то трудно обрабатываемым при помощи валидаций) мы можем создать на определённом уровне глобальный переход от одного способа работы с ошибками к другому. И стоящая выше логика может пользоваться всеми теми приятностями про которые рассказывал ранее. На картинке это уровни 'Services' и 'Controllers'.&lt;/p&gt;&lt;p&gt;Есть ещё один важнейший момент, который подвиг меня на все эти эксперименты, но о котором я не говорил ранее. Дело в том, что конечной целью было построение REST сервиса, использующего протокол HTTP. Замечательной особенностью HTTP, дичайше игнорируемой всеми, является прямая поддержка сообщений об ошибках. В нём есть понятие кода ответа, что позволяет стандартным образом с детально описанной семантикой отвечать любому клиенту и быть понятым. Ещё раз подумайте, до любого клиента, хоть браузера, хоть curl можно донести что пошло не так и как с этим можно побороться... Вместо этого повсеместно практикуется '200 OK... {error: "Failed to..."}'. Зачем???!!!&lt;/p&gt;&lt;p&gt;Ну да, хватит о грустном. Поговорим о весёлом. А состоит оно в том что если мы представить себе, что у нас есть класс &lt;code&gt;HttpResponse&lt;/code&gt;, позволяющий описать все ответы. То преобразование из результата R выполнения какой-то операции в &lt;code&gt;HttpResponse&lt;/code&gt; концептуально абсолютно корректно задать как функцию &lt;code&gt;Validation&amp;#91;R&amp;#93; =&amp;gt; HttpResponse&lt;/code&gt;. Которая естественным образом распадается на незатейливый шаблон:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;r match {
  case Sucess&amp;#40;r&amp;#41; =&amp;gt; buildSuccessResponse&amp;#40;r&amp;#41;
  case Failure&amp;#40;f&amp;#41; =&amp;gt; buildFailureResponse&amp;#40;f&amp;#41;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Где &lt;code&gt;buildFailureResponse&lt;/code&gt;, как не сложно догадаться задаётся один раз на систему, а весь шаблон легко инкапсулируется в простую конструкцию. Предполагая, что у нас определены фунция-сериализатор &lt;code&gt;decompose: Any=&amp;gt;JSONObject&lt;/code&gt; и преобразование из объекта ошибки в HTTP ответ errorResponse, можно написать такую функцию.&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def valsToResponse&amp;#91;A&amp;#93;&amp;#40;v: ListVal&amp;#91;A&amp;#93;&amp;#41;: HttpResponse = v match {
  case Success&amp;#40;res&amp;#41; =&amp;gt;
    JsonResponse&amp;#40;decompose&amp;#40;rel&amp;#41;, successCode&amp;#41;
  case Failure&amp;#40;err&amp;#41; =&amp;gt; errorResponse&amp;#40;err&amp;#41;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Имея операцию &lt;code&gt;op: A=&amp;gt;ListVal&amp;#91;B&amp;#93;&lt;/code&gt;, где &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; уже специфичные для приложения классы представления запросов и ответов, можно легко строить (нетривиальные!) обработчики запросов в одну строчку.&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def getUsers&amp;#40;req: Req, namePattern: String&amp;#41;: LiftResponse = valsToResponse {
  getUsersInternal&amp;#40;namePattern&amp;#41; map { users =&amp;gt;
    val &amp;#40;count, list&amp;#41; = users
    Map&amp;#40;&amp;quot;count&amp;quot; -&amp;gt; count, &amp;quot;items&amp;quot; -&amp;gt; list&amp;#41;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Здесь для примера я преобразую пришедший список результатов в пару значений длина и собственно список (ну представим что кому-то из клиентов так удобнее ;) ). В таком примере &lt;code&gt;getUsersInternal&lt;/code&gt; имел бы тип &lt;code&gt;String =&amp;gt; ListVal&amp;#91;List&amp;#91;User&amp;#93;&amp;#93;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Такого вида функции тривиально цепляются к REST модулю Lift - не буду тратить место на пример.&lt;/p&gt;&lt;p&gt;Осталось предусмотреть последнюю деталь: возможность выброса исключения кодом высокого уровня. От них трудно страховаться, и глупо готовиться к ним везде в коде программы. Простое решение - перехват исключения с помощью некоторого хука, который предоставляют большинство контейнеров и фреймворков, конвертация в ошибку и преобразование уже её в ответ. В моём случае таким хуком являлся &lt;code&gt;LiftRules.exceptionHandler&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Вот в общем и всё. Наверно выглядит немного сумбурно, но примерно так оно и было. Надеюсь этот пример, кому нибудь поможет.&lt;/p&gt;</description><pubDate>Mon, 24 Sep 2012 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2012-03-11-prog-erlang-i-matematician/</guid><link>https://cheatex.cc/posts-output/2012-03-11-prog-erlang-i-matematician/</link><title>"Programming Erlang" и "Я - математик"</title><description>&lt;p&gt;С нового года осилил ещё пару книг. Отчитываюсь одним постом, чтобы не увеличивать энтропию.&lt;/p&gt;&lt;p&gt;Первая, "Programming Erlang" - классическое введение в язык программирования от автора. Очень краткая, очень содержательная книга. Где-то в сотне страниц рассматривается сам язык, ещё где-то в сотне страниц описываются основные техники применения и важные библиотеки. В заключении рассматриваются подходы к решению практических задач: работа с вводом-выводом, распределённое и параллельное программирование, защита от сбоев.&lt;/p&gt;&lt;p&gt;Книга подкупает скорость и глубиной изложения. По большому счёту со всеми упражнениями её можно прочитать за неделю. Прогресс который читатель делает по ходу прочтения потрясает - где-то на 200 странице он уже, вместе с автором, пишет обобщённый сервер с горячей заменой кода и экспортом функционала по сети (наколенный gen_server). Помнится Одерски на 200 странице ещё разбирался с объектами...&lt;/p&gt;&lt;p&gt;Простота и доходчивость также на высоте. Автор мастерски маневрирует между сложными концепциями передачи сообщений, процессов, очередей, сетей, синхронизации, надёжности и всего прочего. Все проблемы ставятся и решаются по одной оставляя у читателя лёгкое ощущение собственной божественности. Маленький совет для читающих: после главы про IRC чат не поленитесь прочитать сразу и приложение D. Очень очень хорошо дополняет.&lt;/p&gt;&lt;p&gt;Несмотря на все старания не смог найти в книге заметных недостатков. Автор задаёт очень, очень высокий стандарт для вводных книг по языкам/технологиям. Трудно что-либо с ним сравнивать, разве что JCP (естественно со скидкой на сложность топика).&lt;/p&gt;&lt;p&gt;Вторая книга "Я - математик" - это автобиография Ноберта Винера, посвящённая его научной карьере. Книга очень интересна анализом сути научной работы и её связи с прикладными задачами а также передачей настроений и мыслей учёных "того самого" поколения. В смысле сделавшего большинство открытий, которыми принято объяснять поразительный прогресс человечества за прошлый век. Автор тщательно передаёт характеры и стиль общения учёных того времени, показывает их отношение к политике и экономике, место в обществе.&lt;/p&gt;&lt;p&gt;Честно говоря я немного побаиваюсь пересказывать мысли изложеные в этой книге в силу возможного неверного истолкования мной и призываю прочитать её самостоятельно. Однако для привлечения внимания поделюсь парой кое-как осознанных идей. Во-первых меня, как инженера, подкупила позиция Винера относительно прикладных исследований и практических задач. Он уверен в том, что связь с реальным миром может принести любой научной работе не только ценность и признание, но и красоту, и завершённость. Он демонстрирует это множество раз, подчёркивая во-первых тот физический смысл который он находил в математических концепциях с во-вторых называя конкретное приложение своих результатов в технике и, иногда, других работах.&lt;/p&gt;&lt;p&gt;Во-вторых очень интресен его взгляд на науку как на коллективный труд, двигаемый вперёд не достижениями одиночек, но прогрессом всего сообщества. Он придаёт большее значение общению и кооперации, связям и кругозору чем единоличному таланту и затяжному "копанию" в одну сторону. Это кстати совпадает с недавно сформировавшимся у меня мнением, что научных успех имеет в основном социальную природу (и что в науку мне идти не стоит).&lt;/p&gt;&lt;p&gt;В общем книга вполне достойна прочтения и её можно рекомендовать как последний мотиватор, если мучает вопрос идти в науку или нет. Также стоит отметить, что перевод делался в 50е годы,  то есть до тотального вымирания научных переводчиков. Так что язык и стиль в книге на высоте, о которой тем-же "Пионерам программирования" можно только мечтать.&lt;/p&gt;</description><pubDate>Sun, 11 Mar 2012 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2012-01-18-programming-in-scala/</guid><link>https://cheatex.cc/posts-output/2012-01-18-programming-in-scala/</link><title>"Programming in Scala"</title><description>&lt;p&gt;Незадолго до нового года я закончил читать "Programming in Scala", написанную частично самим автором языка. Первое что стоит отметить это внушительный размер труда - более 800 страниц. Что в принципе понятно, язык совсем не маленький. Во-вторых книжка даёт более чем достаточное для самостоятельной жизни представление о языке. После неё можно брать и начинать писать рабочий проект.&lt;/p&gt;&lt;p&gt;Основным достоинством книги является наличие нескольких полноценных законченных примеров. Начиная с классической программы симуляции дискретных событий (угадайте откуда взятой) и заканчивая примером табличной системы. При этом фокус этих примеров плавно смещается с демонстрации отдельных фич языка на исследование взаимодействия нескольких особенностей и приёмов в одном проекте. Это оставляет весьма приятное впечатление, и, я думаю, должно позитивно сказываться на уверенности в новом инструменте у начинающего скала-программиста.&lt;/p&gt;&lt;p&gt;Если говорить о структуре книги, то она проста и очевидна, от базовых элементам к сложным, от стандартных функций первой необходимости к обзору больших кусков библиотеки. Несмотря на обилие ссылок вперёд спланированы они более чем грамотно и при последовательном прочтении книги необходимости перейти по ним не возникает.&lt;/p&gt;&lt;p&gt;Авторы не пытаются залезть очень глубоко, здесь не обсуждаются эзотерические возможности системы типов и проблемы ленивого ввода-вывода. Однако ряд сложных топиков освещён более чем добротно. В частности великолепны главы про парсер комбинаторы и устройство стандартной библиотеки коллекций (она без сомнения является лучшим гайдом по сабжу, который я видел).&lt;/p&gt;&lt;p&gt;По началу мне было несколько скучно читать (даже несмотря на осознанные пролистывания очевидных топиков), но по мере появления больших примеров и погружения в более тонкие моменты языка я втянулся. Вторая половина книги поглотила раза в 4 меньше времени чем первая. Уже знакомому с языком человеку видимо стоит иметь эту особенность в виду. В общем книга трудно назвать блестящей, однако ни малейших технических претензий к ней нет, это твёрдое 4.&lt;/p&gt;</description><pubDate>Wed, 18 Jan 2012 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-12-15-intro-to-validation-2/</guid><link>https://cheatex.cc/posts-output/2011-12-15-intro-to-validation-2/</link><title>Введение в Validation: часть 2</title><description>&lt;p&gt;В прошлой статье я постарался рассмотреть наиболее простой подход к использованию класса &lt;code&gt;Validation&lt;/code&gt; (&lt;a href='http://s.lurkmore.to/images/c/c7/Z150_03.jpg'&gt;искушенный&lt;/a&gt; читатель заметит, что не только его). Помимо этого, весьма прямолинейного, подхода к комбинированию значений внутри &lt;code&gt;Validation&lt;/code&gt; у нас есть второй, несколько более хитрый. Именно из за него scalaz когда-то и проник в мой проект.&lt;/p&gt;&lt;p&gt;Основная идея второго подхода состоит в том, что если мы можем как-то агрегировать ошибки, то выполняя операции над завёрнутыми в &lt;code&gt;Validation&lt;/code&gt; значениями можно автоматически это делать в случае обнаружения нескольких ошибок во входных данных. В отличии от ранее рассмотренного стиля, где ошибки вытаскиваются по одной, мы получаем стиль обработки (и соответственно извлечения из внешнего мира) ошибок "всё и сразу".&lt;/p&gt;&lt;p&gt;Именно в таком сценарии проявляется преимущество всех этих сложных штук, перед "проверенными временем" исключениями. У вас бывали в проекте классы "CompositeException" со списком других исключений в одном из полей? А милые кусочки кода, которые пробовали что-то делать, складывали ошибки в список и потом выбрасывали его в этой незатейливой оболочке? Тогда этот пост для Вас.&lt;/p&gt;&lt;p&gt;scalaz даёт нам операцию "собрать значения и если они успешны применить к ним функцию, а если нет - сагрегировать все возникшие ошибки". Реализуется она созданием временного объекта, который представляет собой выборку успешных данных. Эта выборка может быть преобразована применением к ней обычной функции (в смысле принимающей и возвращающей простые значения). Применение это похоже на обычный map, в том смысле, что при успешных входах на выходе появляется результат применения к ним функции. Но отличается тем, что оперирует сразу над набором значений и знает что делать с несколькими неудачами.&lt;/p&gt;&lt;p&gt;В scalaz для доступа к этому функционалу применяется без сомнения согревающий сердце истинного ценителя математики оператор &lt;a href='https://github.com/scalaz/scalaz/blob/6.0.3/core/src/main/scala/scalaz/MA.scala#L36'&gt;&lt;code&gt;|@|&lt;/code&gt;&lt;/a&gt;. Результатом его применения к паре завёрнутых в &lt;code&gt;Validation&lt;/code&gt; значений является тот самый промежуточный объект в который мы можем или продолжить добавлять значения с помощью того же оператора или применить к нему функцию соответствующей арности.&lt;/p&gt;&lt;p&gt;Не смертельно сложно, давайте решим простую задачку: пусть теперь мы ходим, чтобы наш код из предыдущего поста теперь не вытаскивал и проверял параметры по одному а брал и проверял всё сразу. Таким образом, чтобы напортачившему клиенту приходил сразу весь пакет его ошибок и он мог над всеми сразу поработать.&lt;/p&gt;&lt;p&gt;Это решается почти тривиально, однако для начала стоит немного абстрагироваться от деталей устройства запроса, для того чтобы переход был проще. Для этого воспользуемся старой доброй инкапсуляцией: соберём весь набор параметров в один класс и сделаем отдельную функцию для преобразования запроса в экземпляр этого класса:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;case class SearchQuery&amp;#40;
  text: String,
  order: Option&amp;#91;Order&amp;#93;,
  limit: Int&amp;#41;
 
def parseSearchQuery&amp;#40;req: Req&amp;#41;: ReqVal&amp;#91;SearchQuery&amp;#93; =
  for {
    text  &amp;lt;- get&amp;#40;req, &amp;quot;text&amp;quot;&amp;#41;
    order &amp;lt;- getOptOrder&amp;#40;req, &amp;quot;sort&amp;quot;&amp;#41;
    limit &amp;lt;- getInt&amp;#40;req, &amp;quot;limit&amp;quot;&amp;#41;
  } yield SearchQuery&amp;#40;text, order, limit&amp;#41;
 
def handleSearchPosts&amp;#40;req: Req&amp;#41;: Response =
  serialize&amp;#40;
    parseSearchQuery&amp;#40;req&amp;#41; flatMap searchPosts &amp;#95;
  &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Неплохо, наша программа несколько прибавила в кохесии, а основные умственные усилия были потрачены при удалении отступов после копипаста. Теперь пора притворить в жизнь задуманное. К сожалению сразу сделать это немного затруднительно. Дело в том, что для старого класса ошибок у нас нет разумного способа их объединять. Но это легко, исправить. Пусть в случае неудачи вместо одной ошибки у нас будет список ошибок. Да собственно библиотека нам даёт готовый такой тип, надо просто им воспользоваться.&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;type ReqVal&amp;#91;T&amp;#93; = ValidationNEL&amp;#91;String, T&amp;#93;
 
def get&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;String&amp;#93; =
  req.param&amp;#40;name&amp;#41;.toOption.toSuccess&amp;#40;
    &amp;#40;&amp;quot;Missed parameter &amp;quot;+name&amp;#41;.failNel&amp;#41;
 
def parseInt&amp;#40;s: String&amp;#41;: ReqVal&amp;#91;Int&amp;#93; =
  s.parseInt.fail.map { ne: NumberFormatException =&amp;gt;
      &amp;#40;&amp;quot;Value &amp;quot;+s+&amp;quot; is not an integer&amp;quot;&amp;#41;.failNel
    }.validation
 
def parseSearchQuery&amp;#40;req: Req&amp;#41;: ReqVal&amp;#91;SearchQuery&amp;#93; =
  &amp;#40;   get&amp;#40;req, &amp;quot;text&amp;quot;&amp;#41;
  |@| getOptOrder&amp;#40;req, &amp;quot;sort&amp;quot;&amp;#41;
  |@| getInt&amp;#40;req, &amp;quot;limit&amp;quot;&amp;#41;&amp;#41;
    apply SearchQuery &amp;#95;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;А всего остального кода сделанное не касается. Основная проблема - это места, где создаются экземпляры ошибок. Они имеют теперь новый тип и должны создаваться иначе, с помощью метода failNel добавляемого ко всем объектам при импорте scalaz автоматически. К счастью с успешными результатами вывод типов вполне может управится сам.&lt;/p&gt;&lt;p&gt;Обратите внимание, мы не можем (и определённо не хотим) втянуть в мир "всего и сразу" операцию обращающуюся к БД. Но миры "шаг за шагом" и "всё сразу" совершенно интероперабельны. Как только что было показано, мы всегда можем выбрать удобный и даже потом поменять решение, чтоб так реализации SOAP жили.&lt;/p&gt;&lt;p&gt;Ну и для полноты картины можно привести пример с композицией. Давайте снова уроним на свои головы новый функционал. Пусть наши пользователи захотели смотреть не первые N результатов поиска, а все сколько их есть. С издавна на руси такую задачу решали пагинацией. И вот на смену отслужившему свое параметру limit приходит пара новых: slice&lt;i&gt;start и slice&lt;/i&gt;end. И для обеспечения приемлемой производительности мы решили ограничить размер страницы 50 результатами.&lt;/p&gt;&lt;p&gt;Для начала как всегда подправим наши типы:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;case class Slice&amp;#40;start: Int, end: Int&amp;#41;
 
case class SearchQuery&amp;#40;
  text: String,
  order: Option&amp;#91;Order&amp;#93;,
  slice: Slice&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Имея необходимые типы в своём распоряжении, можно начать притворять функционал в жизнь. Очевидно, что потребуется новый строительный блок, функция вида &lt;code&gt;Req =&amp;gt; ReqVal&amp;#91;Slice&amp;#93;&lt;/code&gt;. &lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def getSlice&amp;#40;req: Req&amp;#41;: ReqVal&amp;#91;Slice&amp;#93; = {
  val start = getInt&amp;#40;req, &amp;quot;slice&amp;#95;start&amp;quot;&amp;#41;
  val end   = getInt&amp;#40;req, &amp;quot;slice&amp;#95;end&amp;quot;&amp;#41;
  if &amp;#40;&amp;#40;end | 0&amp;#41; - &amp;#40;start | 0&amp;#41; &amp;lt;= 50&amp;#41;
    &amp;#40;start |@| end&amp;#41; {Slice&amp;#40;&amp;#95;, &amp;#95;&amp;#41;}
  else
    &amp;quot;The page is too large&amp;quot;.failNel
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Отлично, и теперь новая функция легко встаёт на своё место.&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def parseSearchQuery&amp;#40;req: Req&amp;#41;: ReqVal&amp;#91;SearchQuery&amp;#93; =
  &amp;#40;   get&amp;#40;req, &amp;quot;text&amp;quot;&amp;#41;
  |@| getOptOrder&amp;#40;req, &amp;quot;sort&amp;quot;&amp;#41;
  |@| getSlice&amp;#40;req&amp;#41;&amp;#41;
    apply SearchQuery &amp;#95;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Вот и всё. В следующем посте я планирую наконец рассказать как пытался совместить эти изящные приёмы с грубым и жестоким миром баз данных и servlet контейнеров.&lt;/p&gt;</description><pubDate>Thu, 15 Dec 2011 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-11-08-intro-to-validation-1/</guid><link>https://cheatex.cc/posts-output/2011-11-08-intro-to-validation-1/</link><title>Введение в Validation: часть 1</title><description>&lt;p&gt; В этом посте я хочу подготовить почву для будущего рассказа о подходе к обработке ошибок, который как ни крути получился весьма скомканный без должной политической подготовки аудитории. Его темой будет класс Validation из библиотеки scalaz, некоторые (далеко не все) техники работы с ним и отдельные языковые конструкции, которые я нашёл наиболее полезными.&lt;/p&gt;&lt;p&gt;Этот класс по сути объявлен следующим образом:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;sealed trait Validation&amp;#91;+E, +A&amp;#93; {
  def isSuccess : Boolean = this match {
    case Success&amp;#40;&amp;#95;&amp;#41; =&amp;gt; true
    case Failure&amp;#40;&amp;#95;&amp;#41; =&amp;gt; false
  }
  def isFailure : Boolean = !isSuccess
}

final case class Success&amp;#91;E, A&amp;#93;&amp;#40;a: A&amp;#41; extends Validation&amp;#91;E, A&amp;#93;
final case class Failure&amp;#91;E, A&amp;#93;&amp;#40;e: E&amp;#41; extends Validation&amp;#91;E, A&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;В объявлении есть ещё ряд интересных методов, но давайте пока оставим их без внимания. Ничего не напоминает? Да это же брат-близнец &lt;a href='http://www.scala-lang.org/api/2.9.1/index.html#scala.Either'&gt;&lt;code&gt;Either&lt;/code&gt;&lt;/a&gt;. Опять велик? Спокойно, эта модель обладает рядом важных свойств.&lt;/p&gt;&lt;p&gt;Во-первых у него объявлены методы map и flatMap. В scala это означает, что мы можем использовать экземпляры этого класса (на самом деле trait, но как это блин по-русски сказать то?) в выражении for. Например так (это переписанный код метода login из моего давнего поста на эту же тему):&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def login&amp;#40;login: Option&amp;#91;String&amp;#93;, password: Option&amp;#91;String&amp;#93;&amp;#41;: Validation&amp;#91;String, UserInfo&amp;#93; =
  for {
    login &amp;lt;- login.toSuccess&amp;#40; &amp;quot;You should provide login&amp;quot; &amp;#41;
    password &amp;lt;- password.toSuccess&amp;#40; &amp;quot;You should provide password&amp;quot; &amp;#41;
    user &amp;lt;- findUser&amp;#40;login&amp;#41;
    checkedUser &amp;lt;- checkUser&amp;#40;user&amp;#41;
    loggedUser &amp;lt;- doLogin&amp;#40;checkedUser, login, password&amp;#41;
  } yield loggedUser
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Потратим немного времени и рассмотрим этот пример подробнее. Во-первых имеющиеся логин и пароль пользователя преобразуются из &lt;code&gt;Option&lt;/code&gt; в &lt;code&gt;Validation&lt;/code&gt; с помощью метода &lt;a href='https://github.com/scalaz/scalaz/blob/6.0.3/core/src/main/scala/scalaz/OptionW.scala#L84'&gt;&lt;code&gt;toSuccess&lt;/code&gt;&lt;/a&gt;, его реализация абсолютно очевидна. Об этой операции можно думать следующим образом: альтернатива из существующего или отсутствующего значения преобразуется в альтернативу из валидного значения или сообщения об ошибке. Во-вторых происходят вызовы методов &lt;code&gt;findUser&lt;/code&gt;, &lt;code&gt;checkUser&lt;/code&gt;, &lt;code&gt;doLogin&lt;/code&gt;. Мне не хочется тратить время на детальное их описание, будем считать что они объявлены принимающими обычные значения (не &lt;code&gt;Option&lt;/code&gt; или &lt;code&gt;Validation&lt;/code&gt;, а строки и объекты) и возвращающими &lt;code&gt;Validation&amp;#91;UserInfo, String&amp;#93;&lt;/code&gt;. То есть каждый из них принимает некоторые данные для проверки и возвращает либо информацию о прошедшем эту проверку пользователе либо сообщение о случившейся ошибке.&lt;/p&gt;&lt;p&gt;Теперь очередь магии внутри выражения &lt;code&gt;for&lt;/code&gt;. &lt;code&gt;&amp;lt;-&lt;/code&gt; в данном контексте работает как "Если у нас справа успешное вычисление связать имя слева с его результатом, если неудача - вернуть его как результат всего выражения." А &lt;code&gt;yield&lt;/code&gt; в свою очередь работает как "Если все связывания были успешны вычислить выражение и вернуть его как успех". Обратите внимание, выбор всё ещё тут, но он спрятан в способе которым выражение for комбинирует свои элементы.&lt;/p&gt;&lt;p&gt;У &lt;code&gt;Either&lt;/code&gt; методов &lt;code&gt;map&lt;/code&gt; и &lt;code&gt;flatMap&lt;/code&gt; нет, есть они только в его "проекциях" (&lt;a href='https://lampsvn.epfl.ch/trac/scala/browser/scala/tags/R_2_9_1_final/src//library/scala/Either.scala#L221'&gt;правой&lt;/a&gt; и &lt;a href='https://lampsvn.epfl.ch/trac/scala/browser/scala/tags/R_2_9_1_final/src//library/scala/Either.scala#L120'&gt;левой&lt;/a&gt;). На практике это значит, что использование &lt;code&gt;Validation&lt;/code&gt; практически постоянно экономит нам 5 символов. Сравните код выше с кодом из моего старого поста.&lt;/p&gt;&lt;p&gt;Важно понимать, что этот подход позволяет унифицировано обрабатывать целый ряд проблемных ситуаций: (а) ошибку во входных данных (отсутствие пароля), (б) собственно отказ в обработке основанный на логике (пароль не верен) и (в) ошибку во внешней службе (БД легла в момент сверки пароля). При этом код верхнего уровня даже не упоминает никакие &lt;code&gt;Failure&lt;/code&gt;, только использует &lt;code&gt;&amp;lt;-&lt;/code&gt; вместо &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Помимо приятного синтаксического сахара для сокрытия if'ов от нашего взгляда, такой подход к передаче ошибок обладает одним важным свойством - отдельные методы следующие паттерну "значения на вход - валидации на выход" могут легко объединяться вместе рядом других способов помимо &lt;code&gt;for&lt;/code&gt;. В каком-то смысле они обладают свойством замыкания. Для примера я сейчас построю простой модуль для парсинга параметров http запросов из пары десятков строк (полнофункциональная, боевая её версия около 50, но её я естественно никому не покажу :) ).&lt;/p&gt;&lt;p&gt;Пусть у нас есть класс &lt;code&gt;Req&lt;/code&gt;, несущий в себе параметры HTTP запроса в форме словаря &lt;имя параметра&gt; - &lt;список значений&gt;. Нам нужен набор функций, позволяющий типобезопасно извлекать из него параметры, при этом возможно применяя некие алгоритмы парсинга (скажем, стандартный &lt;code&gt;toInt&lt;/code&gt;). Также желательно иметь возможность извлекать необязательный параметры и наборы параметров. Интерфейс такого модуля можно описать следующим образом:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;trait ReqValidation {
  type ReqVal&amp;#91;T&amp;#93; = Validation&amp;#91;String, T&amp;#93;
  //возвращает значение параметра как есть или сообщение о его отсутствии
  def get&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;String&amp;#93;
  //возвращает необязательное значение &amp;#40;его выполнение всегда успешно&amp;#41;
  def getOpt&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;Option&amp;#91;String&amp;#93;&amp;#93;
  //возвращает целое значение или собщение об ошибке парсинга или сообщение об отсутствии параметра
  def getInt&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;Int&amp;#93;
  //возвращает небязательное целое значение или собщение об ошибке парсинга
  def getOptInt&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;Option&amp;#91;Int&amp;#93;&amp;#93;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Во-первых я ввожу новый тип для результата получения параметра. Этот тип параметризован типом успешного результата. Он является псевдонимом для &lt;code&gt;Validation&lt;/code&gt; со строкой в качестве описания неудачи и его параметром в качестве типа успешного значения.&lt;/p&gt;&lt;p&gt;Давайте последовательно реализуем каждую из этих функций, начнём с get:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def get&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;String&amp;#93; =
  req.param&amp;#40;name&amp;#41;.toOption.toSuccess&amp;#40;
    Failure&amp;#40;&amp;quot;Missed parameter &amp;quot;+name&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Она извлекает значение параметра по имени, преобразует его в стандартный &lt;code&gt;Option&lt;/code&gt;. И уже его преобразует в &lt;code&gt;Validation&lt;/code&gt; с соответствующим сообщением об ошибке. Следующим шагом будет реализация метода &lt;code&gt;getOpt&lt;/code&gt;. Его можно сделать уже совсем прямолинейным:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def getOpt&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;Option&amp;#91;String&amp;#93;&amp;#93; =
  Success&amp;#40;req.param&amp;#40;name&amp;#41;.toOption&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Реализацию второй пары методов, подразумевающих парсинг стоит начать с того, что собственно определить парсер:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def parseInt&amp;#40;s: String&amp;#41;: ReqVal&amp;#91;Int&amp;#93; =
  s.parseInt.fail.map { ne: NumberFormatException =&amp;gt;
      Filure&amp;#40;&amp;quot;Value &amp;quot;+s+&amp;quot; is not an integer&amp;quot;&amp;#41;
    }.validation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Здесь используется стандартный метод &lt;code&gt;parseInt&lt;/code&gt;, возвращающий &lt;code&gt;Either&lt;/code&gt;. При помощи метода &lt;code&gt;fail&lt;/code&gt; мы преобразуем его в &lt;a href='https://github.com/scalaz/scalaz/blob/6.0.3/core/src/main/scala/scalaz/Validation.scala#L85'&gt;&lt;code&gt;FailProjection&lt;/code&gt;&lt;/a&gt; и преобразуем исключение из стандартной библиотеки Java в читаемое сообщение об ошибке. Кагда это сделано результат преобразуется назад в обычный &lt;code&gt;Validation&lt;/code&gt;. &lt;code&gt;FailProjection&lt;/code&gt; - это специальная форма &lt;code&gt;Validation&lt;/code&gt; с инвертированной в каком-то смысле логикой: он сделан для явного манипулирования ошибкой и неявного игнорирования успешного результата.&lt;/p&gt;&lt;p&gt;А также вспомогательный метод для применения &lt;code&gt;parseInt&lt;/code&gt; и ему подобных к необязательному значению:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def parseOption&amp;#91;T&amp;#93;&amp;#40;parse: String =&amp;gt; ReqVal&amp;#91;T&amp;#93;&amp;#41;&amp;#40;opt: Option&amp;#91;String&amp;#93;&amp;#41;: ReqVal&amp;#91;Option&amp;#91;T&amp;#93;&amp;#93; =
  opt match {
    case Some&amp;#40;s&amp;#41; =&amp;gt; parse&amp;#40;s&amp;#41;.lift&amp;#91;Option, T&amp;#93;
    case None =&amp;gt; success&amp;#40;None&amp;#41;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Метод &lt;code&gt;lift&lt;/code&gt; берёт успешное значение и дополнительно заворачивает его в указанную "оболочку", в данном случае &lt;code&gt;Option&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Теперь можно написать реализацию &lt;code&gt;getInt&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def getInt&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;Int&amp;#93; =
  get&amp;#40;req, name&amp;#41; flatMap parseInt &amp;#95;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Она предельно проста. Не особо задумываясь мы можем получить и &lt;code&gt;getOptInt&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def getOptInt&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;Option&amp;#91;Int&amp;#93;&amp;#93; =
  getOpt&amp;#40;req, name&amp;#41; flatMap parseOption&amp;#40;s, parseInt &amp;#95;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Этот метод очень похож структурно на &lt;code&gt;getInt&lt;/code&gt;, практически он им и является с той поправкой, что мы трансформируем функцию парсинга для работы с необязательными значениями (продолжая следовать шаблону значение на вход - валидация на выход).&lt;/p&gt;&lt;p&gt;Итак, следуя простому паттерну значения на вход - &lt;code&gt;Validation&lt;/code&gt; на выход мы получили простой в реализации и использовании модуля для типобезопасного извлечения данных из параметров  HTTP запроса. Он может быть легко расширен как добавлением новых поддерживаемых типов (ну например пишем парсер дат какого-то формата и получаем тривиальное в реализации расширение модуля для работы с датами).&lt;/p&gt;&lt;p&gt;Он не идеален, в нём есть очевидные места дублирования (например необходимость набивать новое семейство функций &lt;code&gt;getX&lt;/code&gt;, &lt;code&gt;getOptX&lt;/code&gt; для каждого нового типа, да и от обязательности/необязательности значения кажется можно абстрагироваться), однако для затраченного количества умственных усилий мне кажется неплохо.&lt;/p&gt;&lt;p&gt;Для того, чтобы получить более правдоподобную картину давайте придумаем тестовый пример для этого модуля... Скажем запрос на поиск поста в блоге по названию (параметр запроса "text"), с опцией сортировки по дате публикации (параметр "sort") и указанием ограничения на количество результатов в ответе (параметр &lt;code&gt;limit&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;И пусть у нас уже есть метод которые делает что надо в БД и метод сериализующий список результатов для передачи по HTTP, как-то так:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;case class Post&amp;#40;...&amp;#41;
 
sealed abstract class Order
case object Asc extends Order
case object Desc extends Order
 
def searchPosts&amp;#40;text: String, order: Option&amp;#91;Sort&amp;#93;, limit: Int&amp;#41;: ReqVal&amp;#91;List&amp;#91;Post&amp;#93;&amp;#93; = {...}
 
def serialize&amp;#40;ReqVal&amp;#91;Object&amp;#93;&amp;#41;: Response = {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Давайте подумаем что нам нужно чтобы соединить вместе вышележащую библиотеку для работы с сетевым протоколом и нижележащую функцию работы с БД. Кажется почти всё есть, вот только надо научиться вытаскивать параметр сортировки... А чем порядок хуже числа?&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def parseOrder&amp;#40;value: String&amp;#41;: ReqVal&amp;#91;Order&amp;#93; =
  value match {
    case &amp;quot;asc&amp;quot;  =&amp;gt; Success&amp;#40;Asc&amp;#41;
    case &amp;quot;desc&amp;quot; =&amp;gt; Success&amp;#40;Desc&amp;#41;
    case &amp;#95;      =&amp;gt; Filure&amp;#40;&amp;quot;Illegal order value &amp;quot;+value&amp;#41;
  }
 
def getOptOrder&amp;#40;req: Req, name: String&amp;#41;: ReqVal&amp;#91;Option&amp;#91;Order&amp;#93;&amp;#93; =
  getOpt&amp;#40;req, name&amp;#41; flatMap parseOption&amp;#40;s, parseOrder &amp;#95;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;А теперь можно и написать требуемый код склейки, извлекаюий параметры из запроса и передающий их в функцию работы с БД:&lt;/p&gt;&lt;pre&gt;&lt;code class="Scala"&gt;def handleSearchPosts&amp;#40;req: Req&amp;#41;: Response =
  serialize&amp;#40;
    for {
      text  &amp;lt;- get&amp;#40;req, &amp;quot;text&amp;quot;&amp;#41;
      order &amp;lt;- getOptOrder&amp;#40;req, &amp;quot;sort&amp;quot;&amp;#41;
      limit &amp;lt;- getInt&amp;#40;req, &amp;quot;limit&amp;quot;&amp;#41;
      data  &amp;lt;- searchPosts&amp;#40;text, order, limit&amp;#41;
    } yield data
  &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Вот и всё с первой частью моего введения. Далее я покажу как с помощь всё того-же класса &lt;code&gt;Validation&lt;/code&gt; можно организовывать не только цепочки проверок до первой ошибки но и аккумуляцию нескольких возможных ошибок. Очень надеюсь, что он потребует меньшего времени.&lt;/p&gt;</description><pubDate>Tue, 08 Nov 2011 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-10-30-SO-vs-habr/</guid><link>https://cheatex.cc/posts-output/2011-10-30-SO-vs-habr/</link><title>SO и Habr - поверхностное сравнение</title><description>&lt;p&gt;Довелось недавно поучаствовать в подготовке &lt;a href='http://habrahabr.ru/blogs/programming/130830/'&gt;небольшого перевода&lt;/a&gt; на Habr и немного в его поддержке после публикации. В процессе как-то придумалось сравнение со SO. Вот смотрите:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Рейтинг. SO: единая постоянная метрика основанная на качестве контента. Habr: двухкомпонентная система: рейтинг основанный на контенте, но убывающий по времени и карма основанная на "личных качествах", постоянна по времени.&lt;/li&gt;&lt;li&gt;Право публикации. SO: постоянное и неотъемлемое. Habr: даётся по итогам попрошайничества зависит от кармы.&lt;/li&gt;&lt;li&gt;Возможность голосовать за. SO: всегда имеется. Habr: зависит от кармы.&lt;/li&gt;&lt;li&gt;Возможность голосовать против. SO: имеется всегда, но за счёт своего рейтинга. Habr: зависит от кармы.&lt;/li&gt;&lt;li&gt;Продолжительность голосования по топику. SO: не ограничена. Habr: ограничена по врмени.&lt;/li&gt;&lt;li&gt;Оценки комментариев. SO только +, незначительное влияние на рейтинг. Habr: + или -, заметное влияние на рейтинг.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Вот подумалось, вроде 6 мелочей. Но ведь очевидна "заточка" одного под аккумуляцию полезного контента, а другого под массивные срачи и популяризацию кадров вроде alizar'а.&lt;/p&gt;&lt;p&gt;PS А ещё SO хоть и не ограничивает по рейтингу возможность публикации, зато существенно ограничивает возможности по созданию энтропии. Вот я например уже давно мечтаю о 1,5к рейтинга, чтобы наконец уметь создавать новые тэги &lt;del&gt;а то на говнище, в котором я копаюсь постоянно даже тэга не находится&lt;/del&gt;.&lt;/p&gt;</description><pubDate>Sun, 30 Oct 2011 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-10-02-lift-2/</guid><link>https://cheatex.cc/posts-output/2011-10-02-lift-2/</link><title>Опыт работы с Lift: часть 2</title><description>&lt;p&gt;Продолжая начатое в прошлом посте выкладывание материалов &lt;a href='http://elegion.timepad.ru/event/10880'&gt;ScalaSPB&lt;/a&gt; расскажу ещё два занятных эпизода из своего почти годового общения с Lift. Дальше будут технические подробности и даже куски кода. Не пугайтесь совсем, дальше в серии будет больше абстракции и философии.&lt;/p&gt;&lt;h3 id="проблема&amp;#95;с&amp;#95;локализацией"&gt;Проблема с локализацией&lt;/h3&gt;&lt;p&gt;В один светлый день функционал проекта показался близок к полному а архитектура к устоявшейся. В этот день было решено провести нагрузочное тестирование, чтобы понять как скоро станет плохо, если проектом кто-то начнёт пользоваться. Идея была с энтузиазмом подхвачена и воплощена в жизнь. К сожалению результат оказался не очень радужным. Сервер, использующий отличную кэширующую БД, написанный на замечательном, масштабируемом языке и использующий топовую EC2 конфигурацию оказался способен переварить не более 20 запросов в секунду (наиболее тяжёлых из возможных надо заметить).&lt;/p&gt;&lt;p&gt;Обдумывая возвращение и прекрасного мира стартапов в кровавый энтерпрайз я начал применять все подручные средства для поиска причин такой небодрой работы сервера. Первым попавшимся тулом был munin, отчёты о загрузке CPU если конкретно. Он был весьма обнадёживающим: загрузка была около 15% на сервере и 5% на БД. После недолгой медитации на эти отчёты мне пришла гениальная идея: погрепать код на слово "synchronized". Это правда ничего не дало, но немного подняло мораль.&lt;/p&gt;&lt;p&gt;Следующим шагом стало настроить на сервере доступа к JMX и воспользоваться им для подвода информации в VisualVM. И это был частичный win. &lt;a href='https://github.com/lift/framework/blob/2.3-release/web/webkit/src/main/scala/net/liftweb/http/DefaultRoutines.scala#L53'&gt;Кусочек кода внутри Lift&lt;/a&gt; (ладно, не точно этот, в том момент использовался Lift 2.2, но его исходники кажется остались только в виде архивов) пользовался дикой популярностью среди заблокированных потоков. Собственно выбора особо не было, все обращения к S.? были заменены на свежедобавленный ResourceBundle.&lt;/p&gt;&lt;h3 id="потребление&amp;#95;памяти"&gt;Потребление памяти&lt;/h3&gt;&lt;p&gt;Ещё одним вопросом который меня долго занимал было куда сервер девает память. Дело в том, что под максимальной загрузкой он выедал все отведённые 4GB примерно за 3-4 секунды. Признаков того, что именно это ограничивало производительность не было, но любопытство не давало покоя и выкроив пару свободных часов я занялся поиском причин.&lt;/p&gt;&lt;p&gt;Для поиска я воспользовался уже послужившим добру VisualVM, точнее его профайлером памяти. Это такая замечательная штука, которая которая при каждой аллокации памяти записывает кто это сделал (ну точнее с некоторой вероятностью записывает, чтобы приложение хоть как-то могло ползать). При этом умеет агрегировать результаты в своеобразное дерево пожирателей памяти. В общем лепота.&lt;/p&gt;&lt;p&gt;Результат был достаточно предсказуем - больше половины занимали вариации append из &lt;code&gt;StringBuilder&lt;/code&gt; и скальный &lt;code&gt;::&lt;/code&gt; (конструктор списка то есть). Ещё подозрительно близко к вершине обретался некий "scala.text.DocCons", но на тот момент должное внимание ему уделено не было. Беглый осмотр самых толстых веток того самого дерева пожирателей памяти показал, что все они растут из метода &lt;a href='https://github.com/lift/framework/blob/2.3-release/core/json/src/main/scala/net/liftweb/json/JsonAST.scala#L356'&gt;JsonAST.render&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Для того чтобы понять причину пришлось проследить нелёгкий путь, который переживает объект перед тем как отправиться к клиенту в виде Json. Всё обилие вариантов представлено на картинке в &lt;a href='https://github.com/lift/framework/tree/2.3-release/core/json'&gt;документации&lt;/a&gt;. Наша ветка - от "case class" до "string". Хм... две промежуточные формы представления. Кажда требующая создание своей копии данных. (Ну не совсем своей, строки ре-используются и то не всегда - эскейпинг вынуждает посимвольно копировать строки на стрелке JSON AST -&gt; Document). Практически двухкратный оверхед.&lt;/p&gt;&lt;p&gt;Отдельно стоит рассказать про scala.text.Document, которую я тогда попутно для себя открыл. Это мини-библиотека для форматирования текста отступами. Кажется нигде, кроме как в собственных исходниках она не описана. Очень простая и компактная (&lt;a href='https://lampsvn.epfl.ch/trac/scala/browser/scala/tags/R_2_9_1_final/src//library/scala/text/Document.scala'&gt;один файл&lt;/a&gt;, 120 строк). Как ей пользоваться очевидно из исходников, если не до конца очевидно можно посмотреть на всё тот же &lt;a href='https://github.com/lift/framework/blob/2.3-release/core/json/src/main/scala/net/liftweb/json/JsonAST.scala#L356'&gt;render&lt;/a&gt;. Единственная её проблема - это выделение памяти на каждый чих, что впрочем и не удивительно - красиво форматируют обычно для людей, как следствие не гигабайтами.&lt;/p&gt;&lt;p&gt;Не буду приводить все расчёты, но у меня оказалось, что паразитные копии строк + AST из пакета scala.text были повинны примерно в 20% потребляемой памяти. Подумываю о замене всей этого хозяйства на прямое формирование строк, при случае естественно. Кроме того этот способ более не является рекомендуемым в Lift и ему предложены некоторые &lt;a href='https://github.com/lift/framework/tree/2.3-release/core/json-scalaz'&gt;альтернативы&lt;/a&gt;.&lt;/p&gt;&lt;h3 id="мораль"&gt;Мораль&lt;/h3&gt;&lt;p&gt;Для начала надо отметить, что это всё-таки не столько проблема, сколько особенность Lift'а. Он создан для поддержки AJAX-COMET сайтов, но не сервисов для массовой перекачки данных. Вывод прост: надо брать простые инструменты сквозь которые видно что происходит. Ещё полезно изучать не только тех. документацию, но и мысли авторов относительно области применения их детищ. Эту область хорошо сопоставлять со своей задачей и делать выводы.&lt;/p&gt;</description><pubDate>Sun, 02 Oct 2011 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-07-07-bridges-and-planes/</guid><link>https://cheatex.cc/posts-output/2011-07-07-bridges-and-planes/</link><title>Мосты и самолёты</title><description>&lt;p&gt;Недавно наткнулся на &lt;a href='http://elegantcode.com/2011/06/22/why-software-development-will-never-be-engineering'&gt;занятную статью&lt;/a&gt;. Основная её идея состоит в том, что разработка программ не была и никогда не будет инженерным делом. В частности автор критикует тех, кто списывает имеющиеся проблемы на молодость индустрии и возлагает надежды значительны прирост качества и надёжности ПО в будущем. В частности он обращает внимание на то, что программ за последнее время понаписали поболе, чем мостов построили за историю.&lt;/p&gt;&lt;p&gt;Мне не очень понравился аргумент. Строительство крупных сооружений на разведанной местности была одной из первых инженерных задач и решать её научились тысячи лет назад. Конструкции со сложностью в тысячи, редко десятки тысяч элементов (возможно моя оценка для мостов и неправильна, но количество ноликов явно до 6 не доходит) это самая заря технологии, как для инженерного дела "в железе" так и для разработки программ. С задачами современного программирования соизмеримы скорее проблемы проектирования автомобилей и самолётов. Давайте будем честными и прибавим к тем 600 000 мостов все модели транспортных средств хотя-бы. Не получается того-же объёма опыта, что у машиностроения, никак не получается.&lt;/p&gt;&lt;p&gt;В конце статьи есть предложение, просто заставляющее ощутить гордость за профессию и осознать разницу между программой и мостом: "Software development is about operating on a living breathing thing and all the while keeping it alive.". Но ведь вокруг помимо мостов огромное количество искусственных конструкций поражающей сложности и живучести. Вы когда нибудь смотрели в иллюминатор при посадке самолёта? Автор кажется нет :) Иначе бы он видел изгибающееся под скачущими нагрузками крыло и десятки аэродинамических элементов судорожно пытающихся отодвинуть момент сваливания ещё на десяток км/ч... Эта конструкция считается мёртвой? Или она случайно не попала в область рассмотрения?&lt;/p&gt;&lt;p&gt;Странно, что автор идёт в точности по стопам тех, кого критикует. Проводит аналогию разработки софта со старой, очень частной проблемой и доказывает её несостоятельность. Может рассматривая аналогии софтостроения с конструированием пора немного поднять планку абстракции и включить в рассмотрение какие-нибудь механизмы?&lt;/p&gt;</description><pubDate>Thu, 07 Jul 2011 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-05-05-version-control-with-git/</guid><link>https://cheatex.cc/posts-output/2011-05-05-version-control-with-git/</link><title>Version control with Git</title><description>&lt;p&gt;Эх, что-то своих мыслей давно не приходило. Ладно буду компенсировать пересказом чужих.&lt;/p&gt;&lt;p&gt;Итак, сабж - книжка о популярной в последнее время системе контроля версий, которая как-то так получилось, что завелась у меня на работе. Сразу могу сказать, что книжка однозначно рекомендуется к прочтению начинающим. Бывалым видимо тоже будет небесполезна (точно не берусь судить), так как приведённой там информации в общем то в сети и не видно.&lt;/p&gt;&lt;p&gt;Автор книги, Jon Loelinger, контрибьютор проекта Git и старательно фокусируется на его внутреннем устройстве и логике, лежащей за тем или иным поведением. Книга весьма радикально отличается по глубине изложения от свободно доступной "Pro Git" и от полупиратски попавшей ко мне "Getting good with Git" (она правда на полноту и не претендует).&lt;/p&gt;&lt;p&gt;Так вот, начинается книга (не считая установки и "первых шагов" естественно) с обзора внутреннего устройства репозитария, его элементов и их структуры. Обзор, кстати, оказывается настолько хорош, что его не приходится дополнять на протяжении почти всей книги. Далее, описывая новую операцию, автор приводит краткий обзор того, как эта операция переводится в термины внутренних структур репозитария.&lt;/p&gt;&lt;p&gt;Этот подход используется повсеместно практически во всей книге и результат по-моему просто отличный. Те места, которые выглядели сложными и запутанными после других источников делаются абсолютно прозрачными и очевидными. Весь этот ад с удалёнными репозитариями, fetch vs pull, tracking branches и т.д. становится более менее понятен или по крайней мере поддаётся освоению с точечными вычитками документации.&lt;/p&gt;&lt;p&gt;Вообще после книжки осталось стойкое ощущение, что использование Git подразумевает изучение его самого, а не того как с ним работать. Причём подразумевает на уровне самых ранних дизайнерских решений. Кстати, интересно есть-ли инструменты (наборы скриптов?..) превращающие его во что-то вроде Subversion c локально доступной историей но при этом соответственно сниженным порогом вхождения?&lt;/p&gt;&lt;p&gt;Возвращаясь к самой книге, не могу сказать, что текст сильно выделяется качеством изложения и литературностью. Однако последовательность абсолютно точна, я не могу вспомнить ни одного забегания вперёд. Примеры в конечном итоге иллюстрируют нужную функцию. По тексту немного безсистемно разбросаны важные примеры команд, значительно упрощающих жизнь, но это легко решается парой закладок. В общем ничего, что тянет на серьёзный недостаток для технической книги я не могу вспомнить.&lt;/p&gt;&lt;p&gt;P.S. С удивлением заметил, что в книжке слово developer заменяется местоимением she. Это что получается: разраб в английском по умолчанию - девочка?&lt;/p&gt;</description><pubDate>Thu, 05 May 2011 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-03-27-jcp/</guid><link>https://cheatex.cc/posts-output/2011-03-27-jcp/</link><title>Java concurrency in practice</title><description>&lt;p&gt;Собственно прочитал, наконец сабж. Книга без сомнения отличная и информации о ней в Сети достаточно, добавить особо нечего. Запишу просто пару субъективных впечатлений.&lt;/p&gt;&lt;p&gt;Книга написана просто и понятно. Материал изложен абсолютно последовательно без ссылок вперёд и с минимальным расстоянием в обратных ссылках. Автор старательно избегает обращения ко всяким примитивам синхронизации, вместо этого старается ввести набор паттернов и идиом безопасной синхронизации. Только в последней главе можно увидеть подробное изложение JMM и несколько трюков напрямую с ней связанных.&lt;/p&gt;&lt;p&gt;Из нового для себя я открыл работу с interrupt и InterruptedException а также паттерны корректной остановки выполнения заданий. Вообще тема останова и отмены задач в Java до сих пор была для меня  не изведана. Познавательно, но местами сложновато.&lt;/p&gt;&lt;p&gt;Единственный замеченный недостаток - это обилие примеров, повторяющих стандартную библиотеку. Хотя автор нигде не забывает вставить примечание, что это пример, а не рекомендуемое решение.&lt;/p&gt;&lt;p&gt;P.S. А еще ко мне приехала новая пачка книжек, в том числе "DSLs in Action" и "Version Control with Git", также на подлёте "Programming in Scala". В первую очередь навалился на Git. Очень много новой информации относительно устройства репозитария и принципов работы разных команд. По подробности изложения несравнимо с "Getting good with Git" и "Pro Git".&lt;/p&gt;</description><pubDate>Sun, 27 Mar 2011 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-03-11-on-examples/</guid><link>https://cheatex.cc/posts-output/2011-03-11-on-examples/</link><title>Об учебных примерах</title><description>&lt;p&gt; Подготовка к продолжению семинара по Java для OSLL/АУ заставила снова глубоко озадачиться построением учебных примеров на тему программирования (кстати, для кого рассказываю и какой уровень ожидается я так и не понял, с одной стороны там рассказывают какой то реальный rocket science мужики зашкаливающей суровости, с другой стороны позвали тупо меня рассказать про тупо фичи Java). Тут ещё наложился &lt;a href='https://groups.google.com/group/scala-user/browse_thread/thread/3bcb9d3d56dd83f7/'&gt;затяжной флейм&lt;/a&gt; в одной занимательной рассылке. В этой связи я решил выписать важные для меня критерии качества для учебного примера на тему программирования. Для себя точку отсчёта зафиксировать, да может ещё кому интересно будет.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Доступность. Пример должен быть доступен для понимания с минимумом затрат. Требования к теоретическим познаниям должны быть собраны в явные prequisities. Когда в середине, а то и в примечаниях в конце говорят "Так, а вот тут вам нужно (было) прочитать [1], [2], [3] и вот тот учебник." - материал идёт лесом.&lt;/li&gt;&lt;li&gt;Сфокусированность. В рамках примера должна решаться одна и только одна задача. Если проблема состоит в комбинировании нескольких решений, то мы сначала делаем каждое решение, потом отдельным пунктом пробуем их сочетать (не до маразма естественно - пример на абстракцию данных с полярной и декартовой точкой без предварительного отдельного их описания вполне допустим).&lt;/li&gt;&lt;li&gt;Простота. В примере должно так мало сущностей, как это возможно. Очень плохо, когда появляются примеры вроде: "Мы реализуем подсистему логирования с помощью аспектно-ориентированного программирования, но ещё нам потребуется IoC контейнер для включения аспектов".&lt;/li&gt;&lt;li&gt;Изолированность. Пример должен задействовать минимальное количество (в идеале одну) фичей языка и/или техник программирования. Если речь идёт о каком-то последовательном изложении (например введении в ЯП) совершенно недопустимы ссылки вперёд. Граница с пунктом 2 не очень чёткая. Я их разделяю так: простота связана с требованиями к окружению (например "мы внутри IoC контейнера" или "у нас есть парсер JSON"), изолированность связана с инструментарием, привлекаемым непосредственно к решению задачи (например "мы используем обобщённые типы" или "мы используем механизм макросов").&lt;/li&gt;&lt;li&gt;Реалистичность. читатель не должен проводить бессонные ночи ищя ответ на вопрос "зачем?". Знание, не подкреплённое практикой или хорошей идеей как эту практику можно устроить, быстро теряется и затирается чем нибудь более актуальным. Чисто эмпирически мне кажется, что пример должен попадать в одну из следующих категорий:&lt;ol&gt;&lt;li&gt;Часть большего и жизненного примера (например "мы пишем графический редактор и нам нужна унифицированная обработка фигур" - "нас спасёт паттерн композит").&lt;/li&gt;&lt;li&gt;Какое-то решение общей проблемы программирования ("нам нужно абстрагировать вычисление расстояния между точками от представления их в памяти") с которой гарантированно сталкивался каждый.&lt;/li&gt;&lt;li&gt;Общеупотребимый алгоритмом или структура данных (например "решение комбинаторной задачи" или "представление графа в памяти").&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Масштабируемость. В идеале пример должен быть доведён до конца в несколько итераций, с целью показать несколько доступных уровней глубины. От простого (задача едва-едва решена) и узкого решения к более сложному (максимальному проходящему по критериям 2 и 3) и полному. Соответственно и при практическом применении рассматриваемого инструмента остаётся возможность подвигать ползунок.&lt;/li&gt;&lt;li&gt;Содержательность. Что-то вроде возможности ответить на вопрос "зачем?" на самом высоком уровне. Пробовал сформулировать по разному, но кажется как не крути получается критерий-солянка:&lt;ol&gt;&lt;li&gt;Не велик. Плохо когда что-то делается, а в конце говорится "на самом деле взрослые дяди это уже решили в стандартной библиотеке и лучше пользоваться их решением". Оставляет смешанное чувство собственной убогости ("действительно годное решение мне не понять?") и низкого качества материала ("то есть то же самое можно сделать лучше?"). Но это всё-равно лучше, чем когда такого примечания нет :)&lt;/li&gt;&lt;li&gt;Связь с каким-то юзкейсом верхнего уровня (очевидно что 6. а) избавляет от этой проблемы в принципе).&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Надо заметить, что это касается технических материалов для практиков. Научные статьи и обзоры по понятным причинам в эту шкалу не вписываются. А те люди которые легко переживают отсутствие таких примеров без сомнения должны бросать неблагодарное инженерное дело и релоцироваться в класс учёных. С другой стороны я недавно видел пример того, что в умелых руках даже казалось бы безнадёжно сложные и теоретизированные вопросы находят прекрасную иллюстративную основу, для сравнения: куча введений в продолжения от скалохаскелистов &lt;a href='http://dcsobral.blogspot.com/2009/07/delimited-continuations-explained-in.html'&gt;&amp;#91;1&amp;#93;&lt;/a&gt;, &lt;a href='http://jim-mcbeath.blogspot.com/2010/08/delimited-continuations.html'&gt;&amp;#91;2&amp;#93;&lt;/a&gt;, &lt;a href='http://suereth.blogspot.com/2010/03/how-you-should-think-about-delimited.html'&gt;&amp;#91;3&amp;#93;&lt;/a&gt; и &lt;a href='http://www.dabeaz.com/coroutines/'&gt;одно от питонщика&lt;/a&gt;.&lt;/p&gt;</description><pubDate>Fri, 11 Mar 2011 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-02-16-sicp/</guid><link>https://cheatex.cc/posts-output/2011-02-16-sicp/</link><title>Структура и интерпретация компьютерных программ</title><description>&lt;p&gt;Вот я наконец и дочитал эту замечательную книгу. Ну точнее постановил считать её дочитанной, так как предпоследняя глава растянулась чуть ли не на полгода, а последняя обещала и того дольше.&lt;/p&gt;&lt;p&gt;Процесс и правда изрядно затянулся. Я начал её читать ещё в сентябре позапрошлого (2009) года. И вот только пара недель как закончил. Причина очень проста: книга явно требует подходящего настроения и регулярно читать не получалось хронически. Процесс и сам по себе получился не обычным. Я начал её читать с экрана, в виде английской pdf'ки. Однако, когда я был где-то на середине вышел &lt;a href='http://www.books.ru/shop/books/751828'&gt;очередной тираж&lt;/a&gt; русского издания и я без раздумий добыл себе бумажный экземпляр на русском.&lt;/p&gt;&lt;p&gt;И наверно единственный раз не пожалел, что связался с русским переводом. Надо отдать должное переводчикам - это один из лучших технических переводов, что я видел. И без сомнения наиболее качественный из выпущенного в последние годы. Очень тщательный, последовательный подход к терминологии. Авторы всегда дают оригинальное написание вводя новый термин, но далее в книге используют один и тот же русский вариант. Нет ни диких транслитераций, ни странных оборотов в три слова. Я практически прозрачно переключился с английской версии на русскую.&lt;/p&gt;&lt;p&gt;Ещё важный момент, все примеры в книге выполнены на LISPе (а точнее Scheme). Годика три назад, я наверно по этой причине сделал бы из книжки костер и сплясал бы вокруг него. Однако изучение Smalltalk и Python (а точнее отзывов их авторов о влиянии LISP) в последствии немного сгладили мое отношение к скобочкам. Нельзя не признать, что для первых глав, где демонстрируется куча разных подходов к программированию, он является пожалуй оптимальным выбором. Однако длинные куски кода на LISPе всё-таки страшно выглядят, понимание многих примеров из последних глав отнимало много времени, в основном на вычленение стандартных конструкций из мета-кодировки в скобках.&lt;/p&gt;&lt;p&gt;Итак, о чём же собственно книга.&lt;/p&gt;&lt;p&gt;Первая глава, "Построение абстракций с помощью процедур", рассказывает о базовых техниках функционального программирования. В ней вводятся понятие процедуры, её вычисления, объясняется семантика лямбда-исчисления. Также тут рассматриваются "формы" вычислительных процессов, и то какие потребности в памяти и процессорном времени они порождают. В конце показываются функции высокого порядка и лямбда-выражения, с примерами применения.&lt;/p&gt;&lt;p&gt;Вторая глава, "Построение абстракций с помощью данных", рассказывает о том, что такое данные, как их можно унифицировать (на уровне доступа) с процедурами и почему это бывает важно. Попутно вводится понятие структуры данных и рассматриваются примеры, вроде пар, списков и т.п. Описывается свойство замкнутости для структур данных (программ?), и демонстрируется его важность в дизайне программ. Заканчивается глава по сути кратким введением в ООП, а точнее подробным рассмотрением идеи программирования в "стиле передачи сообщений". Показываются ЛИСПовые техники реализации классов, объектов, методов. Последнее без сомнения лучшее введение в ОО-программирование из всех что я видел. В основном благодаря тому, что мир объектов и сообщений строится вместе с читателем, а не приводится как данность (тут я немного забежал вперёд - достраивается он уже в следующей главе).&lt;/p&gt;&lt;p&gt;Третья глава, "Модульность, объекты и состояние", вводит в стройный мир асбтрактных вычислений, выстроенный в первых главах, проблемы реального мира: присваивание и время. Примерно половина главы посвящена тому как эти явления аккуратно моделировать в языке программирования, и примерно половина конкретным техникам программирования. В этой главе особо порадовал раздел про потоки, который был прочитан с учётом возвратов из следующей главы и перелистываний на досуге раза три. Совершенно замечательный пример простого решения массы сложных проблем, настоятельно рекомендую для прочтения, даже если за всю книгу лень браться.&lt;/p&gt;&lt;p&gt;Четвёртая глава, с жутким названием "Метаязыковая абстракция", посвящена созданию интерпретаторов языков программирования. В ней сначала подробно расписывается архитектура и реализация интерпретатора самой Scheme, а затем вносится в него ряд изменений, для поддержки экзотических методов программирования. Меня, в контексте аспирантуры, конечно больше всего заинтересовал логический интерпретатор (пролог в скобочном синтаксисе), который наверно единственный я более-менее до конца понял.&lt;/p&gt;&lt;p&gt;Ну и на пятую главу, "Вычисления на регистровых машинах", я забил :)&lt;/p&gt;&lt;p&gt;Надо отметить, что книга доставила массу удовольствия в процессе прочтения. Нельзя сказать, что всё написанное там было для меня откровением, но этот материал копился у меня в голове годами, из обрывков статей, блогпостов и собственного печального опыта... В общем стоило ей попасть мне в руки курсе на четвёртом.&lt;/p&gt;&lt;p&gt;Вообще книга заставила много раз подряд проклясть родной универ. Всё-таки способность отечественных преподавателей сделать из даже самых интересных и полезных знаний невнятную, серую, трудноперевариваемую массу просто поражает. Вспомнился и курс функционального программирования, двухмесячный, с быстрым рассмотрением синтаксиса и стандартных функций, какого-то древнего ДОСовского ЛИСПА, увенчанный курсовиком, в котором нужно было сделать базу данных то ли студентов на кафедре, то ли телевизоров на складе. Курс, на котором понятие неизменяемой структуры данных даже не звучало, не говоря уже про то, чтобы объяснить выученному на паскале потоку как с ними работать. И курс объектно-ориентированного программирования, без единого упоминания о передаче сообщений.&lt;/p&gt;&lt;p&gt;Ну да ладно, напоследок, по традиции, критическое замечание к сабжу. В последних главах очень мало диаграмм к сложным примерам кода. Хорошее именование и форматирование это конечно хорошо. Но всё-таки картинки - лучший способ доносить архитектуру до умственно не далёких читателей вроде меня.&lt;/p&gt;</description><pubDate>Wed, 16 Feb 2011 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-01-27-refactoring-excercise/</guid><link>https://cheatex.cc/posts-output/2011-01-27-refactoring-excercise/</link><title>Немного поупражнялся в рефакторинге</title><description>&lt;p&gt;Пару дней назад увидел &lt;a href='http://eao197.blogspot.com/2011/01/progflame-scala.html'&gt;пост на крайне актуальную тему&lt;/a&gt; в одном занимательном блоге. Суть: автор увидел кусок говнокода на Scala, переписал в цивильном виде, сделал аналог переписанного на Java и сравнил. По итогам сомнения он пришёл к выводу что разница в 30 строк кода из 100 не существенна для выбора языка, а идейной разницы никакой нет.&lt;/p&gt;&lt;p&gt;Надо сказать, что пост задел практически за живое, ибо совсем недавно я занимался валидацией запросов и авторизацией пользователей как раз на Scala :) Так что что мне сразу бросилась в глаза пара некорректных мест в сравнении, которые я и попробую дальше подробно описать.&lt;/p&gt;&lt;p&gt;Во-первых, утверждается, что два текста программ, приводимых в конце, одинаковы. И один имеет не лучшую надёжность, чем другой. Это просто не верно. Дело в том, что несмотря на очень похожую структуру Scala-код имеет на несколько порядков большую "защиту от дурака". Для обеспечения сравнимого уровня пассивной защиты от ошибок на Java требовалось-бы написать как-то так:&lt;/p&gt;&lt;pre&gt;&lt;code class="scala"&gt;@rest.Method&amp;#40;httpMethod = Array&amp;#40;POST&amp;#41;&amp;#41; 
public void login&amp;#40;final rest.Request request, 
      @rest.Param&amp;#40;name = &amp;quot;login&amp;quot;&amp;#41; @Nullable final String login, 
      @rest.Param&amp;#40;name = &amp;quot;password&amp;quot;&amp;#41; @Nullable final String password&amp;#41; 
{ 
   debug&amp;#40;&amp;quot;accessing login... &amp;quot; + login&amp;#41;; 
 
   if&amp;#40; login == null || password == null &amp;#41; 
      respond&amp;#40;UNAUTHORIZED, &amp;quot;You should provide login and password&amp;quot;&amp;#41;; 
   else
      doLogin&amp;#40;request, login, password&amp;#41;; 
} 
 
private void doLogin&amp;#40;@NotNull final rest.Request request, @NotNull final String login, @NotNull final String password&amp;#41; 
{ 
   final UserInfo user = AccountsStorage.find&amp;#40;login&amp;#41;; 
   if&amp;#40; user == null &amp;#41; 
      handleUnknownUserLogin&amp;#40;&amp;#41;; 
   else
      &amp;#40;new KnownUserLoginHandler&amp;#40;request, login, password, user&amp;#41;&amp;#41;.handle&amp;#40;&amp;#41;; 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;И прикрутить сверху проверку статическим анализатором кода. Говорить о читабельности кода после такого преобразования не приходится.&lt;/p&gt;&lt;p&gt;Во-вторых приводится аргумент, что разработчик, с учётом возможностей современных IDE будет руками писать кода Java ничуть не больше(Справедливости ради стоит заметить, что скорее всего даже меньше). Аргумент не очень хороший, в контексте того что код ведь обычно не столько пишут, сколько читают. У меня на строку написанного кода приходится минимум сотня прочитанного, и с пять сотен бегло просмотренного. Во время работы каждый программист возвращается к ранее сделанному много раз и шум вроде повторения списка аттрибутов класс четыре раза в разных обрамлениях мягко говоря не помогает понять свою или чужую мысль.&lt;/p&gt;&lt;p&gt;В-третьих, в примере используется внешняя библиотека (для работы с http судя по всему) совершенно не приспособленная к языку и не использующая его возможностей. Как на образец удачной, основанной на полноценном использовании языка библиотеки можно посмотреть например на Circumflex Web Framework.&lt;/p&gt;&lt;p&gt;Ну и в-четвёртых собственно выразительные возможности скалы используется крайне скупо и внутри самого решения. Естественно, что если писать в точности как на Java то и никаких отличий не обнаружится. В доказательство этого утверждения я попробую решить эту-же задачу в немного более скальном стиле.&lt;/p&gt;&lt;p&gt;Итак, что мне не нравится в предложенном решении и что я собираюсь улучшить:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Сквозная связанность всего кода авторизации с классами внешней библиотеки. Не то чтобы переезды целых приложений с одного фреймворка на другой являются обычным делом, но когда они всё-таки происходят...&lt;/li&gt;&lt;li&gt;Весь алгоритм по сути выполняет простой выбор: авторизовать пользователя или выдать сообщение о том, почему в авторизации отказано. В предложенном решении для того чтобы это понять требуется отсмотреть всю сотню строк кода, а исключить другие (ошибочные) варианты реакции весьма затруднительно.&lt;/li&gt;&lt;li&gt;Сам алгоритм авторизации имеет преимущественно линейную структуру:&lt;ul&gt;&lt;li&gt;проверить, что логин и пароль предоставлены;&lt;/li&gt;&lt;li&gt;найти соответствующие учётные данные в БД;&lt;/li&gt;&lt;li&gt;проверить, что пользователь имеет право на вход;&lt;/li&gt;&lt;li&gt;аутентифицировать по паролю.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Несмотря на это код с самого начала начинает ветвиться, полностью скрывая основную идею.&lt;/p&gt;&lt;p&gt;Приступим. Вся процедура авторизации имеет своим результатом или учётные данные авторизованного пользователя, или сообщение об ошибке. Так и запишем:&lt;/p&gt;&lt;pre&gt;&lt;code class="scala"&gt;type LoginResult = Either&amp;#91;UserInfo, String&amp;#93;
def Success&amp;#91;T, E&amp;#93; = Left&amp;#91;T, E&amp;#93; &amp;#95;
def Failure&amp;#91;T, E&amp;#93; = Right&amp;#91;T, E&amp;#93; &amp;#95;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Сама процедура логина получает возможно предоставленные данные, и возвращает описанный выше результат:&lt;/p&gt;&lt;pre&gt;&lt;code class="scala"&gt;def login&amp;#40;login: Option&amp;#91;String&amp;#93;, password: Option&amp;#91;String&amp;#93;&amp;#41;: LoginResult = ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Теперь можно отвлечься от деталей процедуры логина и заняться обработкой результатов&lt;/p&gt;&lt;pre&gt;&lt;code class="scala"&gt;@rest.Method&amp;#40;httpMethod = Array&amp;#40;POST&amp;#41;&amp;#41;
def login&amp;#40;request: rest.Request,
    @rest.Param&amp;#40;name = &amp;quot;login&amp;quot;&amp;#41;
    loginParam: String,
    @rest.Param&amp;#40;name = &amp;quot;password&amp;quot;&amp;#41;
    passwordParam: String&amp;#41;: Unit =
  login&amp;#40;Option&amp;#40;loginParam&amp;#41;, Option&amp;#40;passwordParam&amp;#41;&amp;#41; match {
    case Left&amp;#40;user&amp;#41; =&amp;gt;
      request.session&amp;#40;&amp;quot;user&amp;quot;&amp;#41; = user
    case Right&amp;#40;message&amp;#41; =&amp;gt;
      respond&amp;#40;UNAUTHORIZED, message&amp;#41;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Здесь важно во-первых что количество вариантов внешней реакции системы явно ограничивается. Во вторых, что на этом уровне заканчиваются все связи с фреймворком, включая возможные null'ы в параметрах вызова (именно по этому я не стал делать процедуры, аналогичной setupSuccessfulAuthResult - она просто не создавала бы никакой полезной абстракции).&lt;/p&gt;&lt;p&gt;Дальше хочется заняться собственно процедурой логина, но стоит снова оставить её в стороне и описать все шаги авторизации. Очевидно, что каждый из шагов будет иметь то-же результат, что и процедура логина в целом, однако будет требовать разных данных на вход. Можно записать каждый шаг в виде отдельной функции:&lt;/p&gt;&lt;pre&gt;&lt;code class="scala"&gt;def findUser&amp;#40;login: String&amp;#41;: LoginResult =
  AccountsStorage.find&amp;#40;login&amp;#41;.toLeft&amp;#40; &amp;quot;User not found&amp;quot; &amp;#41;
 
def checkUser&amp;#40;user: UserInfo&amp;#41;: LoginResult =
  if &amp;#40;user.inactive&amp;#41; Failure&amp;#40;&amp;quot;Account is inactive&amp;quot;&amp;#41;
  else Success&amp;#40;user&amp;#41;
 
def doLogin&amp;#40;user: UserInfo, login: String, password: String&amp;#41;: LoginResult =
  if &amp;#40;user.authScheme == &amp;quot;PETRIVKA&amp;quot;&amp;#41;
    handlePetrivkaAuthSchemeLogin&amp;#40;user, password&amp;#41;
  else
    handleUsualAuthSchemeLogin&amp;#40;user, login, password&amp;#41;
 
def handlePetrivkaAuthSchemeLogin&amp;#40;user: UserInfo, password: String&amp;#41;: LoginResult =
  if&amp;#40; user.passwordMatches&amp;#40;password&amp;#41; &amp;#41; Success&amp;#40;user&amp;#41;
  else Failure&amp;#40;&amp;quot;Authentication failed&amp;quot;&amp;#41;
 
def handleUsualAuthSchemeLogin&amp;#40;user: UserInfo, login: String, password: String&amp;#41; =
  AccessStorage.access.auth&amp;#95;configs.find&amp;#40;&amp;#95;.key == user.authScheme&amp;#41; match {
    case Some&amp;#40;scheme&amp;#41; =&amp;gt;
      log.debug&amp;#40;&amp;quot;authenticating with &amp;quot; + scheme.command&amp;#41;
      val exec = Runtime.getRuntime.exec&amp;#40;
          scheme.command replace&amp;#40;&amp;quot;{login}&amp;quot;, login&amp;#41; replace&amp;#40;&amp;quot;{password}&amp;quot;, password&amp;#41;&amp;#41;
      if&amp;#40; exec.waitFor == 0 &amp;#41;
        Success&amp;#40;user&amp;#41;
      else
        Failure&amp;#40;&amp;quot;Authentication within &amp;quot; + scheme + &amp;quot; failed&amp;quot;&amp;#41;
    case None =&amp;gt; Failure&amp;#40;&amp;quot;Unknown authentication scheme: &amp;quot; + user.authScheme&amp;#41;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Если немного помедитировать на handleUsualAuthSchemeLogin, то наверняка можно её сократить и упростить, но это мало повлияет на основную идею решения.&lt;/p&gt;&lt;p&gt;Теперь осталось самое простое - собрать все шаги вместе. Совершенно случайно в Scala завалялась подходящая конструкция :)&lt;/p&gt;&lt;pre&gt;&lt;code class="scala"&gt;def login&amp;#40;login: Option&amp;#91;String&amp;#93;, password: Option&amp;#91;String&amp;#93;&amp;#41;: LoginResult =
  for &amp;#40;login &amp;lt;- login.toLeft&amp;#40; &amp;quot;You should provide login&amp;quot; &amp;#41;.left;
       password &amp;lt;- password.toLeft&amp;#40; &amp;quot;You should provide password&amp;quot; &amp;#41;.left;
       user &amp;lt;- findUser&amp;#40;login&amp;#41;.left;
       checkedUser &amp;lt;- checkUser&amp;#40;user&amp;#41;.left;
       loggedUser &amp;lt;- doLogin&amp;#40;checkedUser, login, password&amp;#41;.left
  &amp;#41; yield loggedUser
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Не вдаваясь в детали, скажу что выражение for делает очередной шаг и проверяет результат: если он успешен то продолжает цепочку, если неуспешен то прерывает цепочку, возвращая неудачу. То какой вариант сейчас считается успешным мы сообщаем в конце каждого выражения, я соответственно всегда считаю успешным левый. Метод toLeft у класса Option преобразует его в Either, говоря куда помещать существующее значение и чем заменять несуществующее.&lt;/p&gt;&lt;p&gt;Вот и всё. Данный пример исправляет отмеченные ранее недостатки, при этом имеет более простую (7 элементов против 9) и близкую к задаче структуру. Также стоит добавть, что он имеет и существенный недостаток: двойную терминологию. В одних местах используется пара Success-Failure, в других Left-Right. Однако это имеет и положительный эффект - интерпретация результатов всегда отличима от их создания.&lt;/p&gt;&lt;p&gt;&lt;a href='https://gist.github.com/CheatEx/2a76c06b3bf5480e62708161a6957b05'&gt;полный исходник с кое-какими моками для компилябельности&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 27 Jan 2011 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2011-01-13-java-seminar/</guid><link>https://cheatex.cc/posts-output/2011-01-13-java-seminar/</link><title>Провёл семинар по Java</title><description>&lt;p&gt; В начале декабря проводил семинар для пары студентов из &lt;a href='http://osll.spb.ru/'&gt;OSLL&lt;/a&gt; про Java. Так как народ в основном ковыряет железки больше что-то не нашлось кому рассказать у них про Java. Вот я и вызвался. Ораторские неспособности потренировать, да для себя какой-нибудь забавный фактик отрыть.&lt;/p&gt;&lt;p&gt;Идея провести семинар (точнее взяться наконец и провести, ибо тема семинара уже давно в их виш-листе висела) пришла ко мне давно. Соответственно кое какие мысленные подготовительные этапы я прошёл. Хотелось поменьше рассказать про язык (до него благо хоть от ++ хоть от # полшага сделать) и по больше про виртуальную машину, библиотеки, то что Sun при жизни именовал экосистемой.&lt;/p&gt;&lt;p&gt;Наученный горьким опытом недавней подготовки лекции про RDF для &lt;a href='http://ailab.ifmo.ru/index.php/ru/events/4-seminars/11-swschool'&gt;семинаров лаборатории&lt;/a&gt; (там была масса "ощущений" и последующих выводов, надо бы тоже отписаться) я начал готовиться за 3 недели. Сел, бодро накидал план в 4 пункта:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Устройство платформы. Ну понятно VM, байт-код, компилятор, библиотеки.&lt;/li&gt;&lt;li&gt;Пример простой программы. Тут помимо куска кода хотелось ещё скомпилировать и потом рассмотреть декомпилятором что получилось. Основная цель - изгнать из сознания слушателей мысли о волшебстве в байт-коде и работе JVM.&lt;/li&gt;&lt;li&gt;Обзор языка. Быстро, чтобы только понять о чём речь. Класы, интерфейсы, методы и атрибуты, примитивные типы.&lt;/li&gt;&lt;li&gt;Собственно обзор "мира". Библиотеки, фреймворки, ну и моё маленькое увлечение - другие языки.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Первый и второй пункты написал быстро, вечера за три. Дальше стало резко хуже. Когда что-то используешь особо не задумываешься. Но когда надо заключить это в текстом и потом рассказать свежему человеку понимаешь насколько там на самом дохрена всего. Чуть больше года назад я писал небольшую вводную &lt;a href='http://habrahabr.ru/blogs/programming/77750/'&gt;статья о Scala&lt;/a&gt; на хабр, там было и правда легко - язык я знал чуть, "особых случаев" там поменьше, да и в глаза они особо не бросались. А в Java ведь так и не знаешь с какого конца браться. "Пишем в класса public static void main" - какой класс? Откуда он взялся? Откуда не начни приходишь к класслоадерам и мониторам. Ладно, кое как разложил, упорядочил, докинул в начальный план дженериков, а то как-то совсем убого выглядела старушка.&lt;/p&gt;&lt;p&gt;Ещё был неприятный вопрос с примерами. С одной стороны рассказывать о конструкциях языка махая в воздухе руками как-то странно. С другой стороны пространные синтаксические конструкции не располагают к выписыванию и запоминанию. Кроме того привод пример программы надо как-то объяснять что она делает. В общем покрутив и так и сяк план, понял, что стоит вернуться к классической схеме. А именно сначала описание языка и синтаксических конструкций с кусочками кода (как ни старался не получается их делать содержательными). Потом пример, декомпиляция. В итоге 2 и 3 пункт поменялись местами.&lt;/p&gt;&lt;p&gt;К моему великому сожалению часть про язык всё-таки разрослась на большую часть семинара, зато получилось почти полноценно: рассказал про классы и интерфейсы, модель наследования и перегрузки, простые случаи дженериков, конструкторы и инициализаторы, статические члены классов и интерфейсов.&lt;/p&gt;&lt;p&gt;Последним кусочком был обзор мира, начальный план был обширен:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Бибилиотеки/фреймворки&lt;ul&gt;&lt;li&gt;JEE&lt;/li&gt;&lt;li&gt;Spring&lt;/li&gt;&lt;li&gt;Apache-commons&lt;/li&gt;&lt;li&gt;OSGi&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Инструменты&lt;ul&gt;&lt;li&gt;Ant&lt;/li&gt;&lt;li&gt;Maven&lt;/li&gt;&lt;li&gt;IDEs (Eclipse, IDEA, Neteans)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Языки&lt;ul&gt;&lt;li&gt;Groovy&lt;/li&gt;&lt;li&gt;Scala&lt;/li&gt;&lt;li&gt;Clojure&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Правда в процессе подготовки быстро стало понятно, что в регламент времени с такой программой вписаться без шансов. В результате пошли под но OSGi и все инструменты кроме IDEs.&lt;/p&gt;&lt;p&gt;Ну затем и пришёл день события. Из человек 6 отписавшихся о желании слушать по факту пришло 2 :) Я про себя от души посмеялся, но всё-таки количество народу полностью развязало мне руки в плане скорости изложения и объёма. Надо заметить, что оба имели хорошую вводную по Java и кажется уже изрядно программировали на ++. Так что я как мог навалился на рассказ про архитектуру платформы. Язык прошёл легко, большая часть вещей была народу знкома, действуя по ситуации, я пару раз заворачивал вглубь: немного сказал про ограничения в дженериках(&lt;T extends Iterable&gt;) и анонимные классы. Явный промах был только в части обзоров. Уже в процессе я понял, что идея рассказывать про библиотеки без юзкейсов и примеров кода - порочна по определению. Однако даже этот кусочек не совсем пропал - идея Inversion of control кажется всё-таки нашла понимание в массах. Ну и естественно я как мог с запалом рассказал про Groovy и Scala, перечислил длинный список плюшек. По Groovy набросал примеров на поиски и выборки из коллекций. Из Scala привёл пример quicksort а-ля Haskell (поставил я тут, кстати, эксперимент на сортировку 1 000 000 интов - всего в три раза медленнее нативного на массивах, кажется в Швейцарских университетах практикуют чёрную магию). Ну и вычисление ряда Фибоначи на скобочках естественно =)&lt;/p&gt;&lt;p&gt;Ну и напоследок я спросил нужно ли продолжение и ответ был положительным. Так что постараюсь по весне сделать либо что-то поглубже про Java (это если Блох приедет и успею прочитать) либо (что привлекает больше и будет иметь больше практического фундамента к тому времени) краткое введение в Groovy и Scala. Ибо как говорит один английский профессор - "лучший способ разобраться в чём-нибудь - прочитать по этому курс".&lt;/p&gt;&lt;p&gt;PS вот моя недопрезентация к семинару, в основном весёлые картинки: &lt;a href='http://dl.dropbox.com/u/1776995/pres.pdf'&gt;http://dl.dropbox.com/u/1776995/pres.pdf&lt;/a&gt;&lt;/p&gt;</description><pubDate>Thu, 13 Jan 2011 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2010-12-25-masterminds-of-programming/</guid><link>https://cheatex.cc/posts-output/2010-12-25-masterminds-of-programming/</link><title>Пионеры программирования</title><description>&lt;p&gt;Дочитал наконец купленную ещё в сентябре книгу "Пионеры программирования". Это перевод вышедшей около полутора лет назад на английском "Masterminds of Programming". Формат её довольно занятен - это сборник интервью с авторами некоторых языков программирования. Да, английский вариант названия более корректен - пионерами мало кого из участников можно назвать.&lt;/p&gt;&lt;p&gt;Интервью сильно различаются между собой. Кто-то предаётся воспоминаниям, кто-то рассказывает практически о всей своей карьере, кто-то с увлечением рассказывает о планах (проработать 30 лет в этой богом проклятой отрасли и сохранить надежду на что-то - это по-моему подвиг). Многие философствуют на тему судьбы информатики и языков программирования... Журналисты аккуратно корректирую тему, в целом не могу оценить их работу ни как очень хорошую, ни как очень плохую. Наверно это как раз то впечатление, которое они хотели оставить. Мне как юному инженеру естественно в первую очередь были интересны рассказы о проектировании и реализации языков. Хотя что-то и на философские рассуждения я что-то становлюсь с годами падок. Тем более что технари умеют при случае сопроводить их логикой и результатами безжалостных экспериментов.&lt;/p&gt;&lt;p&gt;Всего в книге 26 интервью о 17 языках. Для порядка расскажу о некоторых наиболее запомнившихся.&lt;/p&gt;&lt;p&gt;Начинается книга с интервью Бьёрна Страуструпа. Надо сказать, я что не очень люблю C++, последнее время можно даже сказать активно не люблю. Но он всё-таки автор мастер обоснования, к концу главы я абсолютно чётко понимал что именно таким язык должен быть и иначе никак. На самом деле дядька вызывает уважение упорством и бесконечной изобретательностью в решении проблем. Из философии у него ряд интересных мыслей о проблемах образования. Большинство инженеров готовят как учёных. Оказывается дипломник, который впервые видит настоящего коллегу-программиста и живой проект обычное дело не только у нас.&lt;/p&gt;&lt;p&gt;Неожиданно мне очень понравилось интервью Чака Мура, автора Forth (вообще не представляю как он выглядит). Затрудняюсь выделить какие-то особые его мысли. Просто странное совпадение мироощущения, профессиональных приоритетов с моими собственными. Идея о важности глубокой модульности программ и близости их компонентов к мыслительным образам... В общем советую читать.&lt;/p&gt;&lt;p&gt;Великолепные интервью с Альфредом Ахо (да да да, это он!), Питером Вайнбергером и Брайаном Керниганом. Книгу стоит покупать хотя бы ради этой главы. Совершенно потрясающие мысли о проблемах дизайна и проектирования, способах их решения. Лаборатория, в которой собрались все эти люди без сомнения должна была была изменить мир. Ничего не берусь пересказывать - читайте и перечитывайте. А, ну да, поводом для их опроса был AWK (дал одному коллеге почитать отрывочек так он сразу бросился его учить).&lt;/p&gt;&lt;p&gt;Ещё однозначно стоит упомянуть Брэда Кокса, одного из авторов Objective-C. Судя по поднимаемым им проблемам, он, в отличии от большинства опрашиваемых, годы после создания своего языка провёл не в уютной исследовательской лаборатории, а в самой гуще кровавого безумия энтерпрайза. Кажется как архитектор и немного менеджер. Он отмечает целый ряд грустных вещей в отрасли и как может предлагает решения. Во-первых это глубокое непонимание между академическими и промышленными организациями, отсутствие фундаментального решения насущных проблем и усердные раскопки в экзотических областях. Говорит он и о том, что разработка даже очень больших систем в даже очень серьёзных компаниях продолжает оставаться делом полукустарным. Отсутствует технология, отсутствуют доверие и как следствие глубокое разделение обязанностей. Ситуация, когда одни и те-же компании при создании продуктов занимаются всем от архитектуры процессора до формочек остаётся нормой. Кокс приводит замечательную аналогию с древними строителями, которые сами добывали глину и жгли кирпичи. Ведь и правда бегают архитекторы с мастерками!&lt;/p&gt;&lt;p&gt;Можно немного повинить авторов за то, что в книгу не попали по крайней мере три языка и человека, о которых очень хотелось бы услышать. Это Джон Мак Карти, автор LISP, языка до сих пор вызывающего бури эмоций как у стариков, так и у третьекурсников. Это Никлаус Вирт, пожалуй единственный человек сужающий, а не расширяющий языки. Ну и Дениса Ритчи тоже можно было привлечь, всё-таки популярнейший язык.&lt;/p&gt;&lt;p&gt;Не берусь подводить итог прочитанному - очень много различных взглядов не только на методы работы но и саму природу проблемы разработки языка да и программирования вообще. Но могу однозначно сказать что её прочтение стоит потраченного времени. А то и многократно окупается если вы также любите сложные задачи и красивые решения.&lt;/p&gt;</description><pubDate>Sat, 25 Dec 2010 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2010-07-12-complexity-vs-duplication/</guid><link>https://cheatex.cc/posts-output/2010-07-12-complexity-vs-duplication/</link><title>Сложность vs дублирование</title><description>&lt;p&gt;Предпоследняя моя задачка в GGA была весьма символичной.&lt;/p&gt;&lt;p&gt;Краткое описание проблемы. Есть около года кодируемая форма в духе treetable. Работа с данными организована следующим образом: с сервера приходят какие-то структуры, они конвертируются во что-то типа встраиваемой RDB и она подкладывается как модель этой форме. Это буйство технологии несло в себе следующие проблемы:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Всё, в смысле 80% логики приложения - один класс. (банальность)&lt;/li&gt;&lt;li&gt;Работа с данными не читабельна на корню. (банальность)&lt;/li&gt;&lt;li&gt;То, что приходит с (ну потом и уходит на) сервера совпадает с тем, что хранит модель процентов на 60. Что-то вычисляется, что-то нужно для работы самой формы, назначение чего-то никто не знает. (сабж)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Последний пункт вызывал проблемы косвенно, но весьма изрядные: и в модели формы и в структурах, которыми общался сервер был ряд полей реально не используемых на разных этапах жизни этих данных. Кое-что перекладывалось из одного поля в другое в некоторые волшебные моменты времени. В общем удержать в голове что-откуда-куда-зачем было абсолютно нереально.&lt;/p&gt;&lt;p&gt;И вот мне была поставлена задача создать новую модель данных для формы и и продумать какую-то кхм... ну пускай архитектуру для работы с данными. Причём предполагалось добавление альтернативных отображений тех-же данных - с каким-то комбинированием полей, новыми вычислимыми полями и т.п.&lt;/p&gt;&lt;p&gt;Мысль мне пришла достаточно быстро: ввести 3 уровня.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Структуры для взаимодействия с сервером, просто структуры.&lt;/li&gt;&lt;li&gt;Доменные классы. Несущие только то, что необходимо для операций над данными и показа пользователю.&lt;/li&gt;&lt;li&gt;Классы модели для конкретных представлений. Отображение второго уровня под нужны конкретного представления и локально-значимые поля.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;И вроде-бы всё хорошо - уровни выделены, для каждой функции боле-менее понятно где она должна лежать, количество информации для единовременного хранения в памяти программиста должно резко пойти на убыль. Вот только повторяются структуры на этих уровнях процентов на 80. Одно и то же поле ObjName, именно оно самое, с нулевой семантической вариацией повторяется 3, а в перспективе и больше раз.&lt;/p&gt;&lt;p&gt;Альтернатива совсем очевидна - дополнить структуры используемые при общении с сервером недостающими полями и логикой. Повторений нет, но один и тот-же класс использовался бы в нескольких местах абсолютно по-разному.&lt;/p&gt;&lt;p&gt;Так что-же получается: выбор дублирование или разрыв мозга? Может есть решение без таких крайностей? Я не нашёл :(&lt;/p&gt;&lt;p&gt;Ещё интересно кто какой вариант выбрал бы в такой ситуации?&lt;/p&gt;</description><pubDate>Mon, 12 Jul 2010 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2010-06-12-on-testers/</guid><link>https://cheatex.cc/posts-output/2010-06-12-on-testers/</link><title>Немного мыслей о тестировании и тестерах</title><description>&lt;p&gt;Последние пара дней отличились интенсивностью общения с группой тестирования, что повлекло ряд мыслей...&lt;/p&gt;&lt;p&gt;Во-первых, какие задачи решают баг-репорты:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Идентификационную. Если у нас есть какая-то штука, то мы должны уметь посмотреть на другую и сказать "она такая-же" или "она другая". Тут надо понимать, что имеется в виду не просто уникальная цифра, а именно возможность имея перед глазами какую-то картину, пусть и с затратами, понять сталкивались ли мы с этим раньше(хотя цифра тоже не лишняя: с ней мы изрядно экономим на трафике и длине логов в месенджерах).&lt;/li&gt;&lt;li&gt;Документирующую ака историческую. В проекте всё должно быть записано. Потомки должны знать ошибки предыдущих поколений, и знать, что это ошибки, и иметь возможность их найти позже.&lt;/li&gt;&lt;li&gt;Коммуникативную. Крайнее Ответственное лицо должно узнать о том, что что-то "не так". Мало того узнав оно должно не бежать в соседнюю комнату или ждать пока к нему подойдут, чтобы потыкать пальцем в монитор. Оно должен после прочтения брать и воспроизводить проблему.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Далее, как метко &lt;a href='http://www.slideshare.net/Cartmendum/testlabs09-part-i'&gt;подмечает&lt;/a&gt; товарищ &lt;a href='http://cartmendum.livejournal.com/'&gt;Сartmendum&lt;/a&gt; основная боевая мощь живых тестеров сконцентрирована в двух фичах:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Способности "смотреть по сторонам". То есть замечать окружение ошибки и передавать важные его особенности.&lt;/li&gt;&lt;li&gt;Написании репортов на "человеческом языке". То есть рассказывать не что падает, а как падает.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;А теперь, проникнувшись важностью процесса тестирования и благородной миссией людей его выполняющих, закрываем глаза и представляем баг из одного скриншота (в jpg кстати, но это другая история...) с обведённым в пейнте каким-то полем и комментарием типа: "Illegal status of nuclear fusion reactor"... &lt;/p&gt;&lt;p&gt;Грустно. Сколько задач решает такая штука? А сколько времени убивается на то, чтобы эти задачи всё-таки решить?&lt;/p&gt;&lt;p&gt;А сколько заняло бы создание нормального описания ошибки?&lt;/p&gt;</description><pubDate>Sat, 12 Jun 2010 00:00:00 +0400</pubDate></item><item><guid>https://cheatex.cc/posts-output/2010-02-25-what-to-ask/</guid><link>https://cheatex.cc/posts-output/2010-02-25-what-to-ask/</link><title>Что интересно спросить у работодателя</title><description>&lt;h3 id="анализ,&amp;#95;общение&amp;#95;с&amp;#95;пользователями"&gt;Анализ, общение с пользователями&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Откуда берутся требования?&lt;ul&gt;&lt;li&gt;Как оценивается их выполнение?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Требования пересматриваются?&lt;ul&gt;&lt;li&gt;По каким причинам?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Как часто пользователь получает результаты работы?&lt;/li&gt;&lt;li&gt;Участвуют ли пользователи и эксперты в разработке?&lt;ul&gt;&lt;li&gt;В каких формах?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Что предпринимается в случае выявления противоречивости требований?&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="процесс,&amp;#95;планирование"&gt;Процесс, планирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Как формируются задачи на основе требований?&lt;/li&gt;&lt;li&gt;Как оцениваются сроки их выполнения?&lt;/li&gt;&lt;li&gt;Что предпринимается в случае невозможности выполнения требований по&lt;ul&gt;&lt;li&gt;техническим причинам?&lt;/li&gt;&lt;li&gt;организационным причинам?&lt;/li&gt;&lt;li&gt;экономическим причинам?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="программирование"&gt;Программирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Какая VCS используется? Почему?&lt;/li&gt;&lt;li&gt;Есть-ли стандарт кодирования?&lt;ul&gt;&lt;li&gt;Какие аспекты кода он регламентирует?&lt;/li&gt;&lt;li&gt;Как контроллируется его соблюдение?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Сколько человек видят/рецензируют код до его попадания в production?&lt;ul&gt;&lt;li&gt;Как это обеспечивается?&lt;/li&gt;&lt;li&gt;Обязательно-ли исправление по итогам сбора отзывов?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Как происходит сборка продукта?&lt;/li&gt;&lt;li&gt;Есть-ли система автоматической сборки?&lt;ul&gt;&lt;li&gt;Какие действия она предпринимает в случае успеха/неудачи сборки?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Имеет-ли разработчик в своём распоряжении полный стенд разрабатываемого продукта или какие-то его части?&lt;ul&gt;&lt;li&gt;Этот стенд изолирован от других разработчиков?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="контроль&amp;#95;качества,&amp;#95;тестирование"&gt;Контроль качества, тестирование&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;На какие уровнях производится тестирование?&lt;ul&gt;&lt;li&gt;Как каждый из них автоматизирован?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Есть-ли люди ответственные за контроль качества?&lt;ul&gt;&lt;li&gt;Сколько их от общего числа разработчиков?&lt;/li&gt;&lt;li&gt;Какие задачи они решают?&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Thu, 25 Feb 2010 00:00:00 +0300</pubDate></item><item><guid>https://cheatex.cc/posts-output/2008-10-22-jboss-per-app-logs/</guid><link>https://cheatex.cc/posts-output/2008-10-22-jboss-per-app-logs/</link><title>Раздельные логи приложений в JBoss</title><description>&lt;p&gt;Встала задача организовать раздельную запись логов для нескольких экземпляров одного и того-же приложения, запущенных на сервере(разделение экземпяров просто переименование war-ок). При этом дополнительно хотелось получить также: конфигурирование логов отдельно от самого сервера(читай не в серверном &lt;code&gt;jboss-log4j.xml&lt;/code&gt;, а в собственном конфиге приложения, один экземпляр log4j как на диске, так и в памяти.&lt;/p&gt;&lt;p&gt;Простая упаковка конфига вместе с приложением успеха, как и ожидалось, не принесла. Если верить форумам/мэйллистам причина в том, что по умолчанию JBoss подкладывает приложениям свои библиотеки в класспат, соответственно приложения используют уже инициализированный экземпляр log4j.&lt;/p&gt;&lt;p&gt;Вторым этапом стала попытка использовать хак со слушателем контекста и установкой в нём &lt;code&gt;RepositorySelector&lt;/code&gt; взятый &lt;a href='http://docs.jboss.org/process-guide/en/html/logging.html'&gt;тут&lt;/a&gt;, раздел 10.3.8(что примечательно попал он мне на глаза сначала в каком-то блоге, а не в оф. доке). Работал он плохо: при переразвёртываниии приложения падала ошибка при инициализации JBoss log4j plugin. Думаю из за того, что при этом старый ClassLoader убивается и все созданные им классы вместе с ним. Заниматься дебагом сервера было немного лень, а сообщение обошибке было, мягко говоря, кратким.&lt;/p&gt;&lt;p&gt;В третий заход применил подход описанный &lt;a href='http://docs.jboss.org/process-guide/en/html/logging.html'&gt;там-же&lt;/a&gt; в разделе 10.3.6. А именно: положил в папку &lt;code&gt;WEB-INF/lib&lt;/code&gt; log4j и commons-logging(в своём приложении на всякий случай решил использовать его, а не напряму log4j), положил в папку &lt;code&gt;WEB-INF/classes&lt;/code&gt; свой &lt;code&gt;log4j.xml&lt;/code&gt; а также создал файлик &lt;code&gt;jboss-web.xml&lt;/code&gt;(до этого обходился стандартным дескриптором) с содержимым, описанным в доке чуть ниже.&lt;/p&gt;&lt;p&gt;Потом ещё переучил оставшийся с прошлой попытки листенер записывать в системные свойства имена приложения(точнее контекста) и конфига(&lt;code&gt;log4j.xml&lt;/code&gt;). (В спринге есть специальный, более одарённый листенер для этих целей, но спринга пока в проекте нет и связываться было лень.)&lt;/p&gt;&lt;p&gt;Commons-logging увидел старшого брата без дополнительных манипуляций.&lt;/p&gt;&lt;p&gt;Результат: аккуратненький набор папочек в &lt;code&gt;/log&lt;/code&gt; сервера с подневными логами соответствующих приложений. Надо отметить, что это, между тем, не совсем нирвана ибо экземпляр log4j на каждое приложение - и память не по делу и место на диске... в эпоху гигабайтных планок не сильно проблемно, но всё-таки. Есть мнение, что если поглубже покопать в серверный класслоадинг (точнее хоть чуть-чуть копнуть, ибо то, что вписал в конфигурашку я понял приближённо) можно её и достичь...&lt;/p&gt;</description><pubDate>Wed, 22 Oct 2008 00:00:00 +0400</pubDate></item></channel></rss>